(using [list compilers dict net dom]
  ## tag-defs need only be loaded once then used from the cache - all promises
  (ref tag-defs (stateful))

  ## pre-loaded facetz templates may not exist in dev
  (lispz.merge! { facetz: {} })

  ## convert HTML into a DOM fragment
  (ref html-to-DOM (lambda [html]
    (ref dom-fragment (document.createElement "div"))
    (stateful.morph! dom-fragment { innerHTML: html })
  ))

  ## all styles in facetz are global - so inject them into head
  (ref inject-styles (lambda [html-collection]
      (ref style-elements (slice html-collection))
      (list.for-each style-elements (lambda [style-element]
        (head-element.appendChild style-element)
      ))
  ))
  (ref head-element
    (first (document.getElementsByTagName "head"))
  )

  ## compile scripts as functions expecting a tag structure
  ## as parameter when an instance of the tag is instantiated
  ## on the page
  (ref compile-scripts (lambda [html-collection tag-name]
    (ref script-nodes (slice html-collection))
    (ref combined-code (map script-nodes (lambda [script-node]
      ## remove from tag template
      (script-node.parentNode.removeChild script-node)
      (ref code script-node.innerHTML)
      (ref explicit-type (script-node.getAttribute "type"))
      (ref type (or explicit-type "javascript"))
      (ref ext (last (type.split "/")))
      (ref compiler (get compilers type))
      (compiler code (+ tag-name ".facetz"))
    )))
    (new Function "tag" (combined-code.join "\n"))
  ))

  ## we don't know this tag - load it from the server...
  (ref load-tag (lambda [tag-name]
    (ref url (+ tag-name ".facetz.html"))
    (after (net.http-get url)
      (compile-tag-defs @)
      (get tag-defs tag-name)
    )
  ))

  ## for each tag extracted from the template, pull out style and
  ## scripts so that it is pure view. Drop style into head and
  ## compile scripts to use for tag logic.
  (ref extract-html-css-and-scripts (lambda [node]
    (inject-styles (node.getElementsByTagName "style"))
    (ref script-elements (node.getElementsByTagName "script"))
    (ref tag-name (node.tagName.toLowerCase))
    (ref script (compile-scripts script-elements tag-name))
    { node script name: tag-name }
  ))

  ## a container we clone to hold the DOM for each tag
  (ref tag-box (document.createElement "div"))

  ## split tag into html, css and script
  ## and act on each accordingly
  (ref compile-tag-defs-in-DOM (lambda [dom-fragment]
    (ref tag-doms (dom.node.children dom-fragment))
    (tag-doms.forEach (=>
      (ref tag (extract-html-css-and-scripts @))
      (tag-defs.replace! tag.name tag)
    ))
  ))
  (ref compile-tag-defs (lambda [tag-html]
    (compile-tag-defs-in-DOM (html-to-DOM tag-html))
  ))

  ## fetch a tag definition - cached locally or from the server
  (ref retrieve-tag-def (lambda [tag-name]
    (cond
      (ref tag-def (get tag-defs tag-name))
        tag-def
      (ref tag-src (get lispz.facetz tag-name))
        (compile-tag-defs tag-src)
      (else)
        (load-tag tag-name)
    )
  ))

  ## a facetz tag is either pre-defined, has a facetz attribute
  ## or has a dash in the name: <my-node> or <mynode facetz>
  ## if not loaded
  (ref is-facetz-tag (lambda [node]
    (ref name (dom.node.name node))
    (or
      (get tag-defs name)
      (isnt (name.indexOf "-") -1)
      (node.hasAttribute "facetz")
    )
  ))

  ## find all facetz references that are children of a node
  (ref find-facetz-tags (lambda [node]
    (ref all-nodes (slice (node.querySelectorAll "*")))
    (list.filter all-nodes is-facetz-tag)
  ))

  ## find all actors that are not in templates
  (ref nodes-with-actors (lambda [parent]
      (ref all-actors (dom.select parent "[actor]"))
      (ref templates-excluded (list.filter all-actors (=>
        (not (dom.node.has-parent-with-class @ "template"))
      )))
      (ref has-actor (=> (@.getAttribute "actor")))
      (dict.from-list templates-excluded has-actor)
  ))

  ## given a tag definition, create an instance to insert
  ## into the DOM. Requires recursive pass to instantiate
  ## child tags
  (ref mount-tag (lambda [placeholder]
    (ref name (dom.node.name placeholder))
    (ref tag-def (retrieve-tag-def name))
    (when [tag-def]
      (ref instance (dom.node.copy placeholder tag-def.node))
      (ref refs (dict.from-list
        (dom.select placeholder "[name]")
        (=> (@.getAttribute "name"))
      ))
      ## find all actors that are not in templates
      (ref actors (nodes-with-actors placeholder))
      ## find named fragments, add body as all if needed
      (ref named (dict.from-list (dom.node.children placeholder)
        (=> (@.getAttribute "name"))
      ))
      (cond (not named.body) (named.update! { body: placeholder }))
      ###
        tag-def:  tag definition from facetz component
        data:     node list for dynamic tag contents
        actors:   nodes with actors for activation phase
        activate: call in component with dict of actor functions
        fill:     hlf fill node with cloned inner nodes of data
        html:     hlf set innerHTML from text
        transfer-attribute: hlf move attr from tag to node
        use-template: insert items above template
      ###
      (stateful.morph! instance {
        tag-def named actors refs
        activate-template activate
        transfer-attribute fill html
      })
      ## place directly on tag if name is unique
      (dict.for-each named (lambda [key value]
        (cond (not (get instance key)) (instance.update! key value))
      ))
      (dom.node.merge-attributes instance tag-def.node)
      (mount-tags instance) ## recurse through inner facetz
      (tag-def.script instance)
    )
  ))

  ## look for tags in the node and mount them
  ## must be sequential for when tags in same file
  (ref mount-tags (lambda [node]
    (ref tags (find-facetz-tags node))
    (ref mount (lambda [idx]
      (cond (ref tag (get tags idx))
        (after (mount-tag tag) (mount (+ idx 1)))
      )
    ))
    (mount 0)
  ))

  ### ref: (tag.activate nvp)
      <ul class="a-class" name=a-list actors=list-class>
        <li class=template actors=fill-list>
          <b><span actors=title></span></b>
        </li>
      </ul>
      (tag.activate {
        list-class: (=> (@.classList.add("b-class")))
        fill-list:  (lambda [node]
          (list.for-each entries (=>
            (tag.use-template node @)
          ))
        )
      })
  ###
  (ref activate (lambda [actors] (ref tag this)
    (dict.for-each tag.actors (lambda [to-do node]
      ## convert atoms to a form recognised by js (i.e. - == _)
      (ref names (list.map (to-do.split '/\s*,\s*/') lispz.jsify))
      (names.for-each (=>
        (cond (ref actor (get actors to-do)) (actor node))
      ))
    ))
  ))
  (ref activate-template (lambda [template items]
    (ref tag    this)
    (ref parent template.parentNode)
    (list.for-each items (lambda [item]
      (ref node (template.cloneNode true))
    ))
  ))
  (ref transfer-attribute (curry [key node] (ref tag this)
    (cond (ref value (get tag.attributes key))
      (node.setAttribute key value)
    (else)
      (dom.node.remove node)
    )
  ))
  (ref fill (curry [key node] (ref tag this)
    (ref contents (get tag.named (or key "body")))
    (dom.node.fill node contents.childNodes)
  ))
  (ref html (curry [text node] (dom.inner-html! node text)))

  ## index.html can have <template> holding tag defs
  (ref templates (document.getElementsByTagName "template"))
  ((slice templates).forEach (lambda [template]
    ## remove template so it is not processed as a facetz instance
    (compile-tag-defs-in-DOM template.content)
  ))

  ## add a style block to the header
  (dom.global-styles ".template { display: none }")

  ## last thing is to mount any tags in index.html
  (mount-tags document.body)

  (export { compile-tag-defs mount-tags activate })
)
