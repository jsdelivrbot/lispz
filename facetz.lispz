(using [list compilers dict net dom]
  ## tag-defs need only be loaded once then used from the cache
  ##  - all promises
  (ref tag-defs (stateful))

  ## pre-loaded facetz templates may not exist in dev
  (lispz.merge! { facetz: {} })

  ## convert HTML into a DOM fragment
  (ref html-to-DOM (lambda [html]
    (ref dom-fragment (document.createElement "div"))
    (dom.inner-html! dom-fragment html)
  ))

  ## all styles in facetz are global - so inject them into head
  (ref inject-styles (lambda [html-collection]
      (ref style-elements (slice html-collection))
      (list.for-each style-elements (lambda [style-element]
        (head-element.appendChild style-element)
      ))
  ))
  (ref head-element
    (first (document.getElementsByTagName "head"))
  )

  ## compile scripts as functions expecting a tag structure
  ## as parameter when an instance of the tag is instantiated
  ## on the page
  (ref compile-scripts (lambda [html-collection tag-name]
    (ref script-nodes (slice html-collection))
    (ref combined-code (map script-nodes (lambda [script-node]
      ## remove from tag template
      (script-node.parentNode.removeChild script-node)
      (ref code script-node.innerHTML)
      (ref explicit-type (script-node.getAttribute "type"))
      (ref type (or explicit-type "javascript"))
      (ref ext (last (type.split "/")))
      (ref compiler (get compilers type))
      (compiler code (+ tag-name ".facetz"))
    )))
    (new Function "tag" (combined-code.join "\n"))
  ))

  ## we don't know this tag - load it from the server...
  (ref load-tag (lambda [tag-name]
    (ref url (+ tag-name ".facetz.html"))
    (after (net.http-get url)
      (compile-tag-defs @)
      (get tag-defs tag-name)
    )
  ))

  ## for each tag extracted from the template, pull out style and
  ## scripts so that it is pure view. Drop style into head and
  ## compile scripts to use for tag logic.
  (ref extract-html-css-and-scripts (lambda [node]
    (inject-styles (node.getElementsByTagName "style"))
    (ref script-elements (node.getElementsByTagName "script"))
    (ref tag-name (dom.node.name node))
    (ref script (compile-scripts script-elements tag-name))
    { node script name: tag-name }
  ))

  ## a container we clone to hold the DOM for each tag
  (ref tag-box (document.createElement "div"))

  ## split tag into html, css and script
  ## and act on each accordingly
  (ref compile-tag-defs-in-DOM (lambda [dom-fragment]
    (ref tag-doms (dom.node.children dom-fragment))
    (tag-doms.forEach (=>
      (ref tag (extract-html-css-and-scripts @))
      (tag-defs.replace! tag.name tag)
    ))
  ))
  (ref compile-tag-defs (lambda [tag-html]
    (compile-tag-defs-in-DOM (html-to-DOM tag-html))
  ))

  ## fetch a tag definition - cached locally or from the server
  (ref retrieve-tag-def (lambda [tag-name]
    (cond
      (ref tag-def (get tag-defs tag-name))
        tag-def
      (ref tag-src (get lispz.facetz tag-name))
        (do (compile-tag-defs tag-src) (get tag-defs tag-name))
      (else)
        (load-tag tag-name)
    )
  ))

  ## a facetz tag is either pre-defined, has a facetz attribute
  ## or has a dash in the name: <my-node> or <mynode facetz>
  ## if not loaded
  (ref is-facetz-tag (lambda [node]
    (ref name (dom.node.name node))
    (or
      (get tag-defs name)
      (isnt (name.indexOf "-") -1)
      (and node.hasAttribute (node.hasAttribute "facetz"))
    )
  ))

  ## see if a node has a parent that is a facetz
  (ref has-facetz-parent-in-node
    (dom.node.has-specific-parent is-facetz-tag)
  )

  ## find all facetz references that are children of a node
  (ref find-facetz-tags (lambda [parent]
    (ref all-nodes (slice (parent.querySelectorAll "*")))
    (list.filter all-nodes (lambda [child]
      (and
        (is-facetz-tag child)
        (not (has-facetz-parent-in-node parent child))
      )
    ))
  ))

  ## find all actors that are not in templates
  (ref nodes-with-actors (lambda [parent]
      (ref all-actors (dom.select parent "[actor]"))
      (ref templates-excluded (all-actors.filter (=>
        (not (dom.node.has-parent-with-class @ "template"))
      )))
      (ref has-actor (=> (@.getAttribute "actor")))
      (dict.from-list templates-excluded has-actor)
  ))

  ## given a tag definition, create an instance to insert
  ## into the DOM. Requires recursive pass to instantiate
  ## child tags
  (ref mount-tag (lambda [tag]
    (ref name (dom.node.name tag))
    (ref refs    (get-named-components tag))
    (add-body     refs tag)
    (ref tag-def (retrieve-tag-def name))
    (when [tag-def]
      (dom.node.fill tag tag-def.node)
      (ref actors   (nodes-with-actors tag))
      (personalise! tag tag-def refs actors)
      (tag-def.script tag)
      (mount-tags   tag)
      (ref named    (get-named-components tag))
      (add-components-to-tag tag named)
    )
  ))
  (ref personalise! (lambda [tag tag-def refs actors]
    ###
      tag-def:  tag definition from facetz component
      refs:     node list for dynamic tag contents
      actors:   nodes with actors for activation phase
      activate: call in component with dict of actor functions
      fill:     hlf fill node with cloned inner nodes of data
      html:     hlf set innerHTML from text
      transfer-attribute: hlf move attr from tag to node
      use-template: insert items above template
    ###
    (stateful.morph! tag {
      tag-def actors refs
      activate-template activate
      transfer-attribute fill html
    })
  ))
  (ref get-named-components (lambda [placeholder]
    (ref named (dom.select placeholder "[name]"))
    (ref has-facetz-parent
      (has-facetz-parent-in-node placeholder)
    )
    (dict.from-list
      (filter named (=> (not (has-facetz-parent @))))
      (=> (@.getAttribute "name"))
    )
  ))
  (ref add-body (lambda [refs placeholder]
    (cond (not refs.body)
      (refs.update! { body: (placeholder.cloneNode true) })
    )
  ))
  (ref add-components-to-tag (lambda [tag named]
    (tag.update! { named })
    (dict.for-each named (lambda [key value]
      (cond (not (get tag key)) (tag.update! key value))
    ))
  ))

  ## look for tags in the node and mount them
  ## must be sequential for when tags in same file
  (ref mount-tags (lambda [node]
    (ref tags (find-facetz-tags node))
    (ref mount (lambda [idx]
      (cond (ref tag (get tags idx))
        (after (mount-tag tag) (mount (+ idx 1)))
      )
    ))
    (mount 0)
  ))

  (ref fill (curry [key node] (ref tag this)
    (ref contents (get tag.refs (or key "body")))
    (cond contents (dom.node.fill node contents))
  ))
  
  ### (facetz.implicit-actors.update! {my-actor: (lambda [node])})
      where this is the tag this actor and element is related to.

      fill-body: fills node with contents from tag instance
  ###
  (ref implicit-actors (stateful {
    fill-body: (fill "body")
  }))

  ### ref: (tag.activate nvp)
      <ul class="a-class" name=a-list actors=list-class>
        <li class=template actors=fill-list>
          <b><span actors=title></span></b>
        </li>
      </ul>
      (tag.activate {
        list-class: (=> (@.classList.add("b-class")))
        fill-list:  (lambda [node]
          (list.for-each entries (=>
            (tag.use-template node @)
          ))
        )
      })
  ###
  (ref activate (lambda [actors] (ref tag this)
    (dict.for-each tag.actors (lambda [to-do node]
      (ref explicit-actors (or actors {}))
      ## convert atoms to a form recognised by js (i.e. - == _)
      (ref names (list.map (to-do.split '/\s*,\s*/') lispz.jsify))
      (list.for-each names (lambda [name]
        (cond
          (ref act (get explicit-actors name)) (act.call tag node)
          (ref act (get implicit-actors name)) (act.call tag node)
        )
      ))
    ))
  ))
  (ref activate-template (lambda [template items]
    (ref tag    this)
    (ref parent template.parentNode)
    (list.for-each items (lambda [item]
      (ref node (template.cloneNode true))
    ))
  ))
  (ref transfer-attribute (curry [key node] (ref tag this)
    (cond (ref value (tag.getAttribute key))
      (node.setAttribute key value)
    (else)
      (node.removeAttribute key)
    )
  ))
  (ref html (curry [text node] (dom.inner-html! node text)))

  ## index.html can have <template> holding tag defs
  (ref templates (document.getElementsByTagName "template"))
  ((slice templates).forEach (lambda [template]
    ## remove template so it is not processed as a facetz instance
    (compile-tag-defs-in-DOM template.content)
  ))

  ## add a style block to the header
  (dom.global-styles ".template { display: none }")

  ## last thing is to mount any tags in index.html
  (mount-tags document.body)

  (export {
    compile-tag-defs mount-tags activate implicit-actors
  })
)
