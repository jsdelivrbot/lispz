### spec: async >> Messaging
###
(using [list]
  (ref store (stateful)) (ref expecting   (stateful))
  (ref links (stateful)) (ref dispatchers (stateful))
  (ref in-store (pull store))
  (ref get-link (pull links))

  (ref add-to-store (=>
    (ref observers (stateful []))
    (store.update! @ observers)
    observers
  ))

  ### spec: async >> Messaging >> (exchange)
    given an address return the list of recipients who are interested in
    mail sent to this address. It will create a new list of observers if needed.
  ###
  (ref exchange (lambda [address]
    (or (in-store address) (add-to-store address))
  ))

  (ref ready (promise [address]
    (ref observers (exchange address))
    (cond (length observers)
      (promise.resolved)
    (else)
      (expecting.update! address resolve-promise)
    )
  ))

  ## remove a recipient from all attached addresses
  (ref remove (lambda [address recipient]
    (ref observers (exchange address))
    (store.update! address
      (stateful (observers.filter (lambda [possibility]
        (return (isnt recipient possibility)))
      ))
    )
  ))

  ## clear all listeners for an address
  (ref clear (lambda [address] (store.update! address (stateful []))))

  (ref link (lambda [primary secondary]
    (ref primary-links (or
      (get-link primary)
      (links.update! primary (stateful [])))
    )
    (primary-links.push! secondary)
  ))

  (add-execution-context-logger "message.send" (lambda [context error-args]
    (return (+ "to " context.address ", packet " context.packet))
  ))
  ###
  (ref send (promise [address packet]
    (execution-context {context: "message.send" address packet}
      ## take a copy so that it does not change during processing
      (ref result-promises (stateful []))
      (ref sender (lambda [recipient]
        ## yield so that we don't lock up the current thread
        (result-promises.push! (recipient.listener=> packet))
        (cond recipient.once (remove recipient))
      ))
      (ref observers (exchange address))
      (observers.forEach sender)
      (ref secondaries (or (get-link address) [[]]))
      (list.for-each secondaries (lambda [link] (send link packet)))
      (when (promise.all result-promises) [results]
        (resolve-promise (list.squash results))
      )
    )
  ))
  ###
  (ref send (lambda [address packet]
    (execution-context {context: "message.send" address packet}
      ## take a copy so that it does not change during processing
      (ref result (stateful))
      (ref sender (lambda [recipient]
        (result.update! "contents" (recipient.listener=> packet))
        (cond recipient.once (remove recipient))
      ))
      (ref observers (exchange address))
      (observers.forEach sender)
      (ref secondaries (or (get-link address) [[]]))
      (list.for-each secondaries (lambda [link] (send link packet)))
    ) (return (promised result.contents))
  ))

  (ref add-observer (lambda [address envelope]
    (ref observers (exchange address))
    (observers.push! envelope)
    (ref expected-mail-action (get expecting address))
    (cond (and (is observers.length 1)  (get expecting address))
          (do (expected-mail-action) (delete expected-mail-action)))
  ))

  (ref expect (lambda [address listener=>]
    (add-observer address {once: true listener=>})
  ))

  (ref listen (lambda [address listener=>]
    (add-observer address {listener=>})
  ))

  (add-execution-context-logger "message.dispatch" (lambda [context error-args]
    (return (+ "received from " context.address " packet " context.packet))
  ))
  ### spec: async >> Messaging >> dispatch
  Here a code editor will wait on messages to open a new 'file'. The message
  includes a name unique to each code editor. The dictionary at the end can
  include any number of named requests. Each associated function takes a packet
  whose content format is known by clients and services.

      (using [message]
        (ref open (lambda [packet] ...)
        (message.dispatch (+ "code-editor/" opts.name) { open })

  The client will send a command to open a new file for display. If the editor
  is called 'scratch':

      (message.send "code-editor/scratch"
        {action: "open" key: "scratchpad.lispz" contents: null}
      )

  In most cases it is easier to use a connector function

      (ref scratchpad (message.connect "code-editor/scratch"))
      ...
      (scratchpad.open {key: "scratchpad.lispz" contents: null})
  ###
  (ref dispatch (lambda [address actions]
    (ref get-action (pull actions))
    (dispatchers.update! address actions)
    (listen address (lambda [packet]
      (execution-context {context: "dispatch" address packet}
        (ref action (get-action packet.action))
        (cond (not action) (promise.resolved false))
      )
      (action packet)
    ))
  ))
  (ref connect (lambda [address] (get dispatchers address)))

  (ref log (lambda [text]
    (ref parts (text.split '/\s*:\s*/'))
    (cond (is 1 parts.length) (parts.unshift "message"))
    (send "logging" {level: (first parts) text: (second parts)})
  ))

  (listen "logging" (lambda [packet]
    (console.log packet.level "-" packet.text)
  ))

  (export {exchange send expect listen dispatch ready clear link connect})
)
