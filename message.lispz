(var store {}  expecting {})

(var exchange (lambda [address]
  (var envelope (get store address))
  (return? envelope)
  (return (dict.update! store address [[]]))
))

(var add (lambda [address envelope]
  (var envelopes (exchange address))
  (envelopes.push envelope)
  (cond (and (is envelopes.length 1) (get expecting address))
        (do ((get expecting address)) (delete (get expecting address))))
))

## remove a recipient from all attached addresses
(var remove (lambda [recipient]
  (dict.update! exchange address
    ((exchange address).filter (lambda [possibility]
      (return (isnt recipient possibility))
    ))
  )
))

(var send (lambda [address packet reply=>]
  (var reply (default? reply=> (=>)))
  ## take a copy so that it does not change during processing
  (((exchange address).slice).forEach (lambda [recipient]
    (yield (reply (recipient.listener=> packet)))
    (cond recipient.once (remove recipient))
  ))
))

(var expect (lambda [address listener=>]
  (add address {once: true listener=>})
))

## Only add expect if no other listeners - otherwise respond immediately
(var wait-for (lambda [address listener=>]
  (return-if (length (exchange address)) (listener=>))
  (dict.update! expecting address listener=>)
))

(var listen (lambda [address listener=>]
  (add address {listener=>})
))

(var dispatch (lambda [address actions]
  (listen address (lambda [packet]
    (var action (get actions packet.action))
    (return-if (not action) false)
    (action packet)
  ))
))

(export {exchange send expect listen dispatch wait-for})
