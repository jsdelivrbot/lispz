(var store {}  expecting {})

(var exchange (lambda [address]
  (var envelope (get store address))
  (return? envelope)
  (return (dict.update! store address [[]]))
))

(var add (lambda [address envelope]
  (var envelopes (exchange address))
  (envelopes.push envelope)
  (cond (and (is envelopes.length 1) (get expecting address))
        (do ((get expecting address)) (delete (get expecting address))))
))

(var ready (promise [address]
  (return-if (length (exchange address)) (promise.resolved))
  (dict.update! expecting address resolve-promise)
))

## remove a recipient from all attached addresses
(var remove (lambda [recipient]
  (dict.update! exchange address
    ((exchange address).filter (lambda [possibility]
      (return (isnt recipient possibility))
    ))
  )
))

(var send (lambda [address packet]
  ## take a copy so that it does not change during processing
  (var result null)
  (((exchange address).slice).forEach (lambda [recipient]
    (var result (recipient.listener=> packet))
    (cond recipient.once (remove recipient))
  ))
  (return (promise? result))
))

(var expect (lambda [address listener=>]
  (add address {once: true listener=>})
))

(var listen (lambda [address listener=>]
  (add address {listener=>})
))

(var dispatch (lambda [address actions]
  (listen address (lambda [packet]
    (var action (get actions packet.action))
    (return-if (not action) (promise.resolved false))
    (return (action packet))
  ))
))

(var log (lambda [text]
  (var parts (text.split '/\s*:\s*/'))
  (cond (is 1 parts.length) (parts.unshift "message"))
  (send "logging" {level: (get parts 0) text: (get parts 1)})
))

(listen "logging" (lambda [packet]
  (console.log packet.level "-" packet.text)
))

(export {exchange send expect listen dispatch ready})
