### spec: >> GitHub
  A higher-level wrapper around the Github API.
  Intended for the browser.

  https://github.com/michael/github
###
(using  [net dict list axios base64 utf8]
  ### spec: GitHub >> CDN
    It is possible to access GitHub files for direct use in the browser through
    a CDN. Provide the project name, hash/branch/release and a path to the file.
  ###
  ### ref: (github.cdn-uri project hash filepath)
    e.g. (ref uri (github.cdn-uri "atogov/RAM" "develop" "tests/pasckages.json"))
  ###
  (ref cdn-uri (lambda [project hash filepath]
    (return (+ "https://cdn.rawgit.com/" project "/" hash "/" filepath))
  ))
  ### spec: GitHub >> Specifying the Current Repository
    This is a non-pure function because if this is the first connection to
    GitHub, a UI modal dialog is displayed for GitHub log-in details.
  ###
  ### ref: (github.repo> project) ## log in form displayed if necessary
    e.g. (ref repo (github.repo> "paulmarrington/lispz"))
  ###
  (ref repo> (lambda [project]
    (ref connect-to-repo (lambda [session]
      (ref parts (project.split "/"))
      (ref github (session.auth.getRepo (first parts) (second parts)))
      (stateful { project github session branch: "master" })
    ))

    (promise.cascade> session> connect-to-repo)
  ))
  ### (projects> session-or-repo project-owner)
    promise returns a list of projects for owner/org
  ###
  (ref projects> (lambda [session-or-repo project-owner]
    (ref session (or session-or-repo.session session-or-repo))
    (ref org (session.auth.getOrganization project-owner))
    (=> org.getRepos)
  ))

  ### ref: (github.session>)
    Start a GitHub session. User-name and password are retrieved from
    browser storage if available. If not a modal dialog allows a user
    to enter the details.
  ###
  (ref session> (=>
    (ref user (or
      (sessionStorage.getItem "ghstate")
      (localStorage.getItem "ghstate")
    ))
    (cond user (do
      (ref user&pwd ((atob user).split "||"))
      (promised (start-session (first user&pwd) (last user&pwd)))
    ) (else) ## no user has logged in yet
      ((promise (using [bootstrap]
        (when (bootstrap.modal> "github/github-login" {}) [r]
          (cond (is r.login.value "true") (do
            (save-user r.username.value r.password.value r.remember.checked)
            (resolve-promise (start-session r.username.value r.password.value))
          ) (else)
            (reject-promise { error: true reason: "User abort" })
          )
        )
      )))
    )
  ))
  (ref start-session (lambda [username password]
    (ref auth (new Github {username password auth: "basic"}))
    { username password auth }
  ))
  (ref save-user (lambda [name password remember]
    (ref user (btoa (+ user "||" password)))
    (cond (is remember)
      (localStorage.setItem "ghstate" user)
    (else) (do ## user wants amnesia
      (localStorage.removeItem "ghstate")
      (sessionStorage.setItem "ghstate" user)
    ))
  ))
  ### ref: (github.branch repo branch-name)  ## set branch (default master) ###
  (ref branch (promise [repo branch-name]
    (repo.update! { branch: branch-name })
  ))
  ### ref: (github.list-dir> repo dir-path) ###
  (ref list-dir> (promise.callback [repo path]
    (repo.github.contents repo.branch path callback)
  ))
  ### ref: (github.list-all> repo dir-path) ## list sub-directories as well ###
  (ref list-all> (promise [repo path]
    (ref result (stateful []))
    (ref list-path (lambda [path]
      (return (when (list-dir repo path) [paths]
        (ref children (stateful []))
        (paths.forEach (lambda [entry]
          (cond
            (is "dir"  entry.type)
              (cond (not single-level) (children.push! (list-path entry.path)))
            (is "file" entry.type)
              (result.push! entry.path)
          )
        ))
        (return (promise.all children))
      ))
    ))
    (when (list-path path) (resolve-promise result))
  ))
  ### ref: (github.read> repo file-path) ###
  (ref read> (promise.callback [repo path]
    (repo.github.read repo.branch path callback)
  ))
  ### ref: (gibhut.write> repo file-path contents comment) ###
  (ref write> (promise.callback [repo path contents comment]
    (cond
      (not contents.length) (promise.resolved)
      (else) (do
        (ref encoded (unescape (encodeURIComponent contents)))
        (repo.github.write repo.branch path encoded comment callback)
      )
    )
  ))
  ## preprocess a file to generate css or js dependent on extension
  (ref preprocessors {
    lispz: (lambda [name code]
      (return {path ext: "js" code: (window.lispz.compile code name)})
    )
  })
  (ref get-preprocessor (pull preprocessors))
  (ref preprocess (lambda [path code]
    (ref ext (last (path.split ".")))
    (ref preprocessor (get-preprocessor ext))
    (cond preprocessor (preprocessor path code)
                (else) {path ext code})
  ))
  ## Build and save a dependency list
  ## We will need to filter the dependencies
  (ref filter (lambda [before include exclude]
    (ref after before)
    (ref after (cond
      include (after.filter (lambda [file] (include.test file)))
      exclude (after.filter (lambda [file] (not (exclude.test file))))
    ))
    (return after)
  ))
  ## and see which to save and which to copy
  (ref copy (lambda [copy-to path code]
    ## not working yet for binary files
    (ref filename (last (path.split "/")))
    (return {path code copy: (+ copy-to "/" filename)})
  ))
  ## Load the contents of the files we need from a single repo
  (ref process-repo (lambda [source-repo files actors]
    (return (promise.all (files.map (promise [meta]
      (ref base (or meta.base ""))
      (when (actors.list-all> source-repo base meta.single-level) [file-list]
        (ref files (filter file-list meta.include meta.exclude))
        (resolve-promise (promise.all (files.map (promise [path]
          (when (actors.read source-repo path) [code]
            (cond
              meta.copy-to (resolve-promise (copy meta.copy-to path code))
              (else)       (resolve-promise (preprocess path code))
            )
          )
        ))))
      )
    ))))
  ))
  ## Given a list of repos, go through them all for files in need
  (ref process-repos (lambda [target-repo sources actors]
    (return (promise.all (sources.map (lambda [source]
      (ref source-repo (actors.repo target-repo source.repo))
      (return (process-repo source-repo source.files actors))
    ))))
  ))
  ## Retrieve file contents based of filtering meta-data
  (ref retriever (promise [target-repo sources actors]
    (when (process-repos target-repo sources actors) [entry-tree]
      (ref first-from [["Gathered from: "]])
      (ref rest-from (sources.map (lambda [source] (return source.repo))))
      (ref store {
        js:     (stateful [])
        css:    (stateful [])
        copies: (stateful [])
        from:   (first-from.concat rest-from)
      })
      ((list.flatten entry-tree).forEach (lambda [entry]
        (ref ext-list (get store entry.ext))
        (cond
          (ext-list) (do
            (ext-list.push! "\n\n/* " entry.path " */\n" entry.code)
          )
          store.copy
            (store.copies.push! entry)
        )
      ))
      (resolve-promise store)
    )
  ))
  ## Given a file type, save the concatenated source contents
  (ref save-store (promise [target-repo store name ext comment]
    (ref contents ((get store ext).join ""))
    (return (write target-repo (+ "ext/" name "." ext) contents comment))
  ))
  ## copy files identified as needed as-is
  (ref copy-store (lambda [target-repo store comment]
    (return (promise.all (store.copies.map (lambda [entry]
      (return (write target-repo entry.path entry.code comment))
    ))))
  ))
  ## Now we have gathered needed resources, build and save the output file
  (ref builder (promise [actors target-repo name sources]
    (when (retriever target-repo sources actors) [store]
      (ref comment (store.from.join " "))
      (ref saved (when (update target-repo)
        (return (promise.all
          (save-store target-repo store name "js"  comment)
          (save-store target-repo store name "css" comment)
          (copy-store target-repo store            comment)
        ))
      ))
      (when saved (resolve-promise))
    )
  ))
  (ref github-actors {
    list-all> read>
    repo: (lambda [target-repo name]
      (return (repo target-repo.username
        target-repo.password name
      ))
    )
  })
  (ref build (builder.bind null github-actors))
  ## Use gruntfile to decide which files to include and it what order
  (ref grunt-build (promise [meta]
    (ref js (stateful [(or meta.pre "")]))
    (ref read-all (promise.all (meta.files.map (promise
      (when (github-actors.read source-repo path) [data]
        (js.push! data) (resolve-promise)
      )
    ))))
    (when read-all
      (js.push! (or meta.post ""))
      (ref contents (js.join "\n"))
      (when (write target-repo (+ "ext/" meta.target) contents comment)
        (resolve-promise)
      )
    )
  ))
  (ref grunt-copy (promise [files]
    (ref copy-all (promise.all (files.map (promise [item]
      (ref path (or item.src item))
      (when (github-actors.read source-repo path) [contents]
        (ref path (+ "ext/" (last (path.split "/"))))
        (when (write target-repo path contents comment)  (resolve-promise))
      )
    ))))
  ))
  (ref grunt (promise [target-repo source-project]
    (ref source-repo (github-actors.repo target-repo source-project))
    (ref comment (+ "from " source-project))
    (ref sources [[
      {repo: source-project files: [[
        {include: '/^Gruntfile.js$/' single-level: true}
      ]]}
    ]])
    (when (retriever target-repo sources actors) [store]
      (ref grunt-config ((Function
        (+ "var module={};" (last store.js) "return module.exports"))))
      (grunt-config {
        loadNpmTasks: (lambda) registerTask: (lambda)
        initConfig: (lambda [config-data]
          (ref grunt-processor {
            build: grunt-build
            copy:  grunt-copy
          })
          (when (update target-repo)
            (resolve-promise grunt-processor config-data)
          )
        )
      })
    )
  ))
  (ref build-github (lambda [target-repo]
    (ref sources [[
      {repo: "michael/github" files: [[
        {include: "/src/github.js$/"}
      ]]}
    ]])
    (return (build target-repo "github" sources))
  ))
  (ref loaded (net.script "ext/github.js" (lambda (return window.Github))))
  ## (promise.failed loaded (export {build}))
  (when loaded
    (export {
      branch list-all> list-dir> cdn-uri build builder repo> read> write>
      build-github retriever grunt preprocessors session> projects>
      move: (promise.callback [repo from to]
        (repo.github.move repo.branch from to callback)
      )
      delete: (promise.callback [repo path]
        (repo.github.remove repo.branch path script callback)
      )
    })
  )
)
