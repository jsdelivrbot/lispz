### spec: >> GitHub
  A higher-level wrapper around the Github API. Intended for the browser.

  https://github.com/michael/github
###
(using  [net dict list axios base64 utf8]
  ### spec: GitHub >> CDN
    It is possible to access GitHub files for direct use in the browser through
    a CDN. Provide the project name, hash/branch/release and a path to the file.
  ###
  (ref cdn-uri (lambda [project hash filepath]
    (return (+ "https://cdn.rawgit.com/" project "/" hash "/" filepath))
  ))
  ### spec: GitHub >> Specifying the Current Repository
    This is a non-pure function because if this is the first connection to
    GitHub, a UI modal dialog is displayed for GitHub log-in details.
  ###
  (ref repo> (lambda [project]
    (ref user (or
      (sessionStorage.getItem "ghstate")
      (localStorage.getItem "ghstate")
    ))
    (cond user (do
      (ref up ((atob user).split "||"))
      (promised (connect (first up) (last up) project))
    ) (else)
      ((promise (using [bootstrap]
        (ref modal-path "github/github-login")
        (ref modal (bootstrap.modal modal-path {}))
        (when modal [resp]
          (cond (is resp.login.value "true") (do
            (ref user (btoa (+
              resp.username.value
              "||" resp.password.value
            )))
            (cond (is resp.remember.checked)
              (localStorage.setItem "ghstate" user)
            (else) (do ## user wants amnesia
              (localStorage.removeItem "ghstate")
              (sessionStorage.setItem "ghstate" user)
            ))
            (resolve-promise (connect
              resp.username.value resp.password.value project
            ))
          ) (else)
            (reject-promise {
              error: true reason: "User abort"
            })
          )
        )
      )))
    )
  ))
  (ref connect (lambda [username password project]
    (ref auth (new Github {username password auth: "basic"}))
    (ref github (auth.getRepo.apply null (project.split "/")))
    (return (stateful {github auth username password project branch: "master"}))
  ))
  ## Set the branch to use for repo - defaults to master
  (ref branch (promise [repo branch-name]
    (repo.update! {branch: branch-name})
    (repo.github.branch branch-name (lambda [err result] (resolve-promise)))
  ))
  ## list files in a specific path on the repo
  (ref list-dir (promise.callback [repo path]
    (repo.github.contents repo.branch path callback)
  ))
  (ref list-all (promise [repo path single-level]
    (ref result (stateful.array!))
    (ref list-path (lambda [path]
      (return (when (list-dir repo path) [paths]
        (ref children (stateful.array!))
        (paths.forEach (lambda [entry]
          (cond
            (is "dir"  entry.type)
              (cond (not single-level) (children.push! (list-path entry.path)))
            (is "file" entry.type)
              (result.push! entry.path)
          )
        ))
        (return (promise.all children.array!))
      ))
    ))
    (when (list-path path) (resolve-promise result.array!))
  ))
  (ref read (promise.callback [repo path]
    (repo.github.read repo.branch path callback)
  ))
  (ref update (lambda [repo]
    (cond
      (is repo.branch repo.username) (promise.resolved)
      (else) (do
        (ref branch-name (or repo.username "master"))
        (branch repo branch-name)
      )
    )
  ))
  (ref write (promise.callback [repo path contents comment]
    (cond
      (not contents.length) (promise.resolved)
      (else) (do
        (ref encoded (unescape (encodeURIComponent contents)))
        (repo.github.write repo.branch path encoded comment callback)
      )
    )
  ))
  ## preprocess a file to generate css or js dependent on extension
  (ref preprocessors {
    lispz: (lambda [name code]
      (return {path ext: "js" code: (window.lispz.compile code name)})
    )
  })
  (ref get-preprocessor (pull preprocessors))
  (ref preprocess (lambda [path code]
    (ref ext (last (path.split ".")))
    (ref preprocessor (get-preprocessor ext))
    (cond preprocessor (preprocessor path code)
                (else) {path ext code})
  ))
  ## Build and save a dependency list
  ## We will need to filter the dependencies
  (ref filter (lambda [before include exclude]
    (ref after before)
    (ref after (cond
      include (after.filter (lambda [file] (include.test file)))
      exclude (after.filter (lambda [file] (not (exclude.test file))))
    ))
    (return after)
  ))
  ## and see which to save and which to copy
  (ref copy (lambda [copy-to path code]
    ## not working yet for binary files
    (ref filename (last (path.split "/")))
    (return {path code copy: (+ copy-to "/" filename)})
  ))
  ## Load the contents of the files we need from a single repo
  (ref process-repo (lambda [source-repo files actors]
    (return (promise.all (files.map (promise [meta]
      (ref base (or meta.base ""))
      (when (actors.list-all source-repo base meta.single-level) [file-list]
        (ref files (filter file-list meta.include meta.exclude))
        (resolve-promise (promise.all (files.map (promise [path]
          (when (actors.read source-repo path) [code]
            (cond
              meta.copy-to (resolve-promise (copy meta.copy-to path code))
              (else)       (resolve-promise (preprocess path code))
            )
          )
        ))))
      )
    ))))
  ))
  ## Given a list of repos, go through them all for files in need
  (ref process-repos (lambda [target-repo sources actors]
    (return (promise.all (sources.map (lambda [source]
      (ref source-repo (actors.repo target-repo source.repo))
      (return (process-repo source-repo source.files actors))
    ))))
  ))
  ## Retrieve file contents based of filtering meta-data
  (ref retriever (promise [target-repo sources actors]
    (when (process-repos target-repo sources actors) [entry-tree]
      (ref first-from [["Gathered from: "]])
      (ref rest-from (sources.map (lambda [source] (return source.repo))))
      (ref store {
        js:     (stateful.array!)
        css:    (stateful.array!)
        copies: (stateful.array!)
        from:   (first-from.concat rest-from)
      })
      ((list.flatten entry-tree).forEach (lambda [entry]
        (ref ext-list (get store entry.ext))
        (cond
          (ext-list) (do
            (ext-list.push! "\n\n/* " entry.path " */\n" entry.code)
          )
          store.copy
            (store.copies.push! entry)
        )
      ))
      (resolve-promise store)
    )
  ))
  ## Given a file type, save the concatenated source contents
  (ref save-store (promise [target-repo store name ext comment]
    (ref contents ((get store ext).array!.join ""))
    (return (write target-repo (+ "ext/" name "." ext) contents comment))
  ))
  ## copy files identified as needed as-is
  (ref copy-store (lambda [target-repo store comment]
    (return (promise.all (store.copies.array!.map (lambda [entry]
      (return (write target-repo entry.path entry.code comment))
    ))))
  ))
  ## Now we have gathered needed resources, build and save the output file
  (ref builder (promise [actors target-repo name sources]
    (when (retriever target-repo sources actors) [store]
      (ref comment (store.from.join " "))
      (ref saved (when (update target-repo)
        (return (promise.all
          (save-store target-repo store name "js"  comment)
          (save-store target-repo store name "css" comment)
          (copy-store target-repo store            comment)
        ))
      ))
      (when saved (resolve-promise))
    )
  ))
  (ref github-actors {
    list-all read
    repo: (lambda [target-repo name]
      (return (repo target-repo.username
        target-repo.password name
      ))
    )
  })
  (ref build (builder.bind null github-actors))
  ## Use gruntfile to decide which files to include and it what order
  (ref grunt-build (promise [meta]
    (ref js (stateful.array! [[(or meta.pre "")]]))
    (ref read-all (promise.all (meta.files.map (promise
      (when (github-actors.read source-repo path) [data]
        (js.push! data) (resolve-promise)
      )
    ))))
    (when read-all
      (js.push! (or meta.post ""))
      (ref contents (js.array!.join "\n"))
      (when (write target-repo (+ "ext/" meta.target) contents comment)
        (resolve-promise)
      )
    )
  ))
  (ref grunt-copy (promise [files]
    (ref copy-all (promise.all (files.map (promise [item]
      (ref path (or item.src item))
      (when (github-actors.read source-repo path) [contents]
        (ref path (+ "ext/" (last (path.split "/"))))
        (when (write target-repo path contents comment)  (resolve-promise))
      )
    ))))
  ))
  (ref grunt (promise [target-repo source-project]
    (ref source-repo (github-actors.repo target-repo source-project))
    (ref comment (+ "from " source-project))
    (ref sources [[
      {repo: source-project files: [[
        {include: '/^Gruntfile.js$/' single-level: true}
      ]]}
    ]])
    (when (retriever target-repo sources actors) [store]
      (ref grunt-config ((Function
        (+ "var module={};" (last store.js) "return module.exports"))))
      (grunt-config {
        loadNpmTasks: (lambda) registerTask: (lambda)
        initConfig: (lambda [config-data]
          (ref grunt-processor {
            build: grunt-build
            copy:  grunt-copy
          })
          (when (update target-repo)
            (resolve-promise grunt-processor config-data)
          )
        )
      })
    )
  ))
  (ref build-github (lambda [target-repo]
    (ref sources [[
      {repo: "michael/github" files: [[
        {include: "/src/github.js$/"}
      ]]}
    ]])
    (return (build target-repo "github" sources))
  ))
  (ref loaded (net.script "ext/github.js" (lambda (return window.Github))))
  ## (promise.failed loaded (export {build}))
  (when loaded
    (export {
      branch list-all list-dir cdn-uri build builder repo> read write update
      build-github retriever grunt preprocessors
      move: (promise.callback [repo from to]
        (repo.github.move repo.branch from to callback)
      )
      delete: (promise.callback [repo path]
        (repo.github.remove repo.branch path script callback)
      )
    })
  )
)
