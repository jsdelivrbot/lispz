### spec: Riot

[Riot](http://riotjs.com) is a tiny UI library then provides the best of Web components (polymer) and react in a package 15% of the size.

Riot, like web components, each file (of type .riot.html) is a html fragment that also includes style and script elements. Like web components it is based on creating custom tags. This provides clean and readable HTML. Custom tags makes the HTML more readable.

The *panel* tags is a Riot wrapper around bootstrap panels.

Riot, like React it works with a virtual DOM and only updates changes to the real DOM. Like React it compiles to JavaScript. It can be supported on older browsers.

Small tight API that provides all needed web component functionality for reactive views, events and routing.
###

### spec: Riot >> Structure of a RIOT/Lispz Program

Riot components have the extension *.riot.html*. They are loaded from the HTML file or from another component. In the HTML, give a custom tag the class or *riot* and it will load a component file of the same name - including any other tags in the file. The html below will load *bootstrap.riot.html* and *code-editor.riot.html*, while *page-content* does not need a riot class as it is defined withing *bootstrap*.

    <bootstrap class=riot>
      <page-content fluid=true>
        <div class=col-sm-6>
          <code-editor class=riot name=literate height=48% />
        </div>
        <div class=col-sm-6>
          <code-editor class=riot name=code height=48% />
        </div>
      </page-content>
    </bootstrap>

For riot component files that rely on other files for sub-components, Start the file with a comment, the word *using* and a space separated list of component paths. In the example below, *panel* is a tag defined in the bootstrap component file.

    <!-- using bootstrap -->
    <code-editor>
      <panel height={ opts.height } heading={ heading } menu={ menu } owner={ _id }>
        <div name=wrapper class=wrapper></div>
      </panel>
      <style>code-editor .wrapper {...}</style>
      <script type=text/lispz>(var tag this) ...</script>
    </code-editor>
    
Riot uses plain JavaScript inside {} as a templating solution. The *opts* dictionary matches the attributes when the custom tag is referenced. Any inner tag with a *name* or *id* attribute can be referenced by the same name. Each component has a unique *_id*.

Styles are global (unlike *true* web components). This is easily overcome using explicit name-spacing as above.
###

### spec: Riot >> Using other languages

Scripting can be any language of choice that runs on the browser. JavaScript, Lispz, Es6 (with babel) and CoffeeScript are available out-of-the-box. For the latter two you will need to load the compiler by *(using babel coffeescript)* in the startup code. Other languages can be added as long as they compile code on the browser.

    (set! riot.parsers.js.lispz
      (lambda [source] (return ((lispz.compile "riot-tags" source).join "\n")))
    )
###
(using  [jquery net github dict]
  (var compile (lambda [html to-js] (return (riot.compile html to-js))))

  (var processed-tags (stateful {}))

  (var load (promise [name uri]
    (var load-tags-used (lambda [tags]
      (var new-tags (tags.filter (lambda [tag]
        (return-if (get processed-tags tag) false)
        (return (processed-tags.update! tag true))
      )))
      (var loaded (promise.all (new-tags.map (lambda [tag] (return (load tag))))))
      (when loaded [] (resolve-promise))
    ))
    (var usings (lambda [source]
      (var tags ('/<!--\s*using\s*(.*?)\s*-->/'.exec source))
      (cond
        tags   (do (load-tags-used ((last tags).split '/\s+/')))
        (else) (resolve-promise)
      )
    ))
    (var retrieve-and-compile (=>
      (var url (or uri (+ (name.toLowerCase) ".riot.html")))
      (when (net.http-get url) [tag] (usings (compile tag)))
    ))
    (cond
      (get lispz.tags name) (usings ((get lispz.tags name)))
      (else)                (retrieve-and-compile)
    )
  ))

  (var build (lambda [target-repo]
    (return (github.build target-repo "riot" [[
      {repo: "riot/riot" files: [[
        {include: '/^riot\+compiler.js$/'}
      ]]}
    ]]))
  ))

  (var mount (lambda [tags] (riot.mount.apply riot argument)))
  
  ### spec: riot >> Trigger Display Changes
    Given a component context called *tag*, it is possible to change context
    data using the state component.
    
      <script type=text/lispz>
        (var tag (stateful.morph this))
        ...
        (var async-set-title (lambda [title]
          (tag.update! {title})
          (tag.update)
        )
      </script>
      
    For the confused, *update!* changes entries in the stateful context,
    while *update* is a riot function to update the display for bound
    data changes. Continue to use this approach where the data has logic
    around the change, but for the common situation where data is changed
    at the end of the logic, use *riot.update!*.
    
      (using [riot]
        ...
        (var async-set-titles (lambda [title footer]
          (riot.update! tag {title footer})
        )
      )
  ###
  (var update! (lambda [tag changes]
    (tag.update! changes)
    (tag.update) ## repaint
  ))

  ### spec: riot >> Tag support
    Riot uses _this_ as context for codes within a tag. Also, when errors are
    found it throws excepts that are difficult to track. Lispz provides help
    with a riot-tag macro which invokes _using_,  provides a _context_ reference
    and wraps the code in a _try/catch_ to provide improved error reporting.
    
      @TODO example
  ###
  (macro riot-tag [modules *body]
    'var context=this;'
    (using modules
      (#join '' 'try {' *body '}catch(err){console.log(err,context)}')
    )
  )
  
  ### spec: async >> Events
    Events follow [the observer pattern](https://en.wikipedia.org/wiki/Observer_pattern). Lispz provides access to the light-weight version in Riot. If you use Riot for UI components, the custom tags are always observers. You don't need to use riot to make use of events. You can either create an observable or make any object in the system observable.
    
        (using [riot]
          (var observable-1 (riot.observable))
          (var element (get-my-element))
          (riot.observable element)
        )
        
    Once that is out of the way, tell the observable what to do if it receives an event either once or every time.
    
        (observable-1.on "event-name" (lambda [params...] what to do...))
        (element.one "focus" (lambda [contents] (element.set contents)))
        
    One observable can have many listeners for the same or different events. Use 'trigger' to wake an observable.
    
        (observable-1.trigger "event-name" param1 param2)
        
    Finally there needs to be a way to stop listening.
    
        (observable-1.off "event-name" event-function-reference) ## stops one listener
        (observable-1.off "event-name") ## stops all listeners to an event
        (observable-1.off "*")          ## stops all listeners to all events for observable
    
    ## Benefits
    1. Decouples the code to whatever extent is necessary.
    2. Associates code and data (such as the DOM).
    3. Allows multiple invocations
    
    ## Disadvantages
    1. Too convoluted to use as an easy replacement for callbacks
    2. One-way communication
    3. No way of knowing if event was processed as expected.
  ###

  (when (net.script "ext/riot.js") []
    (return-if (not window.riot) (export {build}))
    (stateful.morph! riot.parsers.js)
    (riot.parsers.js.update! {lispz:
      (lambda [source] (return ((lispz.compile "riot-tags" source).join "\n")))
    })
    (var riot-elements (slice (document.getElementsByClassName "riot")))
    (var load-all (promise.all (riot-elements.map (lambda [element]
      (var name (element.tagName.toLowerCase))
      (return (load name (element.getAttribute "uri")))
    ))))
    (when load-all [mounts]
      (riot.mount "*")
      (export {build compile load mount update!})
    )
  )
)
