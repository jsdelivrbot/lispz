(using  [jquery net github dict]
  (var compile (lambda [html to-js] (return (riot.compile html to-js))))

  (var processed-tags (stateful {}))

  (var load (promise [name uri]
    (var load-tags-used (lambda [tags]
      (var new-tags (tags.filter (lambda [tag]
        (return-if (get processed-tags tag) false)
        (return (processed-tags.update! tag true))
      )))
      (var loaded (promise.all (new-tags.map (lambda [tag] (return (load tag))))))
      (when loaded [] (resolve-promise))
    ))
    (var usings (lambda [source]
      (var tags ('/<!--\s*using\s*(.*?)\s*-->/'.exec source))
      (cond
        tags   (do (load-tags-used ((last tags).split '/\s+/')))
        (else) (resolve-promise)
      )
    ))
    (var retrieve-and-compile (=>
      (var url (or uri (+ (name.toLowerCase) ".riot.html")))
      (when (net.http-get url) [tag] (usings (compile tag)))
    ))
    (cond
      (get lispz.tags name) (usings ((get lispz.tags name)))
      (else)                (retrieve-and-compile)
    )
  ))

  (var build (lambda [target-repo]
    (return (github.build target-repo "riot" [[
      {repo: "riot/riot" files: [[
        {include: '/^riot\+compiler.js$/'}
      ]]}
    ]]))
  ))

  (var mount (lambda [tags] (riot.mount.apply riot argument)))
  ### riot >> Trigger Display Changes
    Given a component context called *tag*, it is possible to change context
    data using the state component.
    
      <script type=text/lispz>
        (var tag (stateful.morph this))
        ...
        (var async-set-title (lambda [title]
          (tag.update! {title})
          (tag.update)
        )
      </script>
      
    For the confused, *update!* changes entries in the stateful context,
    while *update* is a riot function to update the display for bound
    data changes. Continue to use this approach where the data has logic
    around the change, but for the common situation where data is changed
    at the end of the logic, use *riot.update!*.
    
      (using [riot]
        ...
        (var async-set-titles (lambda [title footer]
          (riot.update! tag {title footer})
        )
      )
  ###
  (var update! (lambda [tag changes]
    (tag.update! changes)
    (tag.update) ## repaint
  ))
  
  ### async >> Events
    Events follow [the observer pattern](https://en.wikipedia.org/wiki/Observer_pattern). Lispz provides access to the light-weight version in Riot. If you use Riot for UI components, the custom tags are always observers. You don't need to use riot to make use of events. You can either create an observable or make any object in the system observable.
    
        (using [riot]
          (var observable-1 (riot.observable))
          (var element (get-my-element))
          (riot.observable element)
        )
        
    Once that is out of the way, tell the observable what to do if it receives an event either once or every time.
    
        (observable-1.on "event-name" (lambda [params...] what to do...))
        (element.one "focus" (lambda [contents] (element.set contents)))
        
    One observable can have many listeners for the same or different events. Use 'trigger' to wake an observable.
    
        (observable-1.trigger "event-name" param1 param2)
        
    Finally there needs to be a way to stop listening.
    
        (observable-1.off "event-name" event-function-reference) ## stops one listener
        (observable-1.off "event-name") ## stops all listeners to an event
        (observable-1.off "*")          ## stops all listeners to all events for observable
    
    ## Benefits
    1. Decouples the code to whatever extent is necessary.
    2. Associates code and data (such as the DOM).
    3. Allows multiple invocations
    
    ## Disadvantages
    1. Too convoluted to use as an easy replacement for callbacks
    2. One-way communication
    3. No way of knowing if event was processed as expected.
  ###

  (when (net.script "ext/riot.js") []
    (return-if (not window.riot) (export {build}))
    (set! riot.parsers.js.lispz
      (lambda [source] (return ((lispz.compile "riot-tags" source).join "\n")))
    )
    (var riot-elements (slice (document.getElementsByClassName "riot")))
    (var load-all (promise.all (riot-elements.map (lambda [element]
      (var name (element.tagName.toLowerCase))
      (return (load name (element.getAttribute "uri")))
    ))))
    (when load-all [mounts]
      (riot.mount "*")
      (export {build compile load mount update!})
    )
  )
)
