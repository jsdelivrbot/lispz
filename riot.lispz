(using  [jquery net github dict]
  (var compile (lambda [html to-js] (return (riot.compile html to-js))))

  (var load (promise [name uri]
    (var load-tags-used (lambda [tags]
      (var loaded (promise.all (tags.map (lambda [tag] (return (load tag))))))
      (when loaded [] (resolve-promise))
    ))
    (var usings (lambda [source]
      (var tags ('/<!--\s*using\s*(.*?)\s*-->/'.exec source))
      (cond
        tags   (do (load-tags-used ((last tags).split '/\s+/')))
        (else) (resolve-promise)
      )
    ))
    (var retrieve-and-compile (=>
      (var url (or uri (+ (name.toLowerCase) ".riot.html")))
      (when (net.http-get url) [tag] (usings (compile tag)))
    ))
    (cond
      (get lispz.tags name) (usings ((get lispz.tags name)))
      (else)                (retrieve-and-compile)
    )
  ))

  (var build (lambda [target-repo]
    (return (github.build target-repo "riot" [[
      {repo: "riot/riot" files: [[
        {include: '/^riot\+compiler.js$/'}
      ]]}
    ]]))
  ))

  (var mount (lambda [tags] (riot.mount.apply riot argument)))

  (when (net.script "ext/riot.js") []
    (return-if (not window.riot) (export {build}))
    (set! riot.parsers.js.lispz
      (lambda [source] (return ((lispz.compile "riot-tags" source).join "\n")))
    )
    (var riot-elements (slice (document.getElementsByClassName "riot")))
    (var load-all (promise.all (riot-elements.map (lambda [element]
      (var name (element.tagName.toLowerCase))
      (return (load name (element.getAttribute "uri")))
    ))))
    (when load-all [mounts]
      (riot.mount "*")
      (export {build compile load mount})
    )
  )
)
