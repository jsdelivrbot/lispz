### lists >> dict -- The Associative Array List (Dictionary)

Are also called dictionaries or hashmaps. Because lispz is a functional language it is not
uncommon for functions to return a dictionary of values. To make them clearer, if a key is
supplied without a following colon then it is placed into the dictionary with a value of the same name.

    (var exported-method-1 (=> ...))
    (var key "whatever I want"}
    (export {exported-method-1 key error: false date: (new Date))
    
will create a JavaScript dictionary of the form

    (var exporting {exported_method_1: exported_method_1, key: key, error: false, date: (new Date)})
    
access with a key is identical to arrays except that it is a key rather than an index.
If the key is known, using dot syntax is clearer

    exporting.error
    (get exporting key)
###

### literate: lists >> dict >> Internals >> Insert
Dictionary merges and inserts take a list of dictionaries in order to push to the target.
This means that when they have common keys, the last dictionary that has the key takes
precedence.

    ## command-line options overwrite config options of the same name. If neither is
    ## found, the default option is used.
    (dict.merge default-options config-file-options cl-options)
###
(var insert (lambda [target dictionaries]
  (dictionaries.forEach (lambda [dictionary]
    (target.update! dictionary)
  ))
  (return target)
))

### literate: lists >> dict >> Merging Dictionaries
There is often need to merge multiple dictionaries together to create a new combined one.

    (var big-dict (dict.merge dict-1 dict-2 dict-3))
###
(var merge (lambda [dictionaries]
  (return (insert {} (*arguments 0)))
))

### literate: lists >> dict >> Inserting One Dictionary in Another
**Warning** This is not referentially transparent

    (dict.insert! dict-1 dict-2 dict-3)      ## changes dict-1
###
(var insert! (lambda [target dictionaries]
  (return (insert target (*arguments 0)))
))

### literate: lists >> dict >> Create a Dictionary from a List
    (var list [[{key: 1 value: 2} {key: 3 value: 4}]]
    (dict.from-list list "key")    # {1: {key: 1 value: 2} 3: {key: 3 value: 4})
###
(var from-list (lambda [list key]
  (var dictionary (state))
  (cond list (list.forEach (lambda [item] (dictionary.update! item)))
  (return dictionary)
))

### literate: lists >> dict >> For Each Entry...
    (dict.for-each dict-1 (lambda [key value] ...))
###
(var for-each (lambda [dict action=>]
  (Object.keys dict)(.forEach (lambda [k] (action=> k (get dict k))))
))

### literate: lists >> dict >> Morphing One Dictionary into Another
###
(var map (lambda [dict action=>]
  (return ((Object.keys dict).map (lambda [k] (return (action=> k (get dict k))))))
))

(export {merge from-list insert! for-each map})
