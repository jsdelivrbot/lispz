### literate: basics >> Syntax
    One of the really cool things about a lisp language is that there is very little syntax.
    On the flip-side one of the disadantages of minimal syntax is the need for work-arounds -
    and by definition a work-around is syntax. The core for lispz is 4 sorts of lists

        (action a b c ...) ## functional list
        [a b c]            ## raw list (typically parameters for a function definition)
        [[a b c]]          ## an array list
        {a: 1 b c}         ## an associative array or dictionary

    Named references are created using 'var'. They exist only inside the module or function
    in which they are first defined. This includes inner functions, but if the inner function
    defines a 'var' of the same name it will be distinct and hide the outer reference.

        (var ref 23)
###
### literate: basics >> Operators
    A pure lisp system does not have any operators. Everything is a function or a macro.
    Because Lispz compiles to JavaScript, all unary and many binary operators are exposed.

        (delete dict.key)  ## JS==> delete dict.key
        debugger           ## JS==> debugger
        (+ 2 3 4)          ## JS==> (2 + 3 + 4)

    While unary operators are transparent to Lispz and convert directly, binary operators
    are expanced with macros. Some operators have convenience names.

        (and a b c)        ## JS==> a && b && c
        (or a b c)         ## JS==> a || b || c
        (is a 12)          ## JS==> a === 12
        (isnt a 12)        ## JS==> a !== 12

    Thanks to JavaScript 'and' and 'or' short-circuit - meaning that they will stop when
    they find truth for and or false for or.

        (return (or value "default value string"))
###
### literate: developer >> debug
  `(debug)` is a development helper macro. It will print a stack trace
  and the contents of any parameters on the console. If you left-align it
  then it will be easy to find later to delete.
###
### spec: debug
  (describe "(debug [p1, p2, ...]) ## macro to display stack and messages" (=>
    (it "displays a stack trace and the parameters provided" (=>
      (spy-method console trace)
      (debug "multiple" "parameters")
      ((expect console.trace).toHaveBeenCalled)
    ))
  ))
###
(macro debug [*msg] (console.trace (#join ',' *msg)))

### literate: basic >> References
  @TODO
###
(macro var [*list] (#join '' 'var ' (#pairs *list '=' ',') ';'))

### literate: basic >> References >> Global References
  @TODO
###
(macro global [name value]
  (#join '' 'lispz.globals.' name '=' value)
  (macro name [&params] (#join '' 'lispz.globals.' name '(' &params ')')))

### literate: basic >> Functions

    As I am sure I mentioned before the default lisp/lispz element is the list surrounded by brackets.
    In most cases in lisp and all cases in list the first element of the list is a reference to a function.
    In JavaScript perspective this makes a lispz list a JavaScript function where the first element
    is the reference and the rest a list of parameters.

    This allows us to call JavaScript functions at any time we can get to them.

        (console.log "This is the" count "log message")

    Anonymous functions are created with the lambda key-word (which is actually a macro - confused yet?).
    The parameters are referenced in another list form - that between square brackets.
    For later use, assign it to or in a variable. A function will return undefined
    unless a specific return statement is used.

        (var +1 (lambda [number] (return (+ number 1))))
        ...
        a = 12
        (console.log a (+1 a))  ## 12 13
###
### spec: function
  (describe "(lambda [p1 p2 *rest]) ## function definition" (=>
    (it "defines an anonymous function that can be called" (=>
      (var f1 (lambda [a b] (return (* a b))))
      (var result (f1 2 3))
      ((expect result).toBe 6)
    ))
  ))
###
(macro lambda [params *body] (#join '' '(function(' params '){' *body '})'))

### literate: basic >> Retrieval - can be used for objects and arrays
  @TODO
###
(macro get [dict *key] (#join '' dict '[' (#join '][' *key) ']'))

### conditional processing ###
(macro empty? [list] (not list.length))
(macro defined? [field] (!== (typeof field) "undefined"))

### basics -- Conditionals
    Lispz boasts only one traditional conditional operator plus a number of
    macros for conditional assignment and function return. The operator,
    cond takes pairs of lists where the first is the condition and the
    second the action. Evaluation stops after the first true condition.
    There is an else macro that evaluates to true to catch situations not
    covered specifically. The default? function takes a value and returns
    it if it exists and is not empty, otherwise it returns the default value.

        (cond (is v "One")  (return 1)
              (not v)       (return 0)
              (else)        (return -1)
        )

    Because conditionals work with list pairs, it is necessary to wrap the actions
    if there are more than one. Lispz provides 'do' for that.

        (cond ok? (do (finish-up) (return true)))

    The standard conditional tests (< > <= >=, etc) are augmented by aliases (is isnt not).
###
(macro cond [*list]
  (#join '' 'switch(false){case !' (#pairs *list  ':' ';break;case !') '}')
)
(macro else [] 'true')

### literate: basic >> state -- Stateful Containers
  State is the elephant in the room - particularly in the functional programming paradigm.
  When you have state that can be changed from outside, then any function that reads from it
  no longer has referential integrity. This means that identical calls may not return identical
  results.
  
  But we need state. Without it the system is fully enclosed without input or output.
  A referentially integrous :) function can be replaced by it's return value,
  so why ever run it?
  
  The aim is to be like any machine with the internals always working the same.
  Think of a clock. The input is someone setting the time.
  After that the external gearing, etc is meant to work consistently so that the
  time advances at the correct pace. The current time is state. You can build and
  test the entire device without the state. It is on the very outside. Once the
  mechanism is working as expected, add a clock face and hands. Changing the hands
  is input and displaying the time output. The latter can be considered a
  side-effect.
  
  The state container for lispz relies on polite access, not enforced rules. By custom an
  object holding state that may break referential integrity ends in an exclamation mark.
  The default builder return an empty JavaScript dictionary.

      (describe "Create a new stateful object -- (var ref (state seed))" (=>
        (var options (state {name!: "undefined" address!: "nowhere"}))
        (it "is able to read members directly -- stateful.member!" (=>
          ((expect options.name!).toBeEqual "undefined")
        ))
        (it "is able to read members by key -- stateful[key]" (=>
          ((expect options["name!"]).toBeEqual "undefined")
        ))
        (it "is able to change member values -- (state.set stateful.member! value)" (=>
          (state.set options.name! "Fred Flinstone")
          ((expect options.name!).toBeEqual "Fred Flinstone")
        ))
        (it (+ "is able to merge a dictionary of changes -- "
          "(state.merge stateful {a: dictionary})") (=>
            (state.merge options {name!: "Barney Rubble" address!: "Next Door"})
            ((expect options.name!).toBeEqual "Barney Rubble")
            ((expect options.address!).toBeEqual "Next Door")
          )
        )
      ))
  
  Be polite and use this container responsibly. Adding protection adds overhead.
  If you want to cheat, then on your head be it.
###

(macro state.set [state! value] (#join '' state! '=' value ';'))
(var merge (lambda [stateful update]
  ((Object.keys update).forEach (lambda [key]
    (state.set (get stateful key) (get update key))
  ))
))
(global state (lambda [seed]
  (var state! (new Object))
  (cond seed (merge state! seed))
  (return state!)
))
(global state.merge merge)

### literate: basic >> functions >> Functions without Parameters
    While I normally avoid short-cuts that don't clarify the code, I made an exception for functions
    without parameters. I kept forgetting the enpty square brackets.

        (var random-number (=> (Math.random))
###
(macro =>     [*body]        (#join '' '(function(){' *body '})'))

### literate: basic >> functions >> Variable Parameter Lists
    Like JavaScript, lispz function definitions specify a fixed number of arguments.
    To gain access to the full list of arguments, use *arguments, with a starting index.

        (lambda [type rest] (console.log type "=" (*arguments 1)))
###
(macro *arguments [from] ([[]].slice.call arguments from))

(macro closure [params *body] (#join '' '(function(' params '){' *body '})(' params ')'))
(macro return  [value] (#join '' 'return ' value '\n'))

### literate: basics >> functions >> Return if Exists
    As a functional language, most decisions are made by small single-focus functions.
    As such, conditional returns are a useful shortcut. To this end, return? returns
    a value if it not false, null or an empty container.

        (return? calculated-value)
###
(macro return? [value] (cond value (return value)))

### literate: basics >> functions >> Return if ...
    While return-if has aconditional pair. If the first is true the second is returned.

        (return-if (not calculated-value) default-value)
###
(macro return-if [test value] (cond test (return value)))

(macro new [cls *params] (#join '' '(new ' cls '(' (#join ',' *params) '))'))

### literate: functions >> chaining -- Chaining functions
  In a functional style we often call multiple functions to incrementally move
  from problem to solution. Each step takes the results from the step before and
  transforms it. It is allways a good idea to have short functions that do one
  thing - for testing, maintenance and readability. Speaking of readability,
  chain makes the sequence of events clear.

      (parse-titles (lambda [sections] (return (sections.map ...)))
      (sort-titles  (lambda [sections] (return (sections.map ...)))
      (merge-titles (lambda [sections] (return (sections.map ...)))

      ((chain parse-titles sort-titles merge-titles) sections)
###
### spec: chain
  (describe "chain: run each function with the results from the one before" (=>
    (it "(chain f1 f2 ...)" (=>
      (var f1 (lambda [a] (return 2)))
      (var f2 (lambda [a] (return (+ a 3))))
      (var f3 (lambda [a] (return (* a 10))))
      ((expect (chain f1 f2 f3)).toBe 50)
    ))
  ))
###
(global chain (=> (var functions (*arguments 0))
  (var link (lambda [arg func] (return (func arg))))
  (return (functions.reduce link null))
))

## TODO replace with state
### Pure functional programming wants immutability - but we live in an impure world ###
(macro set! [name value] (#join '' name '=' value ';'))
### literate: list >> dict >> Updating Dictionary Entries
  If you need to update a dictionary, use set! or dict.update!. Be aware of and
  keep referential integrity.

      (set! exporting.error "it broke")
      (dict.update! exporting key "new key")
###
(macro dict.update! [dict key value] (#join '' dict '[' key ']' '=' value ';'))

### Operators ###
(macro not [value] (#join '' '!(' value ')'))
(macro in [test against] (#join '' '(' test ' in ' against ')'))
(macro instance-of [type obj] (#join '' '(' obj ' instanceof ' type ')'))

(macro contains [str substr] (isnt -1 (str .indexOf substr)))
###
# basics >> Iteration

In the functional way of programming, loop style iteration is (almost) never needed.
Because of the 'almost' and to provide for those week on functional will,
lispz provides one loop operator. It takes a test and a body.

    (while (not (result)) (look-again))

In this case both are functions. Lispz furthers the functional cause by making
assignment difficult and ugly.

Of course the need for iteration remains no matter what programming discipline you follow.
In the functional world it is filled by ... you guessed it ... functions.
For arrays, JavaScript provides an excellent set documented in [List Processing](list-processing.md).
###
## Javascript does not (yet) have tail recursion - it is scheduled for 2016
(macro while [test body] (#join '' 'while(' test '){' body '}'))

### List and dictionary manipulation ###
(macro length [list] (#join '' list '.length'))
(macro first [list] (get list 0))
(macro rest [list] (list .slice 1))
(macro last [list] (get (list .slice -1) 0))
(global slice (lambda [list from to]  (return ([[]].slice.call list from to))))
### module import ###
(macro using [modules *on_ready] (lispz.load (#join '' '"' modules '"')
  (=> (#requires modules) *on_ready)
))

### Modules must export to continue processing ###
(macro export [exports] (#join '' '__module_ready__(' exports ')'))

(macro delay [ms *body] (setTimeout (=> *body) ms))
(macro yield [*body] (delay 0 *body))
(macro do [*body] *body)
(global wait-for (lambda [test]
  (var waiter (=>
    (return? (test))
    (delay 10 waiter)
  )) (waiter)
))
###
# Use contain to contain state changes. Any var inside a contain can be changed
# no matter how many times the contain is called concurrently. It is also allows
# the passing in of variables that are effectively copied and cannot be changed
# from outside.
###
(macro contain [contain#args *contain#body]
  ((lambda contain#args *contain#body) contain#args)
)
###
# Return a random integer between 0 and the range given
###
(global random (lambda [range] (return (Math.floor (* (Math.random) range)))))

### Promises ###
(global promise {})
(macro promise [params *body] (lambda params
  (var #callbacks (state {ok: (=>) fail: (=>)}))
  (var #pledge (new Promise (lambda [ok fail] (state.merge #callbacks {ok fail}))))
  (var resolve-promise (lambda [] (#callbacks.ok.apply null (*arguments 0))))
  (var reject-promise (lambda [err] (#callbacks.fail err)))
  ## (#join '' 'try{' *body '}catch(err){' (reject-promise err) '}')
  *body
  (return #pledge)
))
(macro promise.callback [params *body] (promise params
  (var callback (lambda [err result]
    (return-if err (reject-promise err))
    (resolve-promise result)
  ))
  *body
))
(global promise.resolved (promise [pact] (resolve-promise pact)))
(global promise? (lambda [pledge]
  (return-if (and pledge pledge.then) pledge)
  (return (promise.resolved pledge))
))

(macro when  [pledge params *body] (pledge .then  (lambda params *body)))
(macro catch [pledge errors *body] (pledge .catch (lambda errors *body)))

(using [list]
  (global promise.all (=> (return (Promise.all (list.flatten (*arguments 0))))))
)
(global promise.chain (=>
  (var chain-link (lambda [input functions]
    (return-if (not functions.length) (promise? input))
    (var pledge (promise? ((first functions) input)))
    (when pledge [output] (chain-link output (rest functions)))
  ))
  (return chain-link null (*arguments 0))
))
(export {})
