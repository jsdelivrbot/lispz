### section: Lispz >> Core Functions ###
### literate: developer >> debug
  `(debug)` is a development helper macro. It will print a stack trace
  and the contents of any parameters on the console. If you left-align it
  then it will be easy to find later to delete.
###
### spec: debug
  (describe "(debug [p1, p2, ...]) ## macro to display stack and messages" (=>
    (it "displays a stack trace and the parameters provided" (=>
      (spy-method console trace)
      (debug "multiple" "parameters")
      ((expect console.trace).toHaveBeenCalled)
    ))
  ))
###
(macro debug [*msg] (console.trace (#join ',' *msg)))

(macro var  (*list) (#join '' 'var ' (#pairs *list '=' ',') ';'))

### spec: function
  (describe "(lambda [p1 p2 *rest]) ## function definition" (=>
    (it "defines an anonymous function that can be called" (=>
      (var f1 (lambda [a b] (return (* a b))))
      (var result (f1 2 3))
      ((expect result).toBe 6)
    ))
  ))
###
(macro lambda [params *body] (#join '' '(function(' params '){' *body '})'))
(macro =>     [*body]        (#join '' '(function(){' *body '})'))
(macro *arguments [from] ([[]].slice.call arguments from))
(macro global [name value]
  (#join '' 'lispz.globals.' name '=' value)
  (macro name [&params] (#join '' 'lispz.globals.' name '(' &params ')')))
(macro closure [params *body] (#join '' '(function(' params '){' *body '})(' params ')'))
(macro return  [value] (#join '' 'return ' value '\n'))
(macro return? [value] (cond value (return value)))
(macro return-if [test value] (cond test (return value)))
(macro new [cls *params] (#join '' '(new ' cls '(' (#join ',' *params) '))'))
### literate: functions >> chaining -- Chaining functions
  In a functional style we often call multiple functions to incrementally move
  from problem to solution. Each step takes the results from the step before and
  transforms it. It is allways a good idea to have short functions that do one
  thing - for testing, maintenance and readability. Speaking of readability,
  chain makes the sequence of events clear.

      (parse-titles (lambda [sections] (return (sections.map ...)))
      (sort-titles  (lambda [sections] (return (sections.map ...)))
      (merge-titles (lambda [sections] (return (sections.map ...)))

      ((chain parse-titles sort-titles merge-titles) sections)
###
### spec: chain
  (describe "chain: run each function with the results from the one before" (=>
    (it "(chain f1 f2 ...)" (=>
      (var f1 (lambda [a] (return (* a 2))))
      (var f2 (lambda [a] (return (+ a 3))))
      (var f3 (lambda [a] (return (* a 10))))
      (var result (chain f1 f2 f3) 2)
      ((expect result).toBe 70)
    ))
  ))
###
(global chain (lambda [functions]
  (var link (lambda [arg func] (return (func arg))))
  (return (lambda [arg] (return ((*arguments 0).reduce link arg))))
))

### Pure functional programming wants immutability - but we live in an impure world ###
(macro set! [name value] (#join '' name '=' value ';'))
(macro dict.update! [dict key value] (#join '' dict '[' key ']' '=' value ';'))

### Retrieval - can be used for objects and arrays ###
(macro get [dict *key] (#join '' dict '[' (#join '][' *key) ']'))

### Operators ###
(macro not [value] (#join '' '!(' value ')'))
(macro in [test against] (#join '' '(' test ' in ' against ')'))
(macro instance-of [type obj] (#join '' '(' obj ' instanceof ' type ')'))

### conditional processing ###
(macro empty? [list] (not list.length))
(macro defined? [field] (!== (typeof field) "undefined"))
(macro cond [*list] (#join '' 'switch(false){case !' (#pairs *list  ':' ';break;case !') '}'))
(macro else [] 'true')
(macro contains [str substr] (isnt -1 (str .indexOf substr)))
## Javascript does not (yet) have tail recursion - it is scheduled for 2016
(macro while [test body] (#join '' 'while(' test '){' body '}'))

(global default? (lambda [value default-value]
  (cond value (return value)) (return default-value)
))

### List and dictionary manipulation ###
(macro length [list] (#join '' list '.length'))
(macro first [list] (get list 0))
(macro rest [list] (list .slice 1))
(macro last [list] (get (list .slice -1) 0))
(global slice (lambda [list from to]  (return ([[]].slice.call list from to))))
### module import ###
(macro using [modules *on_ready] (lispz.load (#join '' '"' modules '"')
  (=> (#requires modules) *on_ready)))

### Modules must export to continue processing ###
(macro export [exports] (#join '' '__module_ready__(' exports ')'))

(macro delay [ms *body] (setTimeout (=> *body) ms))
(macro yield [*body] (delay 0 *body))
(macro do [*body] *body)
(global wait-for (lambda [test]
  (var waiter (=>
    (return? (test))
    (delay 10 waiter)
  )) (waiter)
))
###
# Use contain to contain state changes. Any var inside a contain can be changed
# no matter how many times the contain is called concurrently. It is also allows
# the passing in of variables that are effectively copied and cannot be changed
# from outside.
###
(macro contain [contain#args *contain#body] ((lambda contain#args *contain#body) contain#args))
###
# Return a random integer between 0 and the range given
###
(global random (lambda [range] (return (Math.floor (* (Math.random) range)))))

### Promises ###
(global promise {})
(macro promise [params *body] (lambda params
  (var #callbacks [[]])
  (var #pledge (new Promise (lambda [ok fail] (set! #callbacks  {ok fail}))))
  (var resolve-promise (lambda [] (#callbacks.ok.apply null (*arguments 0))))
  (var reject-promise (lambda [err] (#callbacks.fail err)))
  ## (#join '' 'try{' *body '}catch(err){' (reject-promise err) '}')
  *body
  (return #pledge)
))
(macro promise.callback [params *body] (promise params
  (var callback (lambda [err result]
    (return-if err (reject-promise err))
    (resolve-promise result)
  ))
  *body
))
(global promise.resolved (promise [pact] (resolve-promise pact)))
(global promise? (lambda [pledge]
  (return-if (and pledge pledge.then) pledge)
  (return (promise.resolved pledge))
))

(macro when  [pledge params *body] (pledge .then  (lambda params *body)))
(macro catch [pledge errors *body] (pledge .catch (lambda errors *body)))

(using [list]
  (global promise.all (=> (return (Promise.all (list.flatten (*arguments 0))))))
)
(export {})
