/*** Supporting function definition ***/
(macro lambda [params *body] (join '(function(' params '){' *body '})'))
(macro global [name params *body] (join 'lispz.macros["' name '"]=(function(' params '){' *body '})'))
(macro do [*body] *body)
(macro export [value] (join ' 0;return ' value))

/*** Pure functional programming wants immutability - but we live in an impure world ***/
(macro set! [name value] (join name '=' value ';'))
(macro var  (*list) (join 'var ' (#pairs *list '=' ',') ';'))

/*** Operators ***/
(macro not [value] (join '(!(' value '))'))

/*** conditional processing ***/
(macro empty? [list] (not list.length))
(macro cond [*list] (join 'switch(true){case ' (#pairs *list  ':' ';break;case ') '}'))
(macro else [] 'true')

/*** List manipulation ***/
(macro first [list] (join list '[0]'))
(macro rest [list] (join list '.slice(1)'))

/*** module import ***/
(macro requires [modules *on_ready] (lispz.load modules
  (lambda [] (#requires modules) *on_ready)))

/*** Javascript does not (yet) have tail recursion - it is scheduled for 2016 ***/
(macro while [test body] (join 'while(' test '){' body '}'))
