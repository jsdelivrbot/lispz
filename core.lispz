(macro debug [*msg] (console.log arguments *msg))

### Supporting function definition ###
(macro lambda [params *body] (#join '' '(function(' params '){' *body '}).bind({})'))
(macro =>     [params *body] (#join '' '(function(' params '){' *body '}).bind(this)'))
(macro *arguments [from] ([[]].slice.call arguments from))
(macro global [name params *body] (#join '' 'lispz.macros["' name
    '"]=(function(){return (function(' params '){' *body '}).apply({},arguments)})'))
(macro global [name value]
  (#join '' 'lispz.globals.' name '=' value)
  (macro name [&params] (#join '' 'lispz.globals.' name '(' &params ')')))
(macro closure [params *body] (#join '' '(function(' params '){' *body '})(' params ')'))
(macro return  [value] (#join '' 'return ' value '\n'))
(macro return? [test value] (cond test (return value)))

### Pure functional programming wants immutability - but we live in an impure world ###
(macro set! [name value] (#join '' name '=' value ';'))
(macro var  (*list) (#join '' 'var ' (#pairs *list '=' ',') ';'))

### Retrieval - can be used for objects and arrays ###
(macro get [dict *key] (#join '' dict '[' (#join '][' *key) ']'))

### Operators ###
(macro not [value] (#join '' '!(' value ')'))
(macro countdown? [counter action=>]
  (cond (not counter) (return (action=>)))
  (set! counter (- counter 1))
)

### conditional processing ###
(macro empty? [list] (not list.length))
(macro defined? [field] (!== (typeof field) "undefined"))
(macro cond [*list] (#join '' 'switch(false){case !' (#pairs *list  ':' ';break;case !') '}'))
(macro else [] 'true')
(macro contains [str substr] (isnt -1 (str .indexOf substr)))
## Javascript does not (yet) have tail recursion - it is scheduled for 2016
(macro while [test body] (#join '' 'while(' test '){' body '}'))

(global default? (lambda [value default-value]
  (cond value (return value)) (return default-value)
))

### List and dictionary manipulation ###
(macro first [list] (get list 0))
(macro rest [list] (list .slice 1))
(macro last [list] (get (list .slice -1) 0))
(global slice (lambda [list from to]  (return ([[]].slice.call list from to))))
(macro for-each-attribute [obj action]
  (Object.keys obj)(.forEach (lambda [k] (action k (get obj k))))
)
### module import ###
(macro with [modules *on_ready] (lispz.load modules
  (=> [] (#requires modules) *on_ready)))
(macro using [modules *on_ready] (lispz.load modules
  (lambda [] (#requires modules) *on_ready)))

### Modules must export to continue processing ###
(macro export [exports] (#join '' '__module_ready__(' exports ')'))
(export {})

(macro delay [ms *body] (setTimeout (=> [] *body) ms))
(macro yield [*body] (delay 0 *body))
(macro do [*body] *body)
###
# Use contain to contain state changes. Any var inside a contain can be changed
# no matter how many times the contain is called concurrently. It is also allows
# the passing in of variables that are effectively copied and cannot be changed
# from outside.
###
(macro contain [contain#args *contain#body] ((lambda contain#args *contain#body) contain#args))
###
# There is often need to merge multiple dictionaries together to create a new
# combined one.
###
(global merge (lambda [dictionaries]
  (var merged {})
  ((*arguments 0).forEach (lambda [dictionary]
    ((Object.keys dictionary).forEach (lambda [key]
      (set! (get merged key) (get dictionary key))
    ))
  ))
  (return merged)
))
###
# Execute a list of asynchronous functions one after anothr
###
(global sequential (lambda [list for-each=> on-complete=>]
  (@list: (slice list))
  (var each=> (=> []
    (return? (not @list.length) (on-complete=>))
    (for-each=> (@list.shift) each=>)
  ))(each=>)
))
###
# Return a random integer between 0 and the range given
###
(global random (lambda [range] (return (Math.floor (* (Math.random) range)))))
