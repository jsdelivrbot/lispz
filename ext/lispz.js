window.lispz_modules={}

lispz_modules['annotations']="### spec: Annotations\n  In this context, annotations are comments in source files that can be processed\n  by an external system for processing outside normal compilation and running.\n\n  An annotation is a line containing **##<span>#</span> type: ** followed by\n  lines of text ending in ##<span>#</span>. Annotation processors use a\n  type to define which annotations they retrieve. They then receive a list of\n  objects with _title_ and _body_ elements.\n\n  Source code can be any language that supports multi-line comments:\n\n      &lt;!-- ##<span>#</span> spec: Annotations in HTML or XML\n            ...\n           ##<span>#</span> --&gt;\n      /* ##<span>#</span> spec: Annotations in a C, C++, Java, etc\n          ...\n         ##<span>#</span> */\n###\n### spec: annotations >> Processing Source Code\n  The retrieve function processes source files one at a time. It returns an\n  array of objects containing title and body members.\n\n      (describe \"(annotations.retrieve \\\"spec\\\" source-code)\" (lambda\n        (it \"retrieves a list {title: \\\"..\\\" body: \\\"..\\\"}\" (lambda\n          (using [annotations]\n            (ref source window.lispz_modules.annotations)\n            (ref list (annotations.retrieve \"spec\" source)\n            (expect list.length).toBeGreaterThan(0)\n            (ref annotation (first list))\n            (expect annotation.title).toBe(\"Annotations\")\n            (expect annotation.body.length).toBeGreaterThan(100)\n          )\n        ))\n      ))\n###\n  (ref retrieve (lambda [type source]\n    (ref re (new RegExp (+ \"###\\\\s*\" type \":\\\\s*(.*)\\\\n((?:.|\\\\n)*?)###\") \"g\"))\n    (ref annotations (stateful []))\n    (ref scan (lambda\n      (ref res (re.exec source))\n      (cond res (do\n        (annotations.push! {title: (second res)  body: (third res)})\n        (scan)\n      ))\n    ))(scan)\n    (return annotations)\n  ))\n  (export {retrieve})\n"

lispz_modules['axios']="### spec: Libraries >> Axios\nA Promise based HTTP client\n\nhttps://github.com/mzabriskie/axios\n###\n  (ref build (lambda [target-repo]\n    (using [net github]\n      (return (github.build target-repo \"axios\" [[\n        {repo: \"axios/axios\" files: [[\n          {base: \"dist\" include: '/axios.js$/'}\n        ]]}\n      ]]))\n    )\n  ))\n\n  (lispz.script \"ext/axios.js\" (=> (export { build })))\n"

lispz_modules['babel']="### spec: Libraries >> Babel\nThe compiler for writing next generation JavaScript.\n\nhttps://github.com/babel/babel\n###\n(using [net cdnjs]\n  (ref build (lambda [target-repo]\n    (return (cdnjs.build target-repo \"babel\" [[\n      {repo: \"babel-standalone\" files: [[\n        {include: '/\\.min.js$/'}\n      ]]}\n    ]]))\n  ))\n  (ref loaded (net.script \"ext/jquery.js\" (lambda (return window.Babel))))\n  (when loaded (export {build}))\n  (promise.failed loaded (export {build}))\n)\n"

lispz_modules['base64']="### spec: Libraries >> Base64\nA robust base64 encoder/decoder that is fully compatible with `atob()` and btoa()`\n\nhttps://github.com/mathiasbynens/base64\n###\n  (ref build (lambda [target-repo]\n    (using  [net github]\n      (return (github.build target-repo \"base64\" [[\n        {repo: \"mathiasbynens/base64\" files: [[\n          {base: \"\" include: '/base64.js$/'}\n        ]]}\n      ]]))\n    )\n  ))\n\n  (lispz.script \"ext/base64.js\" (lambda (export { build })))\n"

lispz_modules['bootstrap']="### spec: Bootstrap\nThe most popular HTML, CSS, and JavaScript framework for developing responsive, mobile first projects on the web.\n\n  Bootstrap is a popular CSS framework open sourced by Twitter. It includes skins\n  so all bootstrap driven sites do not have to look alike. It provides support\n  for differing screen sizes and is relatively mobile friendly.\n\nhttp://getbootstrap.com\nhttps://github.com/twbs/bootstrap\n###\n(using [net github cdnjs message]\n  (ref bootswatch-themes [[\"cerulean\" \"cosmo\" \"cyborg\" \"darkly\" \"flatly\"\n    \"journal\" \"lumen\" \"paper\" \"readable\" \"sandstone\" \"simplex\" \"slate\"\n    \"spacelab\" \"superhero\" \"united\" \"yeti\" \"default\"]])\n\n  (ref build (lambda [target-repo]\n    (return (promise.all\n      (github.build target-repo \"bootstrap\" [[\n        {repo: \"twbs/bootstrap\" files: [[\n          {base: \"dist\" exclude: '/\\.map$|\\.min\\.|npm.js$/'}\n          {base: \"dist/fonts\" copy-to: \"fonts\"}\n        ]]}\n      ]])\n      (bootswatch-themes.map (lambda [theme]\n        (return (cdnjs.build target-repo (+ \"bootstrap-\" theme) [[\n          {repo: \"bootswatch\" files: [[{include: (+ theme \"/bootstrap.css\")}]]}\n        ]]))\n      ))\n    ))\n  ))\n\n  (lispz.css \"ext/bootstrap.css\")\n  (ref themes bootswatch-themes)\n  (ref random-theme (dot (random themes.length) in bootswatch-themes))\n\n  ### spec: Bootstrap >> Bootswatch\n  # https://bootswatch.com\n  # Loads a bootswatch theme to make the page look different.\n  # If no theme is provided, a random one is selected.\n  ###\n  (message.listen \"bootstrap/change-theme\" (lambda [theme-name]\n    (ref theme\n      (cond (not (defined? theme-name)) (random-theme)\n            (else)                      theme-name\n      )\n    )\n    (net.css (+ \"ext/bootstrap-\" theme \".css\"))\n  ))\n  ### spec: Bootstrap >> modal\n    Open a named modal dialog box and wait for a user response. Options:\n\n    * seed - object to fill modal form fields\n    * attributes - for the element being created\n  ###\n  (ref modal> (promise [name-path opts] (using [riot dom]\n    (ref name (last (name-path.split \"/\")))\n    (ref address (+ \"modal/\" name))\n    (ref show-modal (=> (message.send (+ address \"/show\"))))\n    (cond (get lispz.tags name) (show-modal)\n    (else) ## modals are singletons, load once\n      (when (riot.inject name-path opts.attributes)\n        (show-modal)\n      )\n    )\n    (ref hidden-address (+ address \"/hidden\"))\n    (message.listen hidden-address (=>\n      (message.clear hidden-address)\n      (resolve-promise (dom.scrape-form @.element))\n    ))\n  )))\n  ### spec: Bootstrap >> loading\n    We know that bootstrap has completed loading\n    when we see _modal_ added to the list of\n    JQuery functions.\n  ###\n  (ref loaded (net.script \"ext/bootstrap.js\" (=>\n    (return (($).modal))\n  )))\n  (when  loaded (export {build themes modal>}))\n  (promise.failed loaded (export {build}))\n)\n\n### spec: Bootstrap >> Bootstrap/RIOT/Lispz Combo\n  There is a difference of scope between bootstrap and riot.\n  [Bootstrap](http://getbootstrap.com/) is designed to be used page-wide.\n  Riot is a web component system where each component should be as independent as possible.\n  ###\n  ### spec: bootstrap >> Page Level Bootstrap\n\n  Any single page application that is going to use bootstrap to simplify the UI wraps the contents inside the body with a bootstrap tag. Use an inner page-content tag to allow for fluid layouts - those that change as the window changes size.\n\n      <body>\n        <bootstrap class=riot>\n          <page-content fluid=true>\n            ...\n          </page-content>\n        </bootstrap>\n      </body>\n\n  ###\n  ### spec: Bootstrap >> Bootstrap Themes\n\n  Bootstrap sites do not have to look alike. [Bootswatch](https://bootswatch.com/)\n  provides 16+ free themes, including ones that fit in with Metro, Polymer and Ubuntu:\n\n  > Default, Cerulean, Cosmo, Cyborg, Darkly, Flatly, Journal, Lumen, Paper, Readable,\n  > Sandstone, Simplex, Slate, Spacelab, Superhero, United, Yeti\n\n  To select a theme, send a message to _change-bootstrap-theme_ with the name of the theme\n  to change to. If you don't provide a theme name, a random one is chosen.\n\n  ###\n  ### spec: bootstrap >> Component Specific Bootstrap\n\n  Riot components can include a _style_ section.\n  If you preface all entries with the name of the component then you have\n  name-spaced your css.\n\n      <code-editor>\n        <panel height={ opts.height } heading={ heading } menu={ menu } owner={ _riot_id }>\n          <div name=wrapper class=wrapper></div>\n        </panel>\n        <style>\n          code-editor .wrapper {\n            ...\n          }\n      </code-editor>\n###\n"

lispz_modules['cdnjs']="### Load packages from CDN and other web sources - listing them when possible ###\n(using [net github list]\n  (ref cdnjs-actors {\n    list-all: (promise [repo path]\n      (ref base \"http://api.cdnjs.com/libraries?fields=assets&search=\")\n      (when (net.json-request (+ base repo.name)) [json]\n        ## select the correct repo for the name\n        (ref filtered (json.results.filter (lambda [it]\n          (return (=== it.name repo.name))\n        )))\n        (cond (filtered.length)\n          ((first filtered).assets.some (lambda [it]\n            (cond\n              (list.contains \"alpha\" it.version) false\n              (else) (do\n                (repo.update! {base: (+\n                  \"https://cdnjs.cloudflare.com/ajax/libs/\"\n                  repo.name \"/\" it.version \"/\"\n                )})\n                (resolve-promise it.files)\n                true ## found the one we want\n              ))\n          ))\n        (else)\n          false\n        )\n      )\n    )\n    read: (promise [repo path]\n      (ref uri (+ repo.base path))\n      (when (net.http-get uri) [response] (resolve-promise response))\n    )\n    repo: (lambda [target-repo name] (return (stateful {})))\n  })\n\n  (export {\n    build: (github.builder.bind null cdnjs-actors)\n  })\n)\n"

lispz_modules['chain']="### spec: functions >> chaining -- Chaining functions\n  In a functional style we often call multiple functions to incrementally move\n  from problem to solution. Each step takes the results from the step before and\n  transforms it. It is allways a good idea to have short functions that do one\n  thing - for testing, maintenance and readability. Speaking of readability,\n  chain makes the sequence of events clear.\n\n      (parse-titles (lambda [sections] (return (sections.map ...)))\n      (sort-titles  (lambda [sections] (return (sections.map ...)))\n      (merge-titles (lambda [sections] (return (sections.map ...)))\n\n      ((chain parse-titles sort-titles merge-titles) sections)\n###\n### spec: chain\n  (describe \"chain: run each function with the results from the one before\" (llbda []\n    (it \"(chain f1 f2 ...)\" (lambda []\n      (ref f1 (lambda [a] (return 2)))\n      (ref f2 (lambda [a] (return (+ a 3))))\n      (ref f3 (lambda [a] (return (* a 10))))\n      ((expect (chain f1 f2 f3)).toBe 50)\n    ))\n  ))\n###\n(export (lambda [] (ref functions (*arguments 0))\n  (ref link (lambda [arg func] (return (func arg))))\n  (return (lambdas.reduce link null))\n))\n"

lispz_modules['codemirror']="### spec: Libraries >> CodeMirror\nIn-browser code editor http://codemirror.net/\n\nhttps://github.com/codemirror/CodeMirror\n###\n(using  [net diff_match_patch message message dict github compilers]\n  (ref options-string (localStorage.getItem \"CodeMirror-options\"))\n  (ref options (stateful.morph!\n    (cond options-string (JSON.parse options-string)\n    (else)  {\n      lineNumbers:        true\n      foldGutter:         true\n  ##  gutters:            [\"CodeMirror-lint-markers\"\n  ##                       \"CodeMirror-foldgutter\"]\n      lint:               true\n      matchBrackets:      true\n      autoCloseBrackets:  true\n      matchTags:          true\n      showTrailingSpace:  true\n      inputStyle:         \"textarea\" ## change to \"contenteditable\" after vim cursor bug fix\n      autofocus:          false\n      dragDrop:           false\n      smartIndent:        true\n      indentUnit:         2\n      indentWithTabs:     false\n      cursorScrollMargin: 5\n      scrollbarStyle:     \"overlay\"\n      extraKeys:          {\n        'Cmd-Left':         \"goLineStartSmart\"\n        'Ctrl-Q':           \"fold_at_cursor\"\n        'Ctrl-Space':       \"autocomplete\"\n        'Ctrl-/':           \"toggleComment\"\n        'Ctrl-<':           \"goColumnLeft\"\n        'Ctrl->':           \"goColumnRight\"\n        'Ctrl-Shift-F':     \"clearSearch\"\n        'Ctrl-=':           \"toMatchingTag\"\n        'Alt-S':            \"view_source\"\n        'Ctrl-`':           \"insertSoftTab\"\n        'Ctrl-,':           \"delLineLeft\"\n        'Ctrl-.':           \"killLine\"\n        'Shift-Ctrl-,':     \"delWrappedLineLeft\"\n        'Shift-Ctrl-.':     \"delWrappedLineRight\"\n        'Ctrl-9':           \"delWordBefore\"\n        'Ctrl-0':           \"delWordAfter\"\n        'Ctrl-6':           \"transposeChars\"\n        'Ctrl-Left':        \"goWordLeft\"\n        'Ctrl-Right':       \"goWordRight\"\n        'Ctrl-Home':        \"goLineLeft\"\n        'Ctrl-Shift-Home':  \"goLineLeftSmart\"\n        'Ctrl-End':         \"goLineRight\"\n        ## paredit keys that defer if not in lisp code\n        'Backspace':        \"subpar_backward_delete\"\n        'Delete':           \"subpar_forward_delete\"\n        'Ctrl-D':           \"subpar_forward_delete\"\n\n        'Shift-9':          \"subpar_open_bracket\"\n        '[':                \"subpar_open_square_bracket\"\n        'Shift-[':          \"subpar_open_braces\"\n\n        'Shift-0':          \"subpar_close_bracket\"\n        ']':                \"subpar_close_square_bracket\"\n        'Shift-]':          \"subpar_close_braces\"\n\n        'Shift-\\'':          \"subpar_double_quote\"\n\n        'Ctrl-Alt-F':       \"subpar_forward\"\n        'Ctrl-Alt-B':       \"subpar_backward\"\n        'Ctrl-Alt-U':       \"subpar_backward_up\"\n        'Ctrl-Alt-D':       \"subpar_forward_down\"\n        'Ctrl-Alt-P':       \"subpar_backward_down\"\n        'Ctrl-Alt-N':       \"subpar_forward_up\"\n\n        'Shift-Ctrl-[':     \"subpar_backward_barf\"\n        'Ctrl-Alt-Right':   \"subpar_backward_barf\"\n        'Ctrl-]':           \"subpar_backward_barf\"\n\n        'Shift-Ctrl-]':     \"subpar_forward_barf\"\n        'Ctrl-Left':        \"subpar_forward_barf\"\n\n        'Shift-Ctrl-9':     \"subpar_backward_slurp\"\n        'Ctrl-Alt-Left':    \"subpar_backward_slurp\"\n        'Ctrl-[':           \"subpar_backward_slurp\"\n\n        'Shift-Ctrl-0':     \"subpar_forward_slurp\"\n        'Ctrl-Right':       \"subpar_forward_slurp\"\n\n        'Alt-Up':           \"subpar_splice_delete_backward\"\n        'Alt-Down':         \"subpar_splice_delete_forward\"\n        'Alt-S':            \"subpar_splice\"\n        'Ctrl-Alt-/':       \"subpar_indent_selection\"\n\n        'Alt-Enter':        \"run_selection\"\n       }\n    })\n  ))\n  ## write changed options back to persistent storage\n  (ref update-options (lambda\n    (localStorage.setItem \"CodeMirror-options\" (JSON.stringify options))\n  ))\n  ## Context menu for code editor\n  (ref topic \"codemirror/command\")\n  (ref menu [[\n    ### {title: \"File\" children: [[\n      {topic meta: \"save\" title: \"Save\"}\n    ]]} ###\n    {title: \"Edit\" children: [[\n      {topic meta: \"autocomplete\" title: \"Auto-Complete\" }\n      {topic meta: \"redo\" title: \"Redo\"}\n      {topic meta: \"undo\" title: \"Undo\"}\n      {topic meta: \"redoSelection\" title: \"Redo Selection\"}\n      {topic meta: \"undoSelection\" title: \"Undo Selection\"}\n      {divider: true}\n      {topic meta: \"toggleOverwrite\" title: \"Insert/Overwrite\"}\n      {topic meta: \"toggleComment\" title: \"Comment/Uncomment\" }\n      {topic meta: \"insertSoftTab\" title: \"Insert Soft Tab\" }\n      {topic meta: \"defaultTab\" title: \"Tab or Indent\"}\n      {title: \"Delete\" children: [[\n        {topic meta: \"deleteLine\" title: \"Line\"}\n        {topic meta: \"killLine\" title: \"Line Right\" }\n        {topic meta: \"delLineLeft\" title: \"Line Left\" }\n        {divider: true}\n        {topic meta: \"delWrappedLineLeft\" title: \"Wrapped Line Left\" }\n        {topic meta: \"delWrappedLineRight\" title: \"Wrapped Line Right\" }\n        {divider: true}\n        {topic meta: \"delWordBefore\" title: \"Word Left\" }\n        {topic meta: \"delWordAfter\" title: \"Word Right\" }\n        {divider: true}\n        {topic meta: \"delGroupBefore\" title: \"Group Before\"}\n        {topic meta: \"delGroupAfter\" title: \"Group After\"}\n        {divider: true}\n        {topic meta: \"delCharBefore\" title: \"Character Left\"}\n        {topic meta: \"delCharAfter\" title: \"Character Right\"}\n      ]]}\n      {topic meta: \"indentAuto\" title: \"Auto Indent\"}\n      {topic meta: \"indentLess\" title: \"Indent Left\"}\n      {topic meta: \"indentMore\" title: \"Indent Right\"}\n      {topic meta: \"newlineAndIndent\" title: \"New line and indent\"}\n      {divider: true}\n      {topic meta: \"transposeChars\" title: \"Transpose Characters\" }\n      {divider: true}\n      {topic meta: \"selectAll\" title: \"Select All\"}\n      {topic meta: \"singleSelection\" title: \"Single Selection\"}\n    ]]}\n    {title: \"Go\" children: [[\n      {topic meta: \"goDocStart\" title: \"Document Start\"}\n      {topic meta: \"goDocEnd\" title: \"Document End\"}\n      {divider: true}\n      {topic meta: \"goCharLeft\" title: \"Char Left\"}\n      {topic meta: \"goCharRight\" title: \"Char Right\"}\n      {divider: true}\n      {topic meta: \"goColumnLeft\" title: \"Column Left\" }\n      {topic meta: \"goColumnRight\" title: \"Column Right\" }\n      {divider: true}\n      {topic meta: \"goGroupLeft\" title: \"Group Left\"}\n      {topic meta: \"goGroupRight\" title: \"Group Right\"}\n      {divider: true}\n      {topic meta: \"goWordLeft\" title: \"Word Left\" }\n      {topic meta: \"goWordRight\" title: \"Word Right\" }\n      {divider: true}\n      {topic meta: \"goLineStart\" title: \"Line Start\"}\n      {topic meta: \"goLineStartSmart\" title: \"Smart Line Start\" }\n      {topic meta: \"goLineEnd\" title: \"Line End\"}\n      {divider: true}\n      {topic meta: \"goLineLeft\" title: \"Line Left\" }\n      {topic meta: \"goLineLeftSmart\" title: \"Smart Line Left\" }\n      {topic meta: \"goLineRight\" title: \"Line Right\" }\n      {divider: true}\n      {topic meta: \"goLineUp\" title: \"Line Up\"}\n      {topic meta: \"goLineDown\" title: \"Line Down\"}\n      {divider: true}\n      {topic meta: \"goPageUp\" title: \"Page Up\"}\n      {topic meta: \"goPageDown\" title: \"Page Down\"}\n    ]]}\n    {title: \"Search\" children: [[\n      {topic meta: \"find\" title: \"Find...\"}\n      {topic meta: \"findNext\" title: \"Find Next\"}\n      {topic meta: \"findPrev\" title: \"Find Previous\"}\n      {topic meta: \"clearSearch\" title: \"Clear Search\" }\n      {divider: true}\n      {topic meta: \"replace\" title: \"Replace\"}\n      {topic meta: \"replaceAll\" title: \"Replace All\"}\n      ## {divider: true} appears to only work for XML\n      ## {topic meta: \"toMatchingTag\" title: \"Matching Tag\" }\n    ]]}\n    {title: \"View\" children: [[\n      {topic meta: \"view_keyboard_shortcuts\" title: \"Keyboard Shortcuts\" }\n      {topic meta: \"fold_at_cursor\" title: \"Fold at Cursor\" }\n      {title: \"Theme\" children: [[\n        {title: \"Dark\" children: [[\n          {topic meta: \"set_option,theme,3024-night\" title: \"3024\"}\n          {topic meta: \"set_option,theme,ambiance\" title: \"Ambience\"}\n          {topic meta: \"set_option,theme,ambiance-mobile\" title: \"Ambience (mobile)\"}\n          {topic meta: \"set_option,theme,base16-dark\" title: \"Base 16\"}\n          {topic meta: \"set_option,theme,blackboard\" title: \"Blackboard\"}\n          {topic meta: \"set_option,theme,cobalt\" title: \"Cobalt\"}\n          {topic meta: \"set_option,theme,colorforth\" title: \"Colour Forth\"}\n          {topic meta: \"set_option,theme,erlang-dark\" title: \"Erlang Dark\"}\n          {topic meta: \"set_option,theme,lesser-dark\" title: \"Lesser Dark\"}\n          {topic meta: \"set_option,theme,mbo\" title: \"MBO\"}\n          {topic meta: \"set_option,theme,midnight\" title: \"Midnight\"}\n          {topic meta: \"set_option,theme,monokai\" title: \"Monokai\"}\n          {topic meta: \"set_option,theme,night\" title: \"Night\"}\n          {topic meta: \"set_option,theme,paraiso-dark\" title: \"Paraiso\"}\n          {topic meta: \"set_option,theme,pastel-on-dark\" title: \"Pastel\"}\n          {topic meta: \"set_option,theme,rubyblue\" title: \"Ruby Blue\"}\n          {topic meta: \"set_option,theme,the-matrix\" title: \"The Matrix\"}\n          {topic meta: \"set_option,theme,tomorrow-night-bright\" title: \"Tomorrow Night\"}\n          {topic meta: \"set_option,theme,tomorrow-night-eighties\" title: \"Tomorrow Night Eighties\"}\n          {topic meta: \"set_option,theme,twilight\" title: \"Twilight\"}\n          {topic meta: \"set_option,theme,vibrant-ink\" title: \"Vibrant Ink\"}\n          {topic meta: \"set_option,theme,xq-dark\" title: \"XQ Dark\"}\n          {topic meta: \"set_option,theme,zenburn\" title: \"Zenburn\"}\n        ]]}\n        {title: \"Light\" children: [[\n          {topic meta: \"set_option,theme,3024-day\" title: \"3024\"}\n          {topic meta: \"set_option,theme,base16-light\" title: \"Base 16\"}\n          {topic meta: \"set_option,theme,default\" title: \"Default\"}\n          {topic meta: \"set_option,theme,eclipse\" title: \"Eclipse\"}\n          {topic meta: \"set_option,theme,elegant\" title: \"Elegant\"}\n          {topic meta: \"set_option,theme,mdn-line\" title: \"MDN\"}\n          {topic meta: \"set_option,theme,neat\" title: \"Neat\"}\n          {topic meta: \"set_option,theme,neo>Neo\"}\n          {topic meta: \"set_option,theme,paraiso-light\" title: \"Paraiso\"}\n          {topic meta: \"set_option,theme,solarized\" title: \"Solarized\"}\n          {topic meta: \"set_option,theme,xq-light\" title: \"XQ Light\"}\n        ]]}\n      ]]}\n    ]]}\n    {title: \"Settings\" children: [[\n      {title: \"Keyboard\" children: [[\n        {topic meta: \"set_mode,default\" title: \"Code Mirror\"}\n        {topic meta: \"set_mode,emacs\" title: \"Emacs\"}\n        {topic meta: \"set_mode,sublime\" title: \"Sublime\"}\n        {topic meta: \"set_mode,vim\" title: \"Vi\"}\n      ]]}\n      {divider: true}\n      {topic meta: \"toggle_option,smartIndent\" title: \"Auto-indent\"}\n      {title: \"Indent\" children: [[\n        {topic meta: \"set_option,indentUnit,2\" title: \"2\"}\n        {topic meta: \"set_option,indentUnit,4\" title: \"4\"}\n      ]]}\n      {topic meta: \"toggle_option,autoCloseBrackets\" title: \"Close Brackets\"}\n      {topic meta: \"toggle_option,matchBrackets\" title: \"Match Brackets\"}\n      {topic meta: \"toggle_option,matchTags\" title: \"Match Tags\"}\n      {divider: true}\n      {title: \"Scroll Margin\" children: [[\n        {topic meta: \"set_option,cursorScrollMargin,0\" title: \"0\"}\n        {topic meta: \"set_option,cursorScrollMargin,2\" title: \"2\"}\n        {topic meta: \"set_option,cursorScrollMargin,4\" title: \"4\"}\n      ]]}\n      {topic meta: \"toggle_option,continueComments\" title: \"Comment Continuation\"}\n      {topic meta: \"toggle_option,showTrailingSpace\" title: \"Show Trailing Spaces\"}\n      {topic meta: \"toggle_option,dragDrop\" title: \"Toggle Drag and Drop\"}\n      {topic meta: \"toggle_option,lineNumbers\" title: \"Toggle Line Numbers\"}\n      {topic meta: \"toggle_option,lineWrapping\" title: \"Toggle Line Wrap\"}\n    ]]}\n  ]])\n  (ref listener (lambda [cm data]\n    (ref args (data.item.meta.split \",\"))\n    (ref command (args.shift))\n    (args.unshift cm)\n    ((get CodeMirror command).apply CodeMirror args)\n  ))\n  (ref open (lambda [owner wrapper]\n    (ref cm (stateful.morph! (CodeMirror wrapper options)))\n    (cm.update! {listener-address: (+ owner \"/\" topic)})\n    (message.send \"codemirror/menu\" menu)\n    (message.listen cm.listener-address (lambda [data] (listener cm data)))\n    (return cm)\n  ))\n  (ref close (lambda [cm]\n    (message.clear cm.listener-address)\n  ))\n  (ref spaces \"                \")\n\n  (ref extra-commands {\n    view_keyboard_shortcuts: (lambda [cm]\n      (ref keys (stateful []))\n      (ref one-map (lambda [key-map]\n        ((Object.keys key-map).forEach (lambda [key]\n          (ref key-value (get key-map key))\n          (cond\n            (is key \"fallthrough\") (do\n                (ref more (cond\n                  (is (typeof key-value) \"string\") [[key-value]]\n                  (else)                           key-value\n                ))\n                (more.forEach (lambda [key-map]\n                  (one-map (get CodeMirror.keyMap key-map))\n                ))\n              )\n            (else) (keys.push! (+ key \": \" key-value))\n          )\n        ))\n      ))\n      (one-map cm.options.extraKeys)\n      (ref core (stateful.morph! (get CodeMirror.keyMap key-map cm.options.keyMap)))\n      (cond (not core.fallthrough)\n        (core.update! {fallthrough: CodeMirror.keyMap.default.fallthrough}))\n      (one-map core)\n      (window.open\n        (+ \"data:text/html,\" (encodeURIComponent (keys.join \"<br>\")))\n        \"Keys\" \"width=300,height=600\")\n    )\n    fold_at_cursor: (lambda [cm]\n      (cm.foldCode (cm.getCursor))\n    )\n    toggle_option: (lambda [cm name]\n      (CodeMirror.commands.set_option cm name (not (cm.getOption name)))\n    )\n    set_option: (lambda [cm name value]\n      (cm.setOption name value)\n      (options.update! name value)\n      (update-options)\n    )\n    set_mode: (lambda [cm mode]\n      (CodeMirror.commands.set_option cm \"keyMap\" mode)\n    )\n    auto_complete: (lambda [cm]\n      (ref not-only (lambda\n        (ref result (CodeMirror.hint.anyword.apply null arguments))\n        (cond\n          (isnt result.list.length 1) result\n          (else) (do\n            (ref size (- result.to.ch result.from.ch))\n            (ref first-choice (first result.list))\n            (cond\n              (isnt first-choice.length size) result\n              (else) ((stateful.morph! result) {list: [[]]}))\n        ))\n      ))\n    )\n  })\n  ## Editing modes dependent on file type\n  (ref default-mode-extensions {\n    apl: \"apl\" as3: \"apl\" asf: \"apl\"\n    c: \"clike\" cpp: \"clike\" h: \"clike\" cs: \"clike\"\n    chh: \"clike\" hh: \"clike\" h__: \"clike\" hpp: \"clike\"\n    hxx: \"clike\" cc: \"clike\" cxx: \"clike\" c__: \"clike\"\n    \"c++\": \"clike\" stl: \"clike\" sma: \"clike\"\n    java: \"clike\" scala: \"clike\" clj: \"clojure\"\n    cpy: \"cobol\" cbl: \"cobol\"cob: \"cobol\"\n    coffee: \"coffeescript\" coffeescript: \"coffeescript\"\n    \"gwt.coffee\": \"coffeescript\"\n    vlx: \"commonlisp\" fas: \"commonlisp\" lsp: \"commonlisp\"\n    el: \"commonlisp\" css: \"css\" less: \"css\"\n    dl: \"d\" d: \"d\" diff: \"diff\" dtd: \"dtd\" dylan: \"dylan\"\n    ecl: \"ecl\" e: \"eiffel\" erl: \"erlang\" hrl: \"erlang\"\n    f: \"fortran\" for: \"fortran\" FOR: \"fortran\"\n    f95: \"fortran\" f90: \"fortran\" f03: \"fortran\"\n    gas: \"gas\" gfm: \"gfm\" feature: \"gherkin\" go: \"go\"\n    groovy: \"groovy\" \"html.haml\": \"haml\" hx: \"haxe\"\n    lhs: \"haskell\" gs: \"haskell\" hs: \"haskell\"\n    asp: \"htmlembedded\" jsp: \"htmlembedded\"\n    ejs: \"htmlembedded\" http: \"http\"\n    html: \"htmlmixed\" htm: \"htmlmixed\" \".py.jade\": \"jade\"\n    js: \"javascript\" json: \"javascript\" jinja2: \"jinja2\"\n    jl: \"julia\" ls: \"livescript\" lua: \"lua\"\n    markdown: \"markdown\" mdown: \"markdown\" mkdn: \"markdown\"\n    md: \"markdown\" mkd: \"markdown\" mdwn: \"markdown\"\n    mdtxt: \"markdown\" mdtext: \"markdown\"\n    mdx: \"mirc\" dcx: \"mirc\"\n    ml: \"mllike\" fs: \"mllike\" fsi: \"mllike\"\n    mli: \"mllike\" fsx: \"mllike\" fsscript: \"mllike\"\n    nginx: \"nginx\" nt: \"ntriples\" mex: \"octave\"\n    pas: \"pascal\" pegjs: \"pegjs\" ps: \"perl\"\n    php: \"php\" \"lib.php\": \"php\"\n    pig: \"pig\" ini: \"properties\" properties: \"properties\"\n    pp: \"puppet\" py: \"python\" q: \"q\" r: \"r\"\n    rpm: \"rpm\" \"src.rpm\": \"rpm\" rst: \"rst\" rb: \"ruby\"\n    rs: \"rust\" sass: \"sass\" scm: \"scheme\" ss: \"scheme\"\n    sh: \"shell\" sieve: \"sieve\"\n    sm: \"smalltalk\" st: \"smalltalk\" tpl: \"smartymixed\"\n    solr: \"solr\" sparql: \"sparql\" sql: \"sql\"\n    stex: \"stex\" tex: \"stex\" tcl: \"tcl\" tw: \"tiddlywiki\"\n    tiki: \"tiki\" toml: \"toml\" ttl: \"turtle\" vb: \"vb\"\n    bas: \"vbscript\" vbs: \"vbscript\" vtl: \"velocity\"\n    v: \"verilog\" xml: \"xml\"\n    xquery: \"xquery\" xq: \"xquery\" xqy: \"xquery\"\n    yaml: \"yaml\" yml: \"yaml\" z80: \"z80\" asm: \"z80\"\n  })\n  (ref saved-mode-extensions localStorage.CodeMirror-mode-extensions)\n  (ref mode-extensions (cond\n    saved-mode-extensions\n      (dict.merge default-mode-extensions (JSON.parse saved-mode-extensions))\n    (else)\n      default-mode-extensions\n  ))\n  (ref get-mode-extension (pull mode-extensions))\n\n  (ref set-mode (lambda [cm name]\n    (ref mode (do\n      (ref parts (name.split \".\"))\n      (ref exts (parts.slice (cond (> parts.length 2) -2 (else) -1)))\n      (ref ext (exts.join \".\"))\n      (ref mode-extension (get mode-extensions ext))\n      (cond mode-extension             mode-extension\n            (get CodeMirror.modes ext) ext\n            (else)                     \"text\"\n      )\n    ))\n    (cm.setOption \"mode\" mode)\n    (CodeMirror.autoLoadMode cm mode)\n  ))\n\n  ## CodeMirror lispz mode\n  (ref init-lispz-mode (lambda\n  (CodeMirror.defineSimpleMode \"lispz\" {\n    start: [[\n      {regex: '/\"\"/'                                 token: \"string\"}\n      {regex: '/\"/'                   next: \"string\" token: \"string\"}\n      {regex: '/\\'(?:[^\\\\]|\\\\.)*?\\'/'                token: \"variable-2\"}\n      {regex: '/###/'                next: \"comment\" token: \"comment\" }\n      {regex: '/(\\()(?:([^\\s\\(\\[\\{\\)\\}\\]]*?(?:!|\\.push!?|\\.pop!?\\b))|(stateful\\b))/'\n                                indent: true  token: [[\"bracket\" \"error\" \"error\"]]}\n      {regex: '/(\\()([^\\s\\(\\[\\{\\)\\}\\]]+)/'\n                                indent: true  token: [[\"bracket\" \"keyword\"]]}\n      {regex: '/true|false|null|undefined|debugger/' token: \"atom\"}\n      {regex: '/0x[a-f\\d]+|[-+]?(?:\\.\\d+|\\d+\\.?\\d*)(?:e[-+]?\\d+)?/i'\n                                                     token: \"number\"}\n      {regex: '/## .*/'                              token: \"comment\"}\n      {regex: '/[\\{\\(\\[]/'        indent: true       token: \"bracket\"}\n      {regex: '/[\\}\\)\\]]/'        dedent: true       token: \"bracket\"}\n      {regex: '/[^\\s\\(\\{\\[\\)\\]\\}]+/'                 token: \"variable\"}\n      {regex: '/\\s+/' next: \"start\"}\n    ]]\n    comment: [[\n      {regex: '/###/' token: \"comment\" next: \"start\"}\n      {regex: '/.*/'  token: \"comment\"}\n    ]]\n    string: [[\n      {regex: '/[^\\\\]\"/' token: \"string\" next: \"start\"}\n      {regex: '/./' token: \"string\"}\n    ]]\n    meta: { lineComment: \"## \" dontIndentStates: [[\"comment\" \"string\"]] }\n  })\n  (CodeMirror.defineMIME \"text/lispz\" \"lispz\")\n  ## Update htmlmixed to understand lispz scripts\n  (ref mimeModes (stateful.morph! CodeMirror.mimeModes))\n  (cond (is (typeof (get mimeModes \"text/html\")) \"string\")\n        (mimeModes.update! \"text/html\" {name: \"htmlmixed\"}))\n  (ref mode (stateful.morph! (get mimeModes \"text/html\")))\n  (cond (not mode.scriptTypes) (mode.update! {scriptTypes: [[]]}))\n  (ref scriptTypes (stateful mode.scriptTypes))\n  (scriptTypes.push! {matches: '/^text\\/lispz$/' mode: \"lispz\"})\n  (mimeModes.update! {htmlmixed: mode})\n\n  (ref get-source (=> (cond\n    (@.somethingSelected)  (@.doc.getSelection)\n    (else)                 (@.doc.getValue)\n  )))\n\n  (ref get-compiler (=>\n    (ref mode     (@.getModeAt (@.getCursor)))\n    (ref compiler (get compilers mode.name))\n    (cond\n      compiler compiler\n      (else)   { compile: (=> \"\") }\n    )\n  ))\n\n  (ref compile (lambda [cm name]\n    ((get-compiler cm).compile (get-source cm))\n  ))\n\n  (ref run_selection (lambda [cm]\n    (ref compiler (get-compiler cm))\n    (ref source (get-source cm))\n\n    (message.send \"code-editor/run/prepare\" { source })\n    (ref js (compiler.compile source ))\n    (message.send \"code-editor/run/compiled\" {\n      source js: (compilers.to-string js)\n    })\n    (compilers.run js)\n  ))\n  ### spec: codemirror >> Compiling Code\n    To send the compiler output to anywhere but the console, use a copy of the\n    following code.\n      (message.send \"code-editor/compile/js\" (lambda [compiled]\n        ## compiled: {name source js}\n      ))\n  ###\n  (message.listen \"code-editor/compile/js\" (lambda [compiled]))\n  ### spec:\n    To process the console output from running compiled code:\n      (message.listen \"code-editor/run/output\" (lambda [run]\n        ## run: {name source output}\n      ))\n  ###\n  (message.listen \"code-editor/run/output\" (lambda [run]\n    ## (console.log run.output)\n  ))\n\n  (ref lisp-modes {lispz: true clojure: true commonlisp: true scheme: true})\n  (ref lisp-mode  (pull lisp-modes))\n  (ref subpar-command (pull subpar.core))\n\n  (ref subpart (lambda [cmd opt]\n    (return (lambda [cm]\n      (return CodeMirror.Pass) ## make a configuration option\n      (ref mode (cm.getModeAt (cm.getCursor)))\n      (cond (lisp-mode mode.name)  ((subpar-command cmd) cm opt)\n            (else)                 CodeMirror.Pass\n      )\n    ))\n  ))\n  (CodeMirror.commands.update! {\n    ## paredit keys that defer if not in lisp code\n    subpar_backward_delete:        (subpart \"backward_delete\")\n    subpar_forward_delete:         (subpart \"forward_delete\")\n    subpar_forward_delete:         (subpart \"forward_delete\")\n\n    subpar_open_bracket:           (subpart \"open_expression\" \"()\")\n    subpar_open_square_bracket:    (subpart \"open_expression\" \"[]\")\n    subpar_open_braces:            (subpart \"open_expression\" \"{}\")\n\n    subpar_close_bracket:          (subpart \"close_expression\" \")\")\n    subpar_close_square_bracket:   (subpart \"close_expression\" \"]\")\n    subpar_close_braces:           (subpart \"close_expression\" \"}\")\n\n    subpar_double_quote:           (subpart \"double_quote\")\n\n    subpar_forward:                (subpart \"forward\")\n    subpar_backward:               (subpart \"backward\")\n    subpar_backward_up:            (subpart \"backward_up\")\n    subpar_forward_down:           (subpart \"forward_down\")\n    subpar_backward_down:          (subpart \"backward_down\")\n    subpar_forward_up:             (subpart \"forward_up\")\n\n    subpar_backward_barf:          (subpart \"backward_barf\")\n    subpar_backward_barf:          (subpart \"backward_barf\")\n    subpar_backward_barf:          (subpart \"backward_barf\")\n\n    subpar_forward_barf:           (subpart \"forward_barf\")\n    subpar_forward_barf:           (subpart \"forward_barf\")\n\n    subpar_backward_slurp:         (subpart \"backward_slurp\")\n    subpar_backward_slurp:         (subpart \"backward_slurp\")\n    subpar_backward_slurp:         (subpart \"backward_slurp\")\n\n    subpar_forward_slurp:          (subpart \"forward_slurp\")\n    subpar_forward_slurp:          (subpart \"forward_slurp\")\n\n    subpar_splice_delete_backward: (subpart \"splice_delete_backward\")\n    subpar_splice_delete_forward:  (subpart \"splice_delete_forward\")\n    subpar_splice:                 (subpart \"splice\")\n    subpar_indent_selection:       (subpart \"indent_selection\")\n\n    run_selection:                 run_selection\n  })\n  ))\n\n  ## elm script has a bug - restore for a later version.\n  ## tern is for javascript features - overrides console.log\n  (ref build-base (lambda [target-repo]\n    (return (github.build target-repo \"codemirror\" [[\n      {repo: \"codemirror/CodeMirror\" files: [[\n        {base: \"lib\" include: '/codemirror\\.(js|css)$/'}\n        {base: \"addon/mode\" include: '/^simple.js$/'}\n        {base: \"keymap\"}\n        {base: \"addon\" exclude: '/test.js$|node.js$|standalone.js$|\\/tern\\//'}\n        {base: \"mode/htmlmixed\" include: '/css$|js$/'}\n        {base: \"mode/javascript\" include: '/css$|js$/'}\n        {base: \"mode/css\" include: '/css$|js$/'}\n      ]]}\n      {repo: \"achengs/subpar\" files: [[\n        {base: \"resources/public/js\" include: '/subpar.core.js/'}\n      ]]}\n    ]]))\n  ))\n  (ref build-themes (lambda [target-repo]\n    (return (github.build target-repo \"codemirror-themes\" [[\n      {repo: \"codemirror/CodeMirror\" files: [[\n        {base: \"theme\"}\n      ]]}\n    ]]))\n  ))\n  (ref build-mode (lambda [target-repo]\n    (return (github.build target-repo \"codemirror-modes\" [[\n      {repo: \"codemirror/CodeMirror\" files: [[\n        {base: \"mode\" exclude: '/htmlmixed|javascript|css|elm.js$|test.js$/'}\n      ]]}\n    ]]))\n  ))\n  (ref build (lambda [target-repo]\n    (return (promise.all build-base build-themes build-mode))\n  ))\n\n  (lispz.css \"ext/codemirror.css\")\n  (ref loaded (net.script \"ext/codemirror.js\"(lambda (return window.CodeMirror))))\n  (when loaded\n    (ref modes-loaded (net.script \"ext/codemirror-modes.js\" (lambda (return CodeMirror.modes.z80))))\n    (when modes-loaded\n      (stateful.morph! CodeMirror.commands)\n      (CodeMirror.commands.update! extra-commands)\n      (init-lispz-mode)\n      (export {options open close set-mode build})\n    )\n    (promise.failed loaded (export {build}))\n  )\n  (delay 100 (lispz.css \"ext/codemirror-themes.css\"))\n)\n"

lispz_modules['compilers']="  ### spec: Compilers\n    The compiler entry for each language is a function that is called with the\n    name of the source code followed by the source itself.\n\n        (using [compilers]\n          (ref js (compilers.lispz.compile \"(console.log \\\"Hi\\\")\" \"name\"))\n          (console.log (compilers.to-string js))\n          (console.log (compilers.run js))\n        )\n  ###\n  (export {\n    to-string: (lambda [js] (return (js.join \"\\n\")))\n    run:       (lambda [js] (return (eval (js.join \"\\n\"))))\n\n    lispz: { compile: (lambda [source name]\n      (return (lispz.compile (+ source \"\\n\") name))\n    )}\n  })\n"

lispz_modules['core']="### spec: Modules >> Module Structure\n\nAll Lispz source files are modules. They are loaded on first request by client code. Subsequent requests returns a cached reference to the exports.\n###\n### spec: Modules >> Module Usage\n\nEvery module must include an export statement including a dictionary of symbols to be exported\n\n    (ref one (lambda [] ...)\n    (ref two 22)\n    (export {one two})\n\nIf a module requires other asynchronous operations it can defer the export statement until they are ready.\n\n    (lispz.script \"ext/jquery.js\" (lambda [] (export { ... })))\n\nTo access external modules, wrap your code in 'using'. Data and functions exported from a module are linked to the import name.\n\n    (using [dict net list]\n      (ref combined (dict.merge d1 d2 d3))\n    )\n\n...and that is all there is to it.\n###\n(macro using [modules *on_ready] (lispz.load (#join '' '\"' modules '\"')\n  (lambda (#requires modules) *on_ready)\n))\n### Modules must export to continue processing ###\n(macro export [exports] (#join '' '__module_ready__(' exports ')'))\n\n### spec: developer >> debug\n  `(debug)` is a development helper macro. It will print a stack trace\n  and the contents of any parameters on the console. If you left-align it\n  then it will be easy to find later to delete.\n###\n### spec: debug\n  (describe \"(debug [p1, p2, ...]) ## macro to display stack and messages\" (lambda []\n    (it \"displays a stack trace and the parameters provided\" (lambda []\n      (spy-method console trace)\n      (debug \"multiple\" \"parameters\")\n      ((expect console.trace).toHaveBeenCalled)\n    ))\n  ))\n###\n(macro debug [*msg] (console.trace (#join ',' *msg)))\n\n### spec: basic >> lambda\n###\n(macro => [*body] (lambda [@] *body))\n\n### spec: basic >> functions >> Variable Parameter Lists\n    Like JavaScript, lispz function definitions specify a fixed number of arguments.\n    To gain access to the full list of arguments, use *arguments, with a starting index.\n\n        (lambda [type rest] (console.log type \"=\" (*arguments 1)))\n###\n(macro *arguments [from] (lispz.slice.call arguments from))\n\n### spec: basic >> References\n  @TODO\n###\n(macro ref [name value]\n  (#join '' '(_res_=(' name '=' value '))')\n  (#ast add_reference name)\n)\n\n### spec: basic >> References >> Global References\n  @TODO\n###\n(macro global [name value]\n  (#join '' 'lispz.globals.' name '=' value)\n  (macro name [&params] (#join '' '(_res_=lispz.globals.' name '(' &params '))'))\n)\n\n### spec: basics -- Conditionals\n    Lispz boasts only one traditional conditional operator plus a number of\n    macros for conditional assignment and function return. The operator,\n    cond takes pairs of lists where the first is the condition and the\n    second the action. Evaluation stops after the first true condition.\n    There is an else macro that evaluates to true to catch situations not\n    covered specifically. The default? function takes a value and returns\n    it if it exists and is not empty, otherwise it returns the default value.\n\n        (cond (is v \"One\")  1\n              (not v)       0\n              (else)       -1\n        )\n\n    Because conditionals work with list pairs, it is necessary to wrap the actions\n    if there are more than one. Lispz provides 'do' for that.\n\n        (cond ok (do (finish-up) true))\n\n    The standard conditional tests (< > <= >=, etc) are augmented by aliases (is isnt not).\n###\n(macro cond [*list]\n  ((lambda\n    (#join '' ';switch(false){case !(' (#pairs *list '):return ' ';case!(') '}')\n    (return null)\n  ) arguments)\n)\n(macro else 'true')\n\n### spec: basics >> Operators ###\n(macro not [value] (#join '' '!(' value ')'))\n(macro instance-of [type obj] (#join '' '(' obj ' instanceof ' type ')'))\n\n(macro closure [?params *body] ((lambda *body) ?params))\n\n### spec: basic >> do\n###\n(macro do [*body] ((lambda *body) arguments))\n\n### spec: function\n  (describe \"(lambda [p1 p2 ...] ...) ## function definition\" (lambda []\n    (it \"defines an anonymous function that can be called\" (lambda []\n      (ref f1 (lambda [a b] (return (* a b))))\n      (ref result (f1 2 3))\n      ((expect result).toBe 6)\n    ))\n    (it \"has optional parameters\" (lambda []\n      (ref f2 (lambda (return 333)))\n      (ref result (f2))\n      ((expect result).toBe 333)\n    ))\n  ))\n  (describe \"(lambda [p1 p2 ...] ...) ## alternate function definition\" (lambda []\n    (it \"defines an anonymous function that can be called\" (lambda []\n      (ref f1 (lambda [a b] (return (* a b))))\n      (ref result (f1 2 3))\n      ((expect result).toBe 6)\n    ))\n    (it \"has optional parameters\" (lambda []\n      (ref f2 (lambda [] (return 222)))\n      (ref result (f2))\n      ((expect result).toBe 222)\n    ))\n  ))\n###\n\n### spec: basic >> Retrieval - can be used for objects and arrays\n  @TODO\n###\n(macro get [dict *key] (#join '' '(_res_=' dict '[' (#join '][' *key) '])'))\n\n### spec: conditional processing ###\n(macro empty? [list] (not list.length))\n(macro defined? [field] (!== (typeof field) \"undefined\"))\n\n\n(macro new [cls *params] (#join '' '(new ' cls '(' (#join ',' *params) '))'))\n###\n# Use contain to contain state changes. Any var inside a contain can be changed\n# no matter how many times the contain is called concurrently. It is also allows\n# the passing in of variables that are effectively copied and cannot be changed\n# from outside.\n###\n(macro contain [contain#args *contain#body]\n  ((lambda contain#args *contain#body) contain#args)\n)\n\n### Update log-execution-context to be more helpful ###\n(using [fp] (using [fp stateful log_execution_context]\n  (lispz.update! { log_execution_context })\n  (using [promise counters] (export {}))\n))\n"

lispz_modules['counters']="### spec: Basic >> Keeping Count\n###\n(macro delay [ms *body] (setTimeout (=> *body) ms))\n\n(macro yield [*body] (delay 0 *body))\n\n(global counter! (lambda\n  (ref count (stateful {to: 0}))\n  (return (lambda\n    (count.update! \"to\" (+ count.to 1))\n    (return count.to)\n  ))\n))\n(global countdown! (lambda [from by]\n  (ref count (stateful {from}))\n  (return (lambda []\n    (from.update! \"from\" (- count.from by))\n    (return (<= count.from 0))\n  ))\n))\n\n(global wait-for (promise [test max-ms]\n  (ref timed-out (countdown! (or max-ms 5000) 10))\n  (ref waiter (lambda []\n    (cond\n      (test)      (resolve-promise)\n      (timed-out) (reject-promise)\n      (else)      (delay 10 (waiter))\n    )\n  )) (waiter)\n))\n\n###\n# Return a random integer between 0 and the range given\n###\n(global random (lambda [range] (return (Math.floor (* (Math.random) range)))))\n\n### spec: Counters >> UUID\n# Generate a fairly unique ID - at least as unique as Math.random can make it.\n###\n(global uuid (=>\n  (\"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace '/[xy]/g' (=>\n    (ref r = (Math.floor (* (Math.random) 16)))\n    ((cond (is @ \"x\") r (else) (| (& r 0x3) 0x8)).toString 16)\n  ))\n))\n(export {})\n"

lispz_modules['dev']="(using [github riot list]\n  (ref manifest (lambda\n    (ref text (stateful [\"CACHE MANIFEST\"]))\n    (lispz.manifest.forEach (lambda [uri] (text.push! uri)))\n    (text.push! \"NETWORK:\" \"*\")\n    (return (text.join \"\\n\"))\n  ))\n  ### Package Lispz for distribution ###\n  (ref package (lambda [repo-name]\n    (when (github.repo> repo-name) [repo] (package-repo repo))\n  ))\n  (ref package-repo (lambda [lispz-repo]\n    (ref read-file (github.read.bind null lispz-repo))\n\n    (ref group (lambda [files]\n      (ref modules (stateful [])) (ref riots (stateful []))\n      (files.forEach (lambda [entry] (cond (is entry.type \"file\") (do\n        (ref parts (entry.name.split \".\"))\n        (cond\n          (is (last parts) \"lispz\")                  (modules.push! (first parts))\n          (is ((slice parts -2).join \".\") \"riot.html\") (riots.push! (first parts))\n        )\n      ))))\n      (promise.resolved { modules riots })\n    ))\n    (ref stringify (=>\n      (return ((@.replace '/[\\\\\"]/g' \"\\\\$&\").replace '/\\n/g' \"\\\\n\"))\n    ))\n    (ref load-module (lambda [name]\n      (ref uri (+ name \".lispz\"))\n      (return (when (read-file uri) [text]\n        (return [[\"\\nlispz_modules['\" name \"']=\\\"\" (stringify text) \"\\\"\\n\"]])\n      ))\n    ))\n    (ref build-modules (lambda [names]\n      (return (promise.all (names.map load-module)))\n    ))\n\n    (ref load-riot (lambda [name]\n      (return (when (read-file (+ name \".riot.html\")) [text]\n        (return [[\"\\n\\n/*\" name \"*/\\n\\nlispz.tags['\" name \"']=\\\"\"\n          (stringify text) \"\\\"\\n\"]])\n      ))\n    ))\n    (ref build-riots (lambda [names]\n      (return (promise.all (names.map load-riot)))\n    ))\n\n    (ref update-mode (github.update lispz-repo))\n    (ref lispz-js    (when update-mode (return (read-file \"lispz.js\"))))\n    (ref listing     (when update-mode (return (github.list-dir lispz-repo \"\"))))\n    (ref groups      (when listing [files] (return (group files))))\n    (ref modules     (when groups  [files] (return (build-modules files.modules))))\n    (ref riots       (when groups  [files] (return (build-riots files.riots))))\n\n    (ref all-loaded  (promise.all modules lispz-js riots))\n\n    (return (when all-loaded [sources]\n      (ref  code  (list.flatten [[\"window.lispz_modules={}\\n\" sources]]))\n      (return (github.write lispz-repo \"ext/lispz.js\"\n        (code.join \"\") \"lispz release code\")\n      )\n    ))\n  ))\n\n  ### Distribution ###\n  (ref distribute (lambda [target-repo]\n    ## @TODO\n  ))\n\n  (export {manifest package distribute})\n)\n"

lispz_modules['dexie']="### spec: Libraries >> Dexie\nDexie.js is a wrapper library for indexedDB - the standard database in the browser.\n\nhttps://github.com/dfahlander/Dexie.js\n###\n(using  [net github]\n\n  (ref build (lambda [target-repo]\n    (return (github.build target-repo \"dexie\" [[\n      {repo: \"dfahlander/Dexie.js\" files: [[\n        {base: \"dist/latest\" include: '/Dexie.js$/'}\n      ]]}\n    ]]))\n  ))\n\n  (lispz.script \"ext/dexie.js\" (lambda (export { build })))\n)\n"

lispz_modules['dict']="### spec: lists >> dict -- The Associative Array List (Dictionary)\n\nAre also called dictionaries or hashmaps. Because lispz is a functional language it is not\nuncommon for functions to return a dictionary of values. To make them clearer, if a key is\nsupplied without a following colon then it is placed into the dictionary with a value of the same name.\n\n    (ref exported-method-1 (lambda [] ...))\n    (ref key \"whatever I want\"}\n    (export {exported-method-1 key error: false date: (new Date))\n\nwill create a JavaScript dictionary of the form\n\n    (ref exporting {exported_method_1: exported_method_1, key: key, error: false, date: (new Date)})\n\naccess with a key is identical to arrays except that it is a key rather than an index.\nIf the key is known, using dot syntax is clearer\n\n    exporting.error\n    (get exporting key)\n###\n\n### spec: lists >> dict >> Internals >> Insert\nDictionary merges and inserts take a list of dictionaries in order to push to the target.\nThis means that when they have common keys, the last dictionary that has the key takes\nprecedence.\n\n    ## command-line options overwrite config options of the same name. If neither is\n    ## found, the default option is used.\n    (dict.merge default-options config-file-options cl-options)\n###\n(ref insert (lambda [target dictionaries]\n  (ref target (stateful target))\n  (dictionaries.forEach (lambda [dictionary]\n    (target.update! dictionary)\n  ))\n  (return target)\n))\n\n### spec: lists >> dict >> Merging Dictionaries\nThere is often need to merge multiple dictionaries together to create a new combined one.\n\n    (ref big-dict (dict.merge dict-1 dict-2 dict-3))\n###\n(ref merge (lambda [dictionaries]\n  (return (insert {} (*arguments 0)))\n))\n\n### spec: lists >> dict >> Inserting One Dictionary in Another\n**Warning** This is not referentially transparent\n\n    (dict.insert! dict-1 dict-2 dict-3)      ## changes dict-1\n###\n(ref insert! (lambda [target dictionaries]\n  (return (insert target (*arguments 0)))\n))\n\n### spec: lists >> dict >> Create a Dictionary from a List\n    (ref list [[{key: 1 value: 2} {key: 3 value: 4}]]\n    (dict.from-list list \"key\")    # {1: {key: 1 value: 2} 3: {key: 3 value: 4})\n###\n(ref from-list (lambda [list key]\n  (ref dictionary (stateful))\n  (cond list (list.forEach (lambda [item] (dictionary.update! item))))\n  (return dictionary)\n))\n\n### spec: lists >> dict >> For Each Entry...\n    (dict.for-each dict-1 (lambda [key value] ...))\n###\n(ref for-each (lambda [dict action=>]\n  ((Object.keys dict).forEach (lambda [k] (action=> k (get dict k))))\n))\n\n### spec: lists >> dict >> Morphing dictionary into an Array\n###\n(ref map (lambda [dict action=>]\n  (return ((Object.keys dict).map (lambda [k] (return (action=> k (get dict k))))))\n))\n\n(ref filter (lambda [dict action=>]\n  (return ((Object.keys dict).filter (lambda [k] (return (action=> k (get dict k))))))\n))\n\n### spec: lists >> dict >> Check a Dictionary for an Entry\n###\n(ref contains (lambda [test against]\n  (return (#join '' '(' test ' in ' against ')'))\n))\n\n(export {merge from-list insert! for-each map filter contains})\n"

lispz_modules['diff_match_patch']="### spec: Libraries >> Diff-Match-Patch\nThis is an unofficial mirror of the JavaScript version of the google-diff-match-patch library.\n\nhttps://github.com/tanaka-de-silva/google-diff-match-patch-js\n###\n(using [net github]\n  (ref build (lambda [target-repo built=>]\n    (return (github.build target-repo \"diff_match_patch\" [[\n      {repo: \"tanaka-de-silva/google-diff-match-patch-js\" files: [[\n        {base: \"\" include: '/^diff_match_patch_uncompressed.js$/'}\n      ]]}\n    ]]))\n  ))\n  (lispz.script \"ext/diff_match_patch.js\" (lambda (export { build })))\n)\n"

lispz_modules['dom']="(using [dict message]\n  (ref append! (lambda [parent element]\n    (ref selector (document.querySelector parent))\n    (selector.appendChild element)\n  ))\n\n  ### spec: DOM >> Replace inner html\n  Given an element, replace the contents with the html provided as a string.\n  ###\n (ref inner-html! (lambda [el html] (#set! el \"innerHTML\" html)))\n\n  ### spec: DOM >> Select Elements\n  This is a shortcut for element.querySelectorAll. It copies the\n  results into an Array of elements for further processing.\n  ###\n  (ref select (lambda [el selector]\n    (return (slice (el.querySelectorAll selector)))\n  ))\n\n  (ref style! (lambda [el styles]\n    (dict.for-each styles(lambda [name value]\n      (#set! el.style name value))\n    ))\n  )\n\n  (ref element (lambda [tag-name attributes]\n    (ref elem (document.createElement tag-name))\n    (dict.for-each (or attributes {}) (lambda [k v] (elem.setAttribute k v)))\n    (return elem)\n  ))\n\n  (ref event-throttle (lambda [element event action]\n    (ref add null)\n    (ref listener (lambda [event]\n      (element.removeEventListener event listener)\n      (delay 66 add)\n      (action event)\n    ))\n    (ref add (lambda [] (element.addEventListener event listener)))\n  ))\n\n  ### spec: DOM >> Forms >> Scraping\n    Given a parent element, return a dictionary\n    of input elements.\n  ###\n  (ref scrape-form (lambda [parent]\n    (ref form (first (select parent \"form\")))\n    form.elements\n  ))\n\n  ### spec: async >> Messaging >> Sources >> (dom.message)\n    Start a message stream from different sources. All curried\n    to create convenient functions.\n\n        (dom.message \"click\" \"my-message-address\" document.body)\n\n    will send messages to address _dom-click/my-message-name/_. For\n    convenience the method returns the full address for mapping and filtering.\n\n    We cache dom event listeners against the address being posted to. that\n    way the dom will not send the message multiple times if the source is\n    reinvoked.\n  ###\n  (ref dom-events (stateful))\n  (ref post-dom-event> (lambda [address]\n    (ref send-to-address (lambda [pkt] (message.send address pkt)))\n    (stateful.cache dom-events (=> send-to-address) address)\n  ))\n  ### ref: (dom.message event-name message-name element)\n    e.g. (ref address (dom.message \"click\" \"monitor\" document.body))\n  ###\n  (ref dom-message (lambda [event-name address-base element]\n    (ref address (message.combine-address (+ \"dom-\" event-name) address-base))\n    (cond (not (get dom-events address))\n      (element.addEventListener event-name (post-dom-event> address))\n    )\n    address\n  ))\n\n  ### ref: (dom.click message-name element)\n    e.g. (dom.click \"monitor\" document.body)\n    messages sent to returned address (**dom-click/monitor**)\n  ###\n  (ref click (lambda [address-base element]\n    (dom-message \"click\" address-base element)\n  ))\n\n  (export {\n    append! element event-throttle style! inner-html!\n    select scrape-form message: dom-message click\n  })\n)\n"

lispz_modules['events']="(ref throttle (lambda [limit callback]\n  (ref context (stateful))\n  (return (=>\n    (cond (not context.wait)\n      (callback)\n      (context.update! {wait: true})\n      (delay limit (context.update! {wait: false}))\n    )\n  ))\n))\n\n(ref delay (lambda [limit callback]\n  (ref context (stateful))\n  (return (=>\n    (clearTimeout context.timeout)\n    (context.update! { timeout: (delay limit (callback)) })\n  ))\n))\n\n(export {throttle delay})\n"

lispz_modules['firebase']="### spec: Libraries >> FireBase\nFirebase can power your app's backend, including data storage, user authentication, static hosting, and more. Focus on creating extraordinary user experiences. We'll take care of the rest.\n\nhttps://www.firebase.com/\n###\n(using  [net]\n  (ref databases (stateful.morph! (JSON.parse (or (localStorage.getItem \"firebases\") \"{}\"))))\n  (ref database-uri (pull databases))\n\n  (ref register (lambda [key uri]\n    (databases.update! key uri)\n    (localStorage.setItem \"firebases\" (JSON.stringify databases))\n  ))\n\n  (ref encode (lambda [before]\n    (ref uri (before.replace '/\\./g' \":\"))\n    (ref uri (uri.replace    '/#/g'  \"_hash_\"))\n    (ref uri (uri.replace    '/\\$/g' \"_dollar_\"))\n    (return uri)\n  ))\n\n  (ref attach (lambda [collection db]\n    (ref uri (database-uri (or db \"default\")))\n    (cond uri (new Firebase (+ uri \"/\" (encode collection))))\n  ))\n\n  (ref loaded (net.script \"https://cdn.firebase.com/js/client/2.2.9/firebase.js\"\n    (lambda (return window.Firebase))\n  ))\n  (when  loaded (export {register attach databases}))\n  ## (promise.failed loaded (export {}))\n)\n"

lispz_modules['firepad']="### spec: Libraries >> FirePad\nCollaborative Text Editor Powered by Firebase.\n\nhttps://github.com/firebase/firepad\n###\n(using  [net github]\n  (ref build (promise [target-repo]\n    (github.grunt target-repo \"firebase/firepad\" [grunt data]\n      (grunt.build {\n        target: \"firepad.js\"\n        pre:   data.concat.firepadjs.options.banner\n        post:  data.concat.firepadjs.options.footer\n        files: data.concat.firepadjs.src\n      } (lambda []\n        (grunt.copy data.copy.toBuild.files built=>)\n      ))\n    )\n  ))\n\n  (lispz.css \"ext/firepad.css\")\n  (ref loaded (net.script \"ext/firepad.js\" (lambda [] (return window.FirePad))))\n  (when loaded (export {build}))\n)\n"

lispz_modules['fp']="### spec: Functional Programming >> curry\n###\n(global curry (lambda [func]\n  (ref curried (=>\n    (ref args (*arguments 0))\n    (cond (>= args.length func.length)\n      (func.apply func args)  ## all done, run it\n    (else)\n      (=> ## otherwise return a partual function\n        (curried.apply this (args.concat (*arguments 0)))\n      )\n    )\n  ))\n))\n(macro curry [params *body] (lispz.globals.curry (lambda params *body)))\n\n### ref: ((compose func1, func2 ...) seed) -- runs left to right\n  e.g. ((compose (=> (+ @ 1)) (=> (+ @ 2))) 3) ==> 6\n###\n(global compose (=>\n  (ref funcs (*arguments 0))\n  (=>\n    (funcs.reduce (lambda [previous current]\n      [[(current.apply this previous)]]\n    ) (*arguments 0))\n  )\n))\n\n### ref: (cascade func1, func2 ...)\n  e.g. (cascade (=> 1) (=> (+ @ 1)) (=> (+ @ 2))) ==> 4\n###\n(global cascade (=>\n  ((lispz.globals.compose.apply null arguments) null)\n))\n\n### spec: Functional Programming >> flip\n  Flip calling order of 2 parameters\n###\n(global flip (curry [fn] (curry [a b] (fn b a))))\n\n### spec: basic >> Retrieval - can be used for objects and arrays\n  Retrieve elements by index for arrays and property for objects.\n\n      (get 1 [3,4,5])\n      ## is 4 the same as\n      (ref second (get 1))\n      (second [3,4,5])\n\n  Included are curries for _first_, _second_ and _third_. For objects, use\n  _in_ to clarify order\n\n      (get \"b\" in {a: 1 b: 2 c: 3})\n\n  or use _pull_ as a curry\n\n      (ref commands {a: 1 b: 2 c: 3})\n      (ref command (pull commands))\n      (command \"b\")\n###\n(global dot    (curry [index array] (#join '' '(_res_=' array '[' index '])')))\n(global pull   (flip lispz.globals.dot))\n(global first  (dot 0))\n(global second (dot 1))\n(global third  (dot 2))\n### spec: Functional Programming >> map\n  Works on functors.\n###\n(global map (lambda [item action] (item.map action)))\n### spec: Functional Programming >> filter\n  Works on functors.\n###\n(global filter (lambda [item action] (item.filter action)))\n### spec: Functional Programming >> map and filter\n  (map-and-filter list (=> list.end))\n###\n(global map-and-filter (compose lispz.globals.filter lispz.globals.map))\n\n(export [])\n"

lispz_modules['github']="### spec: >> GitHub\n  A higher-level wrapper around the Github API. Intended for the browser.\n\n  https://github.com/michael/github\n###\n(using  [net dict list axios base64 utf8]\n  ### spec: GitHub >> CDN\n    It is possible to access GitHub files for direct use in the browser through\n    a CDN. Provide the project name, hash/branch/release and a path to the file.\n  ###\n  (ref cdn-uri (lambda [project hash filepath]\n    (return (+ \"https://cdn.rawgit.com/\" project \"/\" hash \"/\" filepath))\n  ))\n  ### spec: GitHub >> Specifying the Current Repository\n    This is a non-pure function because if this is the first connection to\n    GitHub, a UI modal dialog is displayed for GitHub log-in details.\n  ###\n  (ref repo> (lambda [project]\n    (ref user (or\n      (sessionStorage.getItem \"ghstate\")\n      (localStorage.getItem \"ghstate\")\n    ))\n    (cond user (do\n      (ref up ((atob user).split \"||\"))\n      (promised (connect (first up) (last up) project))\n    ) (else)\n      ((promise (using [bootstrap]\n        (ref modal-path \"github/github-login\")\n        (ref modal (bootstrap.modal modal-path {}))\n        (when modal [resp]\n          (cond (is resp.login.value \"true\") (do\n            (ref user (btoa (+\n              resp.username.value\n              \"||\" resp.password.value\n            )))\n            (cond (is resp.remember.checked)\n              (localStorage.setItem \"ghstate\" user)\n            (else) (do ## user wants amnesia\n              (localStorage.removeItem \"ghstate\")\n              (sessionStorage.setItem \"ghstate\" user)\n            ))\n            (resolve-promise (connect\n              resp.username.value resp.password.value project\n            ))\n          ) (else)\n            (reject-promise {\n              error: true reason: \"User abort\"\n            })\n          )\n        )\n      )))\n    )\n  ))\n  (ref connect (lambda [username password project]\n    (ref auth (new Github {username password auth: \"basic\"}))\n    (ref github (auth.getRepo.apply null (project.split \"/\")))\n    (return (stateful {github auth username password project branch: \"master\"}))\n  ))\n  ## Set the branch to use for repo - defaults to master\n  (ref branch (promise [repo branch-name]\n    (repo.update! {branch: branch-name})\n    (repo.github.branch branch-name (lambda [err result] (resolve-promise)))\n  ))\n  ## list files in a specific path on the repo\n  (ref list-dir (promise.callback [repo path]\n    (repo.github.contents repo.branch path callback)\n  ))\n  (ref list-all (promise [repo path single-level]\n    (ref result (stateful []))\n    (ref list-path (lambda [path]\n      (return (when (list-dir repo path) [paths]\n        (ref children (stateful []))\n        (paths.forEach (lambda [entry]\n          (cond\n            (is \"dir\"  entry.type)\n              (cond (not single-level) (children.push! (list-path entry.path)))\n            (is \"file\" entry.type)\n              (result.push! entry.path)\n          )\n        ))\n        (return (promise.all children))\n      ))\n    ))\n    (when (list-path path) (resolve-promise result))\n  ))\n  (ref read (promise.callback [repo path]\n    (repo.github.read repo.branch path callback)\n  ))\n  (ref update (lambda [repo]\n    (cond\n      (is repo.branch repo.username) (promise.resolved)\n      (else) (do\n        (ref branch-name (or repo.username \"master\"))\n        (branch repo branch-name)\n      )\n    )\n  ))\n  (ref write (promise.callback [repo path contents comment]\n    (cond\n      (not contents.length) (promise.resolved)\n      (else) (do\n        (ref encoded (unescape (encodeURIComponent contents)))\n        (repo.github.write repo.branch path encoded comment callback)\n      )\n    )\n  ))\n  ## preprocess a file to generate css or js dependent on extension\n  (ref preprocessors {\n    lispz: (lambda [name code]\n      (return {path ext: \"js\" code: (window.lispz.compile code name)})\n    )\n  })\n  (ref get-preprocessor (pull preprocessors))\n  (ref preprocess (lambda [path code]\n    (ref ext (last (path.split \".\")))\n    (ref preprocessor (get-preprocessor ext))\n    (cond preprocessor (preprocessor path code)\n                (else) {path ext code})\n  ))\n  ## Build and save a dependency list\n  ## We will need to filter the dependencies\n  (ref filter (lambda [before include exclude]\n    (ref after before)\n    (ref after (cond\n      include (after.filter (lambda [file] (include.test file)))\n      exclude (after.filter (lambda [file] (not (exclude.test file))))\n    ))\n    (return after)\n  ))\n  ## and see which to save and which to copy\n  (ref copy (lambda [copy-to path code]\n    ## not working yet for binary files\n    (ref filename (last (path.split \"/\")))\n    (return {path code copy: (+ copy-to \"/\" filename)})\n  ))\n  ## Load the contents of the files we need from a single repo\n  (ref process-repo (lambda [source-repo files actors]\n    (return (promise.all (files.map (promise [meta]\n      (ref base (or meta.base \"\"))\n      (when (actors.list-all source-repo base meta.single-level) [file-list]\n        (ref files (filter file-list meta.include meta.exclude))\n        (resolve-promise (promise.all (files.map (promise [path]\n          (when (actors.read source-repo path) [code]\n            (cond\n              meta.copy-to (resolve-promise (copy meta.copy-to path code))\n              (else)       (resolve-promise (preprocess path code))\n            )\n          )\n        ))))\n      )\n    ))))\n  ))\n  ## Given a list of repos, go through them all for files in need\n  (ref process-repos (lambda [target-repo sources actors]\n    (return (promise.all (sources.map (lambda [source]\n      (ref source-repo (actors.repo target-repo source.repo))\n      (return (process-repo source-repo source.files actors))\n    ))))\n  ))\n  ## Retrieve file contents based of filtering meta-data\n  (ref retriever (promise [target-repo sources actors]\n    (when (process-repos target-repo sources actors) [entry-tree]\n      (ref first-from [[\"Gathered from: \"]])\n      (ref rest-from (sources.map (lambda [source] (return source.repo))))\n      (ref store {\n        js:     (stateful [])\n        css:    (stateful [])\n        copies: (stateful [])\n        from:   (first-from.concat rest-from)\n      })\n      ((list.flatten entry-tree).forEach (lambda [entry]\n        (ref ext-list (get store entry.ext))\n        (cond\n          (ext-list) (do\n            (ext-list.push! \"\\n\\n/* \" entry.path \" */\\n\" entry.code)\n          )\n          store.copy\n            (store.copies.push! entry)\n        )\n      ))\n      (resolve-promise store)\n    )\n  ))\n  ## Given a file type, save the concatenated source contents\n  (ref save-store (promise [target-repo store name ext comment]\n    (ref contents ((get store ext).join \"\"))\n    (return (write target-repo (+ \"ext/\" name \".\" ext) contents comment))\n  ))\n  ## copy files identified as needed as-is\n  (ref copy-store (lambda [target-repo store comment]\n    (return (promise.all (store.copies.map (lambda [entry]\n      (return (write target-repo entry.path entry.code comment))\n    ))))\n  ))\n  ## Now we have gathered needed resources, build and save the output file\n  (ref builder (promise [actors target-repo name sources]\n    (when (retriever target-repo sources actors) [store]\n      (ref comment (store.from.join \" \"))\n      (ref saved (when (update target-repo)\n        (return (promise.all\n          (save-store target-repo store name \"js\"  comment)\n          (save-store target-repo store name \"css\" comment)\n          (copy-store target-repo store            comment)\n        ))\n      ))\n      (when saved (resolve-promise))\n    )\n  ))\n  (ref github-actors {\n    list-all read\n    repo: (lambda [target-repo name]\n      (return (repo target-repo.username\n        target-repo.password name\n      ))\n    )\n  })\n  (ref build (builder.bind null github-actors))\n  ## Use gruntfile to decide which files to include and it what order\n  (ref grunt-build (promise [meta]\n    (ref js (stateful [(or meta.pre \"\")]))\n    (ref read-all (promise.all (meta.files.map (promise\n      (when (github-actors.read source-repo path) [data]\n        (js.push! data) (resolve-promise)\n      )\n    ))))\n    (when read-all\n      (js.push! (or meta.post \"\"))\n      (ref contents (js.join \"\\n\"))\n      (when (write target-repo (+ \"ext/\" meta.target) contents comment)\n        (resolve-promise)\n      )\n    )\n  ))\n  (ref grunt-copy (promise [files]\n    (ref copy-all (promise.all (files.map (promise [item]\n      (ref path (or item.src item))\n      (when (github-actors.read source-repo path) [contents]\n        (ref path (+ \"ext/\" (last (path.split \"/\"))))\n        (when (write target-repo path contents comment)  (resolve-promise))\n      )\n    ))))\n  ))\n  (ref grunt (promise [target-repo source-project]\n    (ref source-repo (github-actors.repo target-repo source-project))\n    (ref comment (+ \"from \" source-project))\n    (ref sources [[\n      {repo: source-project files: [[\n        {include: '/^Gruntfile.js$/' single-level: true}\n      ]]}\n    ]])\n    (when (retriever target-repo sources actors) [store]\n      (ref grunt-config ((Function\n        (+ \"var module={};\" (last store.js) \"return module.exports\"))))\n      (grunt-config {\n        loadNpmTasks: (lambda) registerTask: (lambda)\n        initConfig: (lambda [config-data]\n          (ref grunt-processor {\n            build: grunt-build\n            copy:  grunt-copy\n          })\n          (when (update target-repo)\n            (resolve-promise grunt-processor config-data)\n          )\n        )\n      })\n    )\n  ))\n  (ref build-github (lambda [target-repo]\n    (ref sources [[\n      {repo: \"michael/github\" files: [[\n        {include: \"/src/github.js$/\"}\n      ]]}\n    ]])\n    (return (build target-repo \"github\" sources))\n  ))\n  (ref loaded (net.script \"ext/github.js\" (lambda (return window.Github))))\n  ## (promise.failed loaded (export {build}))\n  (when loaded\n    (export {\n      branch list-all list-dir cdn-uri build builder repo> read write update\n      build-github retriever grunt preprocessors\n      move: (promise.callback [repo from to]\n        (repo.github.move repo.branch from to callback)\n      )\n      delete: (promise.callback [repo path]\n        (repo.github.remove repo.branch path script callback)\n      )\n    })\n  )\n)\n"

lispz_modules['index']="### spec: Introduction ###\n### spec: basics -- The Basics ###\n### spec: lists -- List Processing ###\n### spec: Macros ###\n### spec: Modules ###\n### spec: async -- Asynchronous Programming ###\n### spec: riot -- UI Components with RIOT ###\n### spec: bootstrap -- Bootstrap Integration ###\n### spec: codemirror -- CodeMirror Integration ###\n### spec: developer -- Developer Tools ###\n### spec: Deployment ###\n### spec:  ###\n\n### spec: Introduction\n# Why another *&^% language?\n**For Fun:**\nIt is fun to create something new - even when you are following paths well trodden by others for decades.\nBy making your own decisions and learning from them you get a better understanding of the how and why of\nother languages.\n\n**Extensibility:**\nFew languages macros integrated in the language - where macros are expressed in the language itself.\nThere is no difference between built-ins, libraries and code created by the end-user.\n\n**Simplicity:**\nMany languages and frameworks are overloaded with features - generating a huge learning curve.\n\n# Overcoming the fear of change\nLispz has different expression ordering, lots of parentheses and function programming overtones.\nIf you have a fear of change and, like me, had decades of OO and Imperative software development\nthen Lispz looks strange, behaves strangely and requires a diffent way of thinking.\n\nAnd yet, Lispz is only a thin veneer over JavaScript.\n\n    Javascript: console.log(\"message:\", msg)\n    Lispz:      (console.log \"message:\" msg)\n    \nIf you move the parenthenis pairs around and replace brace with parenthesis then the\nsurface similarities become more obvious.\n\nThe first major difference is not what has been added, but what has been taken away.\nLisp(z) has a lot less syntax. Only\n\n    (fn params)\n    [list]\n    {dict}\n    \nform the core syntax. Everything else is either a function or a macro.\nWe won't talk more about macros yet - in case parenoia sets in.\n\n# The benefits of lisp\nHaving only parenthesis, bracket or brace to deal with reduces ambiguity - when used\nwith appropriate white-space. In many cases the functional style can be clearer:\n\n    (or value default1 default2 12)\n    (+ a b 12)\n\nalthough not always\n\n    (/ (* value percent) 100)\n  \nWhile our practiced eye finds this harder to understand than \"a * percent / 100\" it\nis easier to decipher. Take the 'standard' syntax. Are these the same:\n\n    value * percent / 100\n    (value * percent) / 100\n  \nYou win if you said 'no'. In most languages operator precedence is such that the first\nsample will do the divice before the multiply. With real numbers the change in order can\ncause a diffent result. For languages without auto-conversion, the first will return zero\n(assuming percent is less than 100). With auto-conversion and all integers, the first will\ncause two floating point operations while the second only one.\n\nBack to\n\n    (/ (* value percent) 100)\n  \nWith the understanding that everthing appears to be a function, it becomes easier to read\nand there are no ambiguities. The word 'appears' is intentional as Lispz expands binaries in-line,\nsuch that the code run is\n\n    ((value * percent) / 100)\n\n# Where functional programming comes in\nShhh! Don't tell the Haskellers. JavaScript is already a functional language in that it\nprovides functions as first-class operation, closures and bindings. There are other aspects\nthat it does not support - the major ones being immutability and static types. I think of\nJavaScript as a modern assember, making it the responsibility of the higher (:)\nlevel language to fill in the gaps.\n\nLispz is too lightweight to do anything about static types.\n\nImmutability is a moving target. For a functional language, this means if a function is\ncalled with the same parameters it will always return the same result. Another definition\nstates \"no side-effects\". A third suggest it means all data on the stack - meaning function\ncall parameters. In the extreme it means that there are no variables, only constants -\ndata once allocated never changes.\n\nLispz takes a pragmatic approach leaving it up to the developer. It keeps the JavaScript\nconcept of a 'var' - leaving it easy to change within the same function and accessible as\nan immutable variable to inner functions. Because immutability is such a hard task master\nin an imperative world (such as the dom), Lisp does incude a set! operator.\nUnlike assignment, set! is painful enough to remind the developer to limit it's use.\nPutting a bang after any exported function that includes mutability provides a good hint to\nrule-breaking. It is up to the developer to ensure than any function exported from a module\nhonours the immutability and repeatability rules - and to flag the method when this is not possible.\n###\n\n(export {}) ## in case it gets included in another module\n"

lispz_modules['jquery']="### Libraries >> jQuery\nNew Wave JavaScript\n\nhttps://github.com/jquery/jquery\n###\n(using [net cdnjs]\n  (ref build (lambda [target-repo]\n    (return (cdnjs.build target-repo \"jquery\" [[\n      {repo: \"jquery\" files: [[\n        {exclude: '/\\.map$|\\.min.js$/'}\n      ]]}\n    ]]))\n  ))\n  (ref loaded (net.script \"ext/jquery.js\" (lambda (return window.jQuery))))\n  (when  loaded (export {build}))\n  (promise.failed loaded (export {build}))\n)\n"

lispz_modules['js_beautify']="### spec: Libraries >> JS-Beautify\nBeautifier for JavaScript\n\nhttp://jsbeautifier.org/\nhttps://github.com/beautify-web/js-beautify\n###\n(using [net github]\n  (ref build (lambda [target-repo built=>]\n    (return (github.build target-repo \"js_beautify\" [[\n      {repo: \"beautify-web/js-beautify\" files: [[\n        {base: \"js/lib\" include: '/^beautify.js$/'}\n      ]]}\n    ]]))\n  ))\n  (ref loaded (net.script \"ext/js-beautify.js\" (lambda []\n    (return window.js_beautify))\n  ))\n  (when loaded [] (export {build}))\n)\n"

lispz_modules['list']="### spec: lists >> flatten - Flattening Lists of Lists\n###\n(ref flatten (lambda [list]\n  (list.reduce (lambda [a b]\n    (ref bflat (cond (instance-of Array b) (flatten b) (else) b))\n    (return (a.concat bflat))\n  ) [[]])\n))\n\n### spec Lists >> squash\n  It is a common pattern to return a value or a list of more than one value is\n  expected.\n###\n(ref squash (=> (cond (is @.length 1) (get @ 1) (else) @)))\n\n### spec: lists >> for-each\n  This is a helper for the JavaScript [].forEach(). It has the advantage that\n  it behaves correctly if the item is not an array by running once for the entry\n  if it is not a falsy.\n###\n(ref for-each (lambda [list action]\n  (cond (not list)               null\n        (instance-of Array list) (list.forEach action)\n        (else)                   (action list)\n  )\n))\n\n### spec: List and dictionary manipulation ###\n(macro length [list] (#join '' list '.length'))\n(macro rest [list] (list .slice 1))\n(macro last [list] (first (list .slice -1)))\n(global slice (lambda [list from to]  (return (lispz.slice.call list from to))))\n\n### spec: lists >> contains\n###\n(ref contains (lambda [substr str] (return (isnt -1 (str .indexOf substr)))))\n\n### spec: lists >> sort\n###\n(ref reverse (lambda [list]\n  (return ((slice list).reverse))\n))\n\n(export {flatten squash for-each contains reverse})\n"

lispz_modules['log_execution_context']="(using [list]\n  ### spec: basic >> Execution Context\n  ###\n  (macro execution-context [context *body]\n    (lispz.execution-context.push context)\n    *body (ref _ecres_ _res_)\n    (lispz.execution-context.pop)\n    (ref _res_ _ecres_)\n  )\n  ### spec: basic >> Execution Context >> Adding Loggers\n  ###\n  (global add-execution-context-logger (lambda [name logger]\n    (cond lispz.execution-context.loggers\n      (lispz.execution-context.loggers.update! name logger)\n    )\n  ))\n\n  (ref loc  (=> (return (+ @.name \":\" @.line))))\n  (ref loc2 (=> (return (+ (loc @.location) \" from \" (loc @.previous)))))\n  (ref src  (lambda [source around]\n    (ref lines (source.split \"\\n\"))\n    (ref bounds (cond\n      around {\n          start: (Math.max 0 (- around 3))\n            end: (Math.min lines.length (+ around 3))\n        }\n      (else) { start: 0  end: lines.length }\n    ))\n    (ref lines ((lines.slice bounds.start bounds.end).map (lambda [line idx]\n      (return (+ \"\\t\" (+ idx bounds.start 1) \" >>>\\t\" line))\n    )))\n    (return (+ \"\\n\" (lines.join \"\\n\")))\n  ))\n  (ref json (=>\n    (ref lines ((JSON.stringify @ null 2).split \"\\n\"))\n    (return (lines.join \"\\n    \"))\n  ))\n\n  (ref loggers (stateful {\n    load:    (=> (return @.uri))\n    module:  (=> (return (+ @.uri \" - \" @.state)))\n    compile: (=> (return (+ (loc2 @) (src @.source @.location.line))))\n    other:   (=> (return (json @)))\n  }))\n  (ref logger-for (pull loggers))\n  \n  (ref format-context (=>\n    (ref name (+ @ \": \"))\n    (ref spaces (- 16 name.length))\n    (cond (< spaces 1)  name\n          (else)        (+ \"    \" name (  \"                \".slice 0 spaces))\n    )\n  ))\n  (ref logger (lambda [execution-context args]\n    (ref context (list.reverse execution-context))\n    (lispz.log \"Context:\" context) ## to JavaScript console just in case...\n    (console.log (first args) \"\\nContext:\")\n    (context.forEach (lambda [item]\n      (ref logger (or (logger-for item.context) loggers.other))\n      (console.log (+ (format-context item.context) (logger item)))\n    ))\n  ))\n  (stateful.morph! logger) (logger.update! {loggers})\n  (export logger)\n)\n"

lispz_modules['macros']="### spec: macros >> What is a Macro?\n\nThe term \"macro\" includes text substitution (e.g. ASM and C) and syntactic macros. Lisp has had the latter proposed 1963 or soon after. By working on the abstract syntax tree (AST), a macro has the full faculties and syntax of the language to effectively extend the language. Another way of looking at it is that lisp macros run lisp code during the compile to modify the resulting program. Yes, I know this is still not clear. Read https://en.wikipedia.org/wiki/Macro_%28computer_science%29 for a more informative perspective.\n\ncreates a new language element that only returns if the value is a truthy, as in\n\n    (ref result ....)\n    (return? result)\n    ## try something else\n\nThis example would also work with a text substitution macro system, but this one doesn't:\n\n    (macro closure [params *body] (#join '' '(lambda(' params '){' *body '})(' params ')'))\n\nThis generates the JavaScript output directly as #join is an immediate function called during the\nast to JavaScript phase.\n\n### spec: macros >> Defining a Macro\n\nA macro is defined by giving it a name, list of parameters and a body. In it's simplest form the parameters are substituted into the body at reference time. It is like a function expanded in-line.\n\nImmediate actions are required to modify the JavaScript output during the compile stage (ast to JavaScript).\n\n    (macro function [params *body] (#join '' '(lambda(' params '){' *body '})'))\n\nParameters that start with star must be the last in the list and encapsulate all the remaining parameters in the expansion. This is why function works:\n\n    (lambda [a b] (ref c (+ a b)) (return c))\n\n### spec: macros >> #join\nMany macros translate lispz directly to JavaScript by mixing pure JavaScript with macro parameters that can convert themselves to JavaScript. It is an immediate function - being one that runs during the compile phase. The first parameter is the text to be used between the segments. In this context it is usually empty. The first parameter along with the JavaScript are wrapped in single quotes so that they are left as-is in the JavaScript output.\n\n    (macro set! [name value] (#join '' name '=' value ';'))\n\n### spec: macros >> #pairs\nPairs is more rarely used. It takes a list and creates output based on pairs in that list. Hmmm, that is not very clear. Best use an example then.\n\n    (macro var (*list) (#join '' 'var ' (#pairs *list '=' ',') ';'))\n    (ref a 12  b \"hi\") ##js=> var a=12,b=\"hi\";\n\nPairs takes a list, the code within each pair and the string between pairs. In this example, = is between the two items in the pair and , is between pairs. If you need it clearer than that, try meditating on the two sample lines above - or don't use #pairs.\n\n### spec: macros >> immediate\n\nMacros allow you to change lispz by adding new build-in commands. By their nature, macros allow the use of lispz at compile time to generate the resulting lispz code. Most macros are to generate JavaScipt\n\n    (macro return [value] (#join '' 'return ' value '\\n'))\n\nDouble-check substitution macros. The one above must be a macro, but may could be easily converted into global functions\n\n    (macro empty? [list] (not list.length))\n    # is functionally the same as\n    (global empty? [list] (return (not list.length)))\n\nThe built-ins #join and #pairs are example of immediate functions - ones that operate during the compile phase. Lispz would not be complete if you could not also create immediate functions.\n\n    (immediate 'alert(\"Hi\")')\n\nWorks but has no point. I added immediate for language completeness. I have not yet found a use for it.\n\n    (global #join2 (lambda [sep parts]\n      (immediate (*arguments 1) '.map(lispz.ast_to_js).join(lispz.ast_to_js(sep)')\n    ))\n\n\n(export {})\n"

lispz_modules['markdown']="### spec: Libraries >> Showdown\nA Markdown to HTML converter written in JavaScript\n\nhttp://showdownjs.github.io/demo/\nhttps://github.com/showdownjs/showdown\n###\n(using [net cdnjs dict]\n  (ref build (lambda [target-repo]\n    (return (cdnjs.build target-repo \"showdown\" [[\n      {repo: \"showdown\" files: [[\n        {include: '/showdown.js$/'}\n      ]]}\n    ]]))\n  ))\n  (ref default-options {\n    ## (boolean) Omit the trailing newline in a code block.\n    omitExtraWLInCodeBlocks: false\n    ## (boolean) Disable the automatic generation of header ids.\n    noHeaderId: false\n    ## (string/boolean) Add a prefix to the generated header ids.\n    prefixHeaderId: false\n    ## (boolean) Enable support for setting image dimensions.\n    parseImgDimensions: false ## ![foo](foo.jpg =100x80) -- *, px, %, em\n    ## (integer) Set the header starting level.\n    headerLevelStart: 2\n    ## (boolean) Enable GFM autolink style.\n    simplifiedAutoLink: true\n    ## (boolean) Stop interpreting underscores in the middle of words\n    literalMidWordUnderscores: false\n    ## (boolean) Enable support for strikethrough syntax (~~strike~~)\n    strikethrough: true\n    ## (boolean) Enable support for tables syntax.\n    tables: true\n    ## (boolean) Adds an id property to table headers tags.\n    tablesHeaderId: true\n    ## (boolean) Enable support for GFM code block style.\n    ghCodeBlocks: true\n    ## (boolean) Enable support for GFM takslists.\n    tasklists: true\n    ## (boolean) Prevents weird effects in live previews due to incomplete input\n    smoothLivePreview: false\n  })\n\n  (ref compile (lambda [markdown options]\n    (ref options (dict.merge (or options {}) default-options))\n    (ref converter (new showdown.Converter options))\n    (ref html (converter.makeHtml markdown))\n    (return html)\n  ))\n\n  (ref loaded (net.script \"ext/showdown.js\" (lambda (return window.showdown))))\n\n  (when  loaded (export {build compile}))\n  (promise.failed loaded (export {build}))\n)\n"

lispz_modules['message']="### spec: async >> Messaging\n###\n(using [list dict]\n  (ref exchange  (stateful))\n  (ref observers (stateful.cache exchange (=> (stateful []))))\n\n  ### spec: async >> Messaging >> (clear)\n    Clear all observers from a message box.\n  ###\n  (ref clear (lambda [matcher]\n    (cond (instance-of RegExp matcher)  (clear-by-regexp matcher)\n          (else)                        (clear-by-name   matcher)\n    )\n  ))\n  (ref clear-by-regexp (lambda [matcher]\n    (ref matches (dict.filter exchange (=> (matcher.test @))))\n    (list.for-each matches (=> (clear-by-name @)))\n  ))\n  (ref clear-by-name (lambda [name]\n    (exchange.update! name (stateful []))\n  ))\n\n  ### spec: async >> Messaging >> Sources >> (request>)\n    Send a message directly to an address so that it is picked up by\n    all observers. Call returns a promise\n    that is fulfulled when all listeners have responded. The promise\n    returns an array of results for each listener.\n\n        (ref requested (message.request> \"examples/my-address\"\n          { msg: \"whatsit\" read-now: true }\n        ))\n        (when requested [results context] ...)\n\n    For in-process addresses, the observers are expected to be well behaved.\n    They should (yield) the CPU rather that take too much time.\n  ###\n  (ref request> (lambda [address packet]\n    (ref postman (lambda [obs] (promised (obs.action> packet obs))))\n    (promise.all ((observers address).map postman))\n  ))\n\n  ### spec: async >> Messaging >> Sources >> (send)\n    Send a message directly to an address so that it is picked up by\n    all observers. Unlike _request>_, _send_\n    does not expect the receivers to respond.\n  ###\n  (ref send (lambda [address packet]\n    (ref postman (lambda [obs] (yield (obs.action> packet obs))))\n    ((observers address).map postman)\n  ))\n\n  ### spec: async >> Messaging >> (ready>)\n    If a _post>_ can happen before a listener is set - and it is important\n    that the _post>_ is heard, wrap it in a _ready>_.\n  ###\n  (ref ready> (promise [address]\n    (ref ready-check (=>\n      (ref listeners = (observers address))\n      (cond listeners.length\n        (resolve-promise)\n      (else)\n        (delay 100 ready-check)\n      )\n    ))\n  ))\n\n  ### spec: async >> Messaging >> Sources >> (observe)\n    Observe the passage of a message. An action is called with the packet\n    and a reference to the observer object as stateful local context.\n    The action can return a promise and preferably not do anything too\n    time-costly in-process.\n  ###\n  (ref listen (lambda [address action>]\n    ((observers address).push! (stateful { action> }))\n  ))\n\n  ### spec: async >> Messaging >> Sources >> (dispatch)\n    Dispatch is a specialised version of observe where a number of actions\n    can be defined and messages built to dispatch to them.\n\n        (ref open  (=> ...))\n        (ref close (=> ...))\n        (message.dispatch \"my-component\" { open close })\n\n    Each action creates a separate message-box using the given address followed\n    by the action name. In this example, _my-component/open_ and _my-component/close_.\n  ###\n  (ref dispatch (lambda [address actions]\n    (dict.for-each actions (lambda [name action>]\n      (message.listen (+ address \"/\" name) action>)\n    ))\n  ))\n\n  ### spec: async >> Messaging >> Sources >> (combine-address)\n    Mapping and filtering messages are given source and target\n    addresses. If the target address starts with a / it is used\n    alone, otherwise the source and target addresses are concatenated.\n\n        (combine-address \"left\" \"right\")  ## left/right\n        (combine-address \"left\" \"/right\") ## right\n  ###\n  (ref combine-address (lambda [from to]\n    (cond\n      (is (first to) \"/\")   (slice to 1)\n      (else)                (+ from \"/\" to)\n    )\n  ))\n\n  ### ref: (from.update! {source: (lambda [address ...])})\n      e.g. (from.update! {callback: (lambda [address] ...)})\n      then use as (message.from.callback \"my-address\")\n  ###\n  (ref from (stateful {\n    promise: (lambda [address a-promise]\n      (when a-promise [packet] message.send (*arguments 0))\n    )\n  }))\n\n  ### spec: async >> Messaging >> Modifiers >> (map)\n    Map message streams to change the results\n        (ref @click (message.from.click \"my-message-address\" document.body))\n        (ref @mouse (message.map @click \"mouse\" (lambda [event]\n          {x: event.clientX  y: event.clientY}\n        )))\n        (message.listen @mouse (=> (console.log @.x @.y)))\n  ###\n  ### ref: (message.map from to mapper)\n    e.g. (message.map @click \"mouse\" (=> {x: @.clientX y: clientY}))\n    will send messages to (+ @click \"/mouse\") - use \"/to\" for abs address\n  ###\n  (ref message-map (lambda [from to mapper]\n    (ref address (combine-address from to))\n    (message.listen from (=> (message.send address (mapper @))))\n    address\n  ))\n\n  ### spec: async >> Messaging >> Modifiers >> (filter)\n    Map message streams to change the results\n        (ref @click (message.from.click \"my-message-address\" document.body))\n        (ref @mouse (message.map @click \"mouse\" (lambda [event]\n          {x: event.clientX  y: event.clientY}\n        )))\n        (ref @top-left (message.filter @mouse \"top-left\" (lambda [pos]\n          (< pos.x pos.y)\n        )))\n        (message.listen @top-left (=> (console.log @.x @.y)))\n  ###\n  ### ref: (message.filter from to filterer)\n    e.g. (message.filter @mouse \"top-left\" (=> (< @.x @.y)))\n    will send messages to (+ @mouse \"/top-left\") - use \"/to\" for abs address\n  ###\n  (ref message-filter (lambda [from to filterer]\n    (ref address (combine-address from to))\n    (message.listen from (=> (cond (filterer @) (message.send address @))))\n    address\n  ))\n\n  ### ref: (message.throttle address milliseconds)\n    e.g. (message.throttle @mouse 100) sends (+ @mouse \"/100ms\")\n    will only pass messages every 100ms or more apart to\n  ###\n  (ref throttle (lambda [from ms]\n    (ref address (+ from \"/\" ms \"ms\"))\n    (message.listen from (lambda [packet context]\n      (ref now (new Date))\n      (ref elapsed (- now (or context.last-message-time 0)))\n      (cond (> elapsed ms) (do\n        (context.update! { last-message-time: now })\n        (message.send address packet)\n      ))\n    ))\n    address\n  ))\n\n  ### spec: async >> Messaging >> Sources >> (trace)\n    Turning tracing on will display messages posted and received to\n    the browser console. Use a regular expression to reduce the number\n    of messages to a manageable amount. A parameter of false will turn\n    trace off again.\n  ###\n\n  (ref with-tracing (lambda [name action filterRE has-packet]\n    (lambda [address packet]\n      (cond (filterRE.test address)\n        (console.trace name \"\\t\" address (cond has-packet packet (else) \"\"))\n      )\n      (action address packet)\n    )\n  ))\n\n  (ref set-trace (lambda [filterRE]\n    (message.update! {\n      send:     (with-tracing \"SEND    \"  send      filterRE true)\n      request>: (with-tracing \"REQUEST \"  request>  filterRE true)\n      listen:   (with-tracing \"LISTEN  \"  listen    filterRE false)\n    })\n  ))\n\n  (ref trace (=>\n    (cond\n      (is @ false)    (message.update! { send request> listen })\n      (not @)         (set-trace '/.*/')\n      (else)          (set-trace @)\n    )\n  ))\n\n  (ref message (stateful {\n    send listen dispatch request> clear trace from ready>\n    map: message-map filter: message-filter combine-address\n    exchange throttle\n  }))\n  (lispz.update! {message})\n  (export message)\n)\n"

lispz_modules['net']="(using [list dom regex]\n  (ref script (promise.callback [uri check max-ms] (lispz.script uri (lambda []\n    (cond check (do\n      (ref initialised (wait-for check max-ms))\n      (when  initialised [] (callback))\n      (promise.failed initialised [] (debug (+ uri \"didn't load\")))\n    ) (else) (return (callback))\n    )\n  ))))\n\n  (ref css (lambda [uri]\n    (ref el (dom.element \"link\" {\n      type: \"text/css\" rel: \"stylesheet\" href: uri\n    }))\n    (dom.append! \"head\" el)\n  ))\n\n  (ref http-get (promise.callback [uri]\n    (lispz.http_request uri \"GET\" callback)\n  ))\n\n  (ref json-request (promise [uri]\n    (when (http-get uri) [response] (resolve-promise (JSON.parse response)))\n  ))\n\n  ### spec: Network >> Is URL external\n  ###\n  (ref external? (lambda [url] (return (list.contains \"://\" url))))\n\n  ### spec: Network >> Retrieve the last element in a URL path\n  ###\n  (ref url-path (lambda [href]\n    (return (regex.substring href '/(.*\\/)[^\\/]*$/'))\n  ))\n\n    ### spec: Network >> Retrieve the last element in a URL path\n    ###\n    (ref url-actor (lambda [href]\n      (return (regex.substring href '/.*\\/([^\\/]*)(?:\\?.*)?$/'))\n    ))\n\n  (export {\n    script css http-get json-request external? url-actor url-path\n  })\n)\n"

lispz_modules['paredit']="### codeeditor >> codemirror >> ParEdit\n###\n    (ref extraKeys {\n      ## paredit keys that defer if not in lisp code\n      'Backspace':        \"subpar_backward_delete\"\n      'Delete':           \"subpar_forward_delete\"\n      'Ctrl-D':           \"subpar_forward_delete\"\n\n      'Shift-9':          \"subpar_open_bracket\"\n      '[':                \"subpar_open_square_bracket\"\n      'Shift-[':          \"subpar_open_braces\"\n\n      'Shift-0':          \"subpar_close_bracket\"\n      ']':                \"subpar_close_square_bracket\"\n      'Shift-]':          \"subpar_close_braces\"\n\n      'Shift-\\'':          \"subpar_double_quote\"\n\n      'Ctrl-Alt-F':       \"subpar_forward\"\n      'Ctrl-Alt-B':       \"subpar_backward\"\n      'Ctrl-Alt-U':       \"subpar_backward_up\"\n      'Ctrl-Alt-D':       \"subpar_forward_down\"\n      'Ctrl-Alt-P':       \"subpar_backward_down\"\n      'Ctrl-Alt-N':       \"subpar_forward_up\"\n\n      'Shift-Ctrl-[':     \"subpar_backward_barf\"\n      'Ctrl-Alt-Right':   \"subpar_backward_barf\"\n      'Ctrl-]':           \"subpar_backward_barf\"\n\n      'Shift-Ctrl-]':     \"subpar_forward_barf\"\n      'Ctrl-Left':        \"subpar_forward_barf\"\n\n      'Shift-Ctrl-9':     \"subpar_backward_slurp\"\n      'Ctrl-Alt-Left':    \"subpar_backward_slurp\"\n      'Ctrl-[':           \"subpar_backward_slurp\"\n\n      'Shift-Ctrl-0':     \"subpar_forward_slurp\"\n      'Ctrl-Right':       \"subpar_forward_slurp\"\n\n      'Alt-Up':           \"subpar_splice_delete_backward\"\n      'Alt-Down':         \"subpar_splice_delete_forward\"\n      'Alt-S':            \"subpar_splice\"\n      'Ctrl-Alt-/':       \"subpar_indent_selection\"\n    })\n\n  ## paredit keys that defer if not in lisp code\n  (ref lisp-modes {lispz: true clojure: true commonlisp: true scheme: true})\n  (ref is-lisp-mode (pull lisp-modes))\n  (ref subpar-command (pull subpar.core))\n  (ref subpart (lambda [cmd opt]\n    (return (lambda [cm]\n      (ref mode (cm.getModeAt (cm.getCursor)))\n      (cond (is-lisp-mode mode.name)  ((subpar-command cmd) cm opt)\n            (else)                    CodeMirror.Pass\n      )\n    ))\n  ))\n  (ref code-mirror-commands (state.morph CodeMirror.commands))\n  (code-mirror-commands.update! {\n    ## paredit keys that defer if not in lisp code\n    subpar_backward_delete:        (subpart \"backward_delete\")\n    subpar_forward_delete:         (subpart \"forward_delete\")\n    subpar_forward_delete:         (subpart \"forward_delete\")\n\n    subpar_open_bracket:           (subpart \"open_expression\" \"()\")\n    subpar_open_square_bracket:    (subpart \"open_expression\" \"[]\")\n    subpar_open_braces:            (subpart \"open_expression\" \"{}\")\n\n    subpar_close_bracket:          (subpart \"close_expression\" \")\")\n    subpar_close_square_bracket:   (subpart \"close_expression\" \"]\")\n    subpar_close_braces:           (subpart \"close_expression\" \"}\")\n\n    subpar_double_quote:           (subpart \"double_quote\")\n\n    subpar_forward:                (subpart \"forward\")\n    subpar_backward:               (subpart \"backward\")\n    subpar_backward_up:            (subpart \"backward_up\")\n    subpar_forward_down:           (subpart \"forward_down\")\n    subpar_backward_down:          (subpart \"backward_down\")\n    subpar_forward_up:             (subpart \"forward_up\")\n\n    subpar_backward_barf:          (subpart \"backward_barf\")\n    subpar_backward_barf:          (subpart \"backward_barf\")\n    subpar_backward_barf:          (subpart \"backward_barf\")\n\n    subpar_forward_barf:           (subpart \"forward_barf\")\n    subpar_forward_barf:           (subpart \"forward_barf\")\n\n    subpar_backward_slurp:         (subpart \"backward_slurp\")\n    subpar_backward_slurp:         (subpart \"backward_slurp\")\n    subpar_backward_slurp:         (subpart \"backward_slurp\")\n\n    subpar_forward_slurp:          (subpart \"forward_slurp\")\n    subpar_forward_slurp:          (subpart \"forward_slurp\")\n\n    subpar_splice_delete_backward: (subpart \"splice_delete_backward\")\n    subpar_splice_delete_forward:  (subpart \"splice_delete_forward\")\n    subpar_splice:                 (subpart \"splice\")\n    subpar_indent_selection:       (subpart \"indent_selection\")\n  })\n"

lispz_modules['projects']="(using [github dexie]\n  ### spec: Projects\n    Empiric can work on one project at a time. A project is a reflection of\n    a Github project - warts and all. A best effort is made to keep the local\n    copy and that on Github in sync.\n  ###\n  (ref db (new Dexie \"Empiric-Projects\"))\n  ((db.version 1).stores {\n    projects: \"&name\"\n    files: \"++,project,path\"\n  })\n  (db.open)\n\n  ### spec: Projects >> Open a Project\n    Once a project has been added to the system on this browser, it can be\n    opened by name. Returned is an object with the cached project meta-data\n    and a reference for accessing the GitHub repository.\n      (describe \"Open a project that does not exist\" (lambda []\n        (ref project (projects.open \"I don't exist\"))\n      ))\n      (describe \"Open an existing project\" (lambda []\n        (ref project (projects.open \"Empiric\"))\n      ))\n  ###\n  (ref open (lambda [name]\n    (return (when (db.projects.get name) [data]\n      (ref repo (github.repo data.username data.password data.project-name))\n      (return {meta-data: data repo})\n    ))\n  ))\n\n  ### spec: Projects >> Add or Update a Project\n    It is possible to change some of the meta-data associated with a project.\n    Most specifically this includes the necessaries to contact the GitHub\n    source of truth for this project.\n  ###\n  (ref add (lambda [name username password project-name]\n    (ref project (db.projects.get name))\n    (ref update! (lambda [data]\n      (ref data (stateful.morph data))\n      (data.update! username password project-name)\n      (return (db.projects.put data))\n    ))\n    (when  project [data] (update! data))\n    (promise.failed project [err] (update! {name}))\n  ))\n\n  ### spec: Projects >> List Known Projects\n    Return a promise that when fulfilled will provide an array of project\n    meta-data. It returns a promise.\n\n        (describe \"List Projects\" (lambda []\n          (it \"will return a list of known projects\" (lambda []\n            (when (projects.list) [list] (lambda []\n              ((expect list.length).toBeGreaterThan 0)\n            ))\n          ))\n        ))\n  ###\n  (ref list (lambda [] (return (db.projects.toArray))))\n\n  (export open)\n)\n"

lispz_modules['promise']="(global #prepare-promise (lambda\n  (ref callbacks (stateful {ok: (lambda) fail: (lambda)}))\n  (ref pledge (stateful.morph!\n    (new Promise (lambda [ok fail] (callbacks.update! {ok fail})))\n  ))\n  (ref resolve (lambda (callbacks.ok.apply null (*arguments 0))))\n  (ref reject (lambda [err] (callbacks.fail err)))\n  (return { pledge resolve reject })\n))\n(global #action-promise (lambda [context promise-body]\n  (context.pledge.update! \"execution_context\" lispz.execution-context)\n  (#join '' 'try{' (promise-body context.resolve context.reject) '}catch(err){'\n    (lispz.log-execution-context context.pledge.execution-context [[\"own-promise\"]])\n    (lispz.log-execution-context lispz.execution-context [[\"in-promise\"]])\n    (context.reject err) '}'\n  )\n  (return context.pledge)\n))\n(global #deferred-promise (lambda [promise-body]\n  (ref context (#prepare-promise))\n  (context.pledge.update! {deferred: (lambda\n    (return (#action-promise context promise-body))\n  )})\n  (return context.pledge)\n))\n(global promise {})\n\n(macro promise [?params *body] (lambda ?params\n  (return (#action-promise (#prepare-promise)\n    (lambda [resolve-promise reject-promise] *body)\n  ))\n))\n(macro promise.deferred [*body]\n  (return #deferred-promise (lambda [resolve-promise reject-promise] *body))\n)\n(macro promise.callback [?params *body] (promise ?params\n  (ref callback (lambda [err result]\n    (cond err    (reject-promise err)\n          (else) (resolve-promise result)\n    )\n  ))\n  *body\n))\n(global promise.resolved (promise [pact] (resolve-promise pact)))\n\n(global promised (lambda [pledge]\n  (cond (and pledge pledge.then) pledge\n        (else)                   (promise.resolved pledge)\n  )\n))\n\n(global #resolve-deferred (lambda [pledge]\n  (cond pledge.deferred (do\n    (ref deferred pledge.deferred)\n    (delete pledge.deferred)\n    (deferred)\n  ))\n  (return pledge)\n))\n\n(macro when [pledge ?params *body]\n  ((#resolve-deferred pledge).then (lambda ?params *body))\n)\n(macro promise.failed [pledge ?errors *body]\n  ((#resolve-deferred pledge).catch (lambda ?errors *body))\n)\n\n(using [list]\n  ### Promises >> promise.all\n    Given a list of promises and constant data, will return a list of\n    returned data when all the promises have been resolved.\n  ###\n  (global promise.all (=>\n    (ref flattened (list.flatten (*arguments 0)))\n    (ref promisified (flattened.map (=> (promised @))))\n    (return (Promise.all promisified))\n  ))\n)\n(global promise.chain (lambda []\n  (ref chain-link (lambda [input functions]\n    (cond (not functions.length) (promised input)\n    (else) (do\n      (ref pledge (promised ((first functions) input)))\n      (when pledge [output] (chain-link output (rest functions)))\n    ))\n  ))\n  (chain-link null (*arguments 0))\n))\n\n(export [])\n"

lispz_modules['regex']="\n### spec: regex >> Extracting a substring\nA common problem is finding part of a string given a pattern.\n\n    (regex.substring href '/(.*)\\/[^\\/]*$/') ## retrieve base part of url\n###\n(ref substring (lambda [str re]\n  (ref match (str.match re))\n  (cond match  (second match) (else) \" \")\n))\n\n(export {substring})\n"

lispz_modules['riot']="### spec: Libraries >> RIOT\nA React-like, user interface library\n\n[Lispz RIOT Support](riot.spec.lispz)\nhttp://riotjs.com/\nhttps://github.com/riot/riot\n###\n### spec: Riot\n\n[Riot](http://riotjs.com) is a tiny UI library then provides the best of Web components (polymer) and react in a package 15% of the size.\n\nRiot, like web components, each file (of type .riot.html) is a html fragment that also includes style and script elements. Like web components it is based on creating custom tags. This provides clean and readable HTML. Custom tags makes the HTML more readable.\n\nThe *panel* tags is a Riot wrapper around bootstrap panels.\n\nRiot, like React it works with a virtual DOM and only updates changes to the real DOM. Like React it compiles to JavaScript. It can be supported on older browsers.\n\nSmall tight API that provides all needed web component functionality for reactive views, events and routing.\n###\n\n### spec: Riot >> Structure of a RIOT/Lispz Program\n\nRiot components have the extension *.riot.html*. They are loaded from the HTML file or from another component. In the HTML, give a custom tag the class or *riot* and it will load a component file of the same name - including any other tags in the file. The html below will load *bootstrap.riot.html* and *code-editor.riot.html*, while *page-content* does not need a riot class as it is defined withing *bootstrap*.\n\n    <bootstrap class=riot>\n      <page-content fluid=true>\n        <div class=col-sm-6>\n          <code-editor class=riot name=literate height=48% />\n        </div>\n        <div class=col-sm-6>\n          <code-editor class=riot name=code height=48% />\n        </div>\n      </page-content>\n    </bootstrap>\n\nRiot uses plain JavaScript inside {} as a templating solution. The *opts* dictionary matches the attributes when the custom tag is referenced. Any inner tag with a *name* or *id* attribute can be referenced by the same name. Each component has a unique *_id*.\n\nStyles are global (unlike *true* web components). This is easily overcome using explicit name-spacing as above.\n###\n\n### spec: Riot >> Using other languages\n\nScripting can be any language of choice that runs on the browser. JavaScript, Lispz, Es6 (with babel) and CoffeeScript are available out-of-the-box. For the latter two you will need to load the compiler by *(using babel coffeescript)* in the startup code. Other languages can be added as long as they compile code on the browser.\n\n    (set! riot.parsers.js.lispz\n      (lambda [source] (return ((lispz.compile source \"riot-tags\").join \"\\n\")))\n    )\n###\n(using  [jquery net github dict dom]\n  ## we need to update the tags cache\n  (stateful.morph! lispz.tags)\n  ### spec: RIOT >> Get Tag Definition by Name\n  ###\n  (ref tag-by-name (pull lispz.tags))\n\n  ## has side-effects as riot caches compile results\n  (ref compile (lambda [html to-js] (riot.compile html to-js)))\n\n  (ref processed-tags (stateful {}))\n  (ref processed-tag  (pull processed-tags))\n\n  (add-execution-context-logger \"riot.load\" (lambda [context error-args]\n    (return (+ \"tag\" context.name \" from \" context.uri))\n  ))\n  (ref child-tags (lambda [html]\n    (ref raw-tags (html.match '/<[^>\\s]+[^>]*?class=[\\'\\\"]riot[\\s\\'\\\"]/g'))\n    (return ((or raw-tags [[]]).map (=> (return (last ('/^<(\\S*)/'.exec @))))))\n  ))\n  ### spec: RIOT >> load\n    Returns true if tag has been previously loaded. This\n    allows the caller to decided whether to reuse or\n    reinstate.\n  ###\n  (ref load (promise [name uri] (execution-context {context: \"riot.load\" name uri}\n    (ref usings (lambda [tags]\n      (ref new-tags (tags.filter (=>\n        (cond @.length (do\n          (ref processed (processed-tag @))\n          (processed-tags.update! @ true)\n          (return (not processed)))\n        (else)\n          false\n        )\n      )))\n      (ref loaded (promise.all (new-tags.map (=>\n        (return (load @))\n      ))))\n      (when loaded (resolve-promise))\n    ))\n\n    (ref compile-and-process (=>\n      (usings (child-tags (compile @)))\n    ))\n\n    (ref retrieve-and-compile (lambda\n      (ref url\n        (or uri (+ (name.toLowerCase) \".riot.html\"))\n      )\n      (when (net.http-get url) [tag-html]\n        (lispz.tags.update! name tag-html)\n        (compile-and-process tag-html)\n      )\n    )))\n\n    (ref tag-def (tag-by-name name))\n    (cond\n      tag-def   (compile-and-process tag-def)\n      (else)    (retrieve-and-compile)\n    )\n  ))\n\n  (ref build (lambda [target-repo]\n    (return (github.build target-repo \"riot\" [[\n      {repo: \"riot/riot\" files: [[\n        {include: '/^riot\\+compiler.js$/'}\n      ]]}\n    ]]))\n  ))\n  ### spec: RIOT >> mount\n  ###\n  (ref mount (=> (riot.mount.apply riot arguments)))\n\n  ### spec: RIOT >> inject\n    Load a named tag if needed, inject an instance into the DOM then mount it.\n    The name can be the name of the file followed by the specific element.\n  ###\n  (ref inject (promise [name-path attributes parent-selector]\n    (ref parts (name-path.split \"/\"))\n    (ref name  (last parts))\n    (ref file (first parts))\n    (ref exists (tag-by-name name))\n    (when (load name (+ file \".riot.html\"))\n      (cond exists (do\n        (ref tags (riot.mount name))\n        (resolve-promise (first tags))\n      ) (else) (do\n        (ref element (dom.element name attributes))\n        (ref parent (or parent-selector \"body\"))\n        (dom.append! parent element)\n        (ref tags (riot.mount element name))\n        (resolve-promise (first tags))\n      ))\n    )\n  ))\n\n  ### spec: riot >> Trigger Display Changes\n    Given a component context called *tag*, it is possible to change context\n    data using the state component.\n\n      <script type=text/lispz>\n        (ref tag (stateful.morph this))\n        ...\n        (ref async-set-title (lambda [title]\n          (tag.update! {title})\n          (tag.update)\n        )\n      </script>\n\n    For the confused, *update!* changes entries in the stateful context,\n    while *update* is a riot function to update the display for bound\n    data changes. Continue to use this approach where the data has logic\n    around the change, but for the common situation where data is changed\n    at the end of the logic, use *riot.update!*.\n\n      (using [riot]\n        ...\n        (ref async-set-titles (lambda [title footer]\n          (riot.update! tag {title footer})\n        )\n      )\n  ###\n  (ref update! (lambda [tag changes]\n    (tag.update! changes)\n    (tag.update) ## repaint\n  ))\n\n  ### spec: riot >> Tag support\n    Riot uses _this_ as context for codes within a tag. Also, when errors are\n    found it throws excepts that are difficult to track. Lispz provides help\n    with a riot-tag macro which invokes _using_,  provides a _tag_ reference\n    and wraps the code in a _try/catch_ to provide improved error reporting.\n\n      @TODO example\n  ###\n  (add-execution-context-logger \"riot\" (lambda [context error-args]\n    (return (+ \"for <\" context.node \"/>\"))\n  ))\n  (macro riot-tag [*body]\n    (ref tag (stateful.morph! this))\n    (execution-context {context: \"riot\" node: tag.root.nodeName tag}\n      *body\n    )\n  )\n  ## modules must be on mount or mounting will happen before trigger is set\n  (macro mount-tag-using [modules *body] (tag.on \"mount\" (=> (using modules\n    (execution-context {context: \"riot\" node: tag.root.nodeName tag}\n      *body\n    )\n  ))))\n\n  ### spec: async >> Events\n    Events follow [the observer pattern](https://en.wikipedia.org/wiki/Observer_pattern). Lispz provides access to the light-weight version in Riot. If you use Riot for UI components, the custom tags are always observers. You don't need to use riot to make use of events. You can either create an observable or make any object in the system observable.\n\n        (using [riot]\n          (ref observable-1 (riot.observable))\n          (ref element (get-my-element))\n          (riot.observable element)\n        )\n\n    Once that is out of the way, tell the observable what to do if it receives an event either once or every time.\n\n        (observable-1.on \"event-name\" (lambda [params...] what to do...))\n        (element.one \"focus\" (lambda [contents] (element.set contents)))\n\n    One observable can have many listeners for the same or different events. Use 'trigger' to wake an observable.\n\n        (observable-1.trigger \"event-name\" param1 param2)\n\n    Finally there needs to be a way to stop listening.\n\n        (observable-1.off \"event-name\" event-function-reference) ## stops one listener\n        (observable-1.off \"event-name\") ## stops all listeners to an event\n        (observable-1.off \"*\")          ## stops all listeners to all events for observable\n\n    ## Benefits\n    1. Decouples the code to whatever extent is necessary.\n    2. Associates code and data (such as the DOM).\n    3. Allows multiple invocations\n\n    ## Disadvantages\n    1. Too convoluted to use as an easy replacement for callbacks\n    2. One-way communication\n    3. No way of knowing if event was processed as expected.\n  ###\n\n  (ref   loaded (net.script \"ext/riot.js\" (lambda (return window.riot))))\n  (promise.failed loaded (export {build}))\n  (when  loaded (using [compilers]\n    (stateful.morph! riot.parsers.js)\n    (add-execution-context-logger \"riot.compile\" (lambda [context error-args]\n      (return (+ context.url \" -- source: \" context.source))\n    ))\n    (riot.parsers.js.update! {lispz:\n      (lambda [source options url]\n        (execution-context { context: \"riot.compile\" url options source }\n          (ref js (compilers.lispz.compile source \"riot-tags\"))\n          (compilers.to-string js)\n        )\n      )\n    })\n    (ref riot-elements (slice (document.getElementsByClassName \"riot\")))\n    (ref load-all (promise.all (riot-elements.map (lambda [element]\n      (ref name (element.tagName.toLowerCase))\n      (return (load name (element.getAttribute \"uri\")))\n    ))))\n    (when load-all\n      (riot.mount \"*\")\n      (export {build compile load mount inject update! child-tags tag-by-name})\n    )\n  ))\n)\n"

lispz_modules['sortable']="### spec: Libraries >> Sortable\nSortable â is a minimalist JavaScript library for reorderable drag-and-drop lists on modern browsers and touch devices. No jQuery. Supports Meteor, AngularJS, React, Polymer and any CSS library, e.g. Bootstrap\n\nhttps://github.com/RubaXa/Sortable\n###\n(using [net cdnjs dict]\n\n  (ref sortable-defaults {\n    dataIdAttr: name\n    store: {\n      get: (lambda [sortable]\n        (ref items (localStorage.getItem sortable.options.group))\n        (return ((or items \"\").split \"|\"))\n      )\n      set: (lambda [sortable]\n        (localStorage.setItem sortable.options.group ((sortable.toArray).join \"|\"))\n      )\n    }\n  })\n  ### spec: DOM >> Sortable Components\n  ###\n  (ref create (lambda [container name options]\n    (return (Sortable.create container\n      (dict.merge  sortable-defaults {group: (or name (Math.random))} options)\n    ))\n  ))\n\n  (ref build (lambda [target-repo]\n    (return (cdnjs.build target-repo \"sortable\" [[\n      {repo: \"sortable\" files: [[{include '/Sortable.js/'}]]}\n    ]]))\n  ))\n  (ref loaded (net.script \"ext/sortable.js\" (lambda [] (return window.Sortable))))\n  (when  loaded [] (export {build create}))\n  (promise.failed loaded [] (export {build}))\n)\n"

lispz_modules['stateful']="### spec: basic >> state -- Stateful Containers\n  State is the elephant in the room - particularly in the functional programming paradigm.\n  When you have state that can be changed from outside, then any function that reads from it\n  no longer has referential integrity. This means that identical calls may not return identical\n  results.\n\n  But we need state. Without it the system is fully enclosed without input or output.\n  A referentially integrous :) function can be replaced by it's return value,\n  so why ever run it?\n\n  The aim is to be like any machine with the internals always working the same.\n  Think of a clock. The input is someone setting the time.\n  After that the external gearing, etc is meant to work consistently so that the\n  time advances at the correct pace. The current time is state. You can build and\n  test the entire device without the state. It is on the very outside. Once the\n  mechanism is working as expected, add a clock face and hands. Changing the hands\n  is input and displaying the time output. The latter can be considered a\n  side-effect.\n\n  The state container for lispz relies on polite access, not enforced rules. By custom an\n  function that changes ends in an exclamation mark. Use this to highlight review.\n  The default builder return an empty JavaScript dictionary.\n\n      (describe \"Create a new stateful object -- (ref context (stateful seed))\" (lambda []\n        (ref options (stateful {name: \"undefined\" address: \"nowhere\"}))\n        (it \"is able to read members directly -- context.member\" (lambda []\n          ((expect options.name).toBeEqual \"undefined\")\n        ))\n        (it \"is able to read members by key -- context[key]\" (lambda []\n          ((expect options[\"name\"]).toBeEqual \"undefined\")\n        ))\n        (it (+ \"is able to update a dictionary with changes -- \"\n          \"(context.update! {a: dictionary})\") (lambda []\n            (options.update! {name: \"Barney Rubble\" address: \"Next Door\"})\n            ((expect options.name).toBeEqual \"Barney Rubble\")\n            ((expect options.address).toBeEqual \"Next Door\")\n        )\n          )\n      ))\n\n  Javascript lives in the world of objects as well as functions. Sometimes to work in this world\n  objects need to be labelled as stateful. Use this approach as sparingly as possible. Always\n  consider other alternatives first.\n\n      (describe \"Creating a stateful reference -- (ref context (stateful.morph! this))\" (lambda []\n        (ref that {a: 1 b: 2})\n        (ref context (stateful.morph! that))\n        (it \"looks the same as the original object\" (lambda []\n          ((expect context.a).toBeEqual that.a)\n        ))\n        (it \"reflects changes to the original object\" (lambda []\n          (context.update! {a: 99})\n          ((expect that.a).toBeEqual 99)\n        ))\n      ))\n\n  Be polite and use this container responsibly. Adding protection adds overhead.\n  If you want to cheat, then on your head be it.\n###\n\n(macro #set! [list index value] (#join '' list '[' index ']=' value ';'))\n\n(ref #morph! (lambda [obj]\n  (cond\n    obj.update!               obj ## already morphed\n    (instance-of Array obj)   (#morph-array!  obj)\n    (instance-of Object obj)  (#morph-object! obj)\n    (else)                    (#morph-object! { data: obj })\n  )\n))\n(ref #morph-object! (lambda [obj]\n  (Object.defineProperties obj {\n\n    update!: {value: (lambda [update value]\n      (ref context this)\n      (cond (is arguments.length 1)\n        ((Object.keys update).forEach (lambda [key]\n          (#set! context key (get update key))\n        ))\n      (else)\n        (#set! context update value)\n      )\n      context\n    )}\n\n    delete!: { value: (lambda [to-delete] (delete (get this to-delete))) }\n  })\n  obj\n))\n\n(ref #morph-array! (lambda [array]\n  (Object.defineProperties array {\n    update!:  { value: (lambda [index value] (#set! this index value)) }\n    push!:    { value: (=> (Array.prototype.push.apply this (*arguments 0))) }\n    pop!:     { value: (=> (Array.prototype.pop.apply this)) }\n  })\n  array\n))\n\n(global stateful (lambda [seed]\n  (ref item (cond\n    (instance-of Array seed)    (#morph-array!  (seed.slice))\n    (instance-of Object seed)   ((#morph-object! {}).update! seed)\n    (else)                      (#morph-object! (or seed {}))\n  ))\n))\n\n(global stateful.cache (curry [store update key]\n  (or (get store key) (do (store.update! key (update)) (get store key)))\n))\n\n(global stateful.morph! #morph!)\n\n### We sometimes need to change Lispz functionality ###\n(stateful.morph! lispz)\n\n(export [])\n"

lispz_modules['storage']="(using [dexie]\n  (export {})\n)\n"

lispz_modules['underscore']="### spec: Libraries >> Underscore\nJavaScript's utility _ belt\n\nhttp://underscorejs.org\nhttps://github.com/jashkenas/underscore\n###\n(using [net github]\n  (ref build (lambda [target-repo]\n    (ref sources [[{repo: \"jashkenas/underscore\" files:\n      [[{include: '/underscore.js$/'}]]}]])\n    (return (build target-repo \"underscore\" sources))\n  ))\n  (ref loaded (net.script \"ext/underscore.js\" (lambda (return window._))))\n  (when loaded (export { build }))\n)\n"

lispz_modules['utf8']="### spec: Libraries >> Utf8\nA robust UTF-8 encoder/decoder in JavaScript.\n\nhttps://git.io/utf8js\nhttps://github.com/mathiasbynens/utf8.js\n###\n  (ref build (lambda [target-repo]\n    (using  [net github]\n      (return (github.build target-repo \"utf8\" [[\n        {repo: \"utf8/utf8\" files: [[\n          {base: \"\" include: '/utf8.js$/'}\n        ]]}\n      ]]))\n    )\n  ))\n\n  (lispz.script \"ext/utf8.js\" (lambda (export { build })))\n"

lispz_modules['while']="### spec: basics >> Iteration\n\nIn the functional way of programming, loop style iteration is (almost) never needed.\nBecause of the 'almost' and to provide for those week on functional will,\nlispz provides one loop operator. It takes a test and a body.\n\n    (while (not (result)) (look-again))\n\nIn this case both are functions. Lispz furthers the functional cause by making\nassignment difficult and ugly.\n\nOf course the need for iteration remains no matter what programming discipline you follow.\nIn the functional world it is filled by ... you guessed it ... functions.\nFor arrays, JavaScript provides an excellent set documented in [List Processing](list-processing.md).\n###\n## Javascript does not (yet) have tail recursion - it is scheduled for 2016\n(macro while [test *body] (#join '' 'while(' test '){' *body '}'))\n"
var lispz = function() {
  if (!window.lispz_modules) window.lispz_modules = {}
  var logger = window.console.log,
  log = function() { logger.apply(console, arguments) },
  log_execution_context = function() { lispz.log(arguments) },
  execution_contexts = {}, execution_context = [], references = [{}],
  delims = "(){}[],n".split(''), // characters that are not space separated atoms
  not_delims = delims.join("\\"), delims = delims.join('|\\'),
  stringRE =
    "''|'[\\s\\S]*?[^\\\\]':?|" +
    '""|"(?:.|\\r*\\n)*?[^\\\\]"|' +
    '###+(?:.|\\r*\\n)*?###+|' + '##\\s+.*?\\r*\\n|',
  tkre = new RegExp('(' + stringRE + '\\' + delims + "|[^\\s" + not_delims + "]+)", 'g'),
  opens = new Set("({["), closes = new Set(")}]"), ast_to_js, slice = [].slice,
  location = {line:0, name:"boot"}, globals = {}, load_index = 0,
  synonyms = {and:'&&', or:'||', is:'===', isnt:'!=='}, javascript = "",
  jsify = function(atom) {
    if (/^'\/(?:.|\n)*'$/.test(atom)) return atom.slice(1, -1).replace(/\n/g, '\\n')
    if (/^'.*'$/.test(atom)) return atom.slice(1, -1).replace(/\\n/g, '\n')
    if (/^"(?:.|\r*\n)*"$/.test(atom)) return atom.replace(/\r*\n/g, '\\n')
    switch (atom[0]) {
      case '-': return atom // unary minus or negative number
      default:  return atom.replace(/\W/g, function(c) {
        var t = "$hpalcewqgutkri"["!#%&+:;<=>?@\\^~".indexOf(c)];
        return t ? ("_"+t+"_") : (c === "-") ? "_" : c })
    }
  },
  drop_line_number = function(ast) {
    return (ast instanceof Array && ast[0] === "\n") ? ast.slice(3) : ast
  },
  call_to_js = function(func, params) {
    params = slice.call(arguments, 1)
    if (synonyms[func]) func = synonyms[func]
    if (macros[func]) return macros[func].apply(lispz, params)
    func = ast_to_js(func)
    if (params[0] && params[0][0] === '.') func += ast_to_js(params.shift())
    params = map_ast_to_js(params, ',').replace(/,\s*\./, ".")
    if (func.startsWith("function(){")) {
      func = "(" + func + ")"
    }
    var js = "_res_=" + func +
      ((params === "arguments") ? ".apply(this,arguments)" : ('(' + params + ')'))
    return "(" + js + ")"
  },
  function_to_js = function(params, body) {
    params = drop_line_number(params)
    // functions can be created without a parameter list
    if (params instanceof Array && params[0] == "[") {
      body = slice.call(arguments, 1)
    } else {
      body = slice.call(arguments, 0)
      params = ["["]  // empty parameter list for macro
    }
    function_body_to_js = function() {
      if (body.length === 0) return ""
      var full_body = (body.length === 1 && body[0] instanceof Array) ? body[0] : body
      var end = full_body.length - 1
      if (!(full_body[end] instanceof Array)  &&  full_body[end][0] != ".") {
        full_body[end] = ["(","ref","_res_",full_body[end]]
      }
      body = map_ast_to_js(body, ";\n") + "\n;return _res_"
    }

    var header = "_res_=function("+params.slice(1).map(jsify).join(",")+")"
    var vars = vars_to_js(function_body_to_js)
    return header + "{\n"+vars+"\n"+body+"\n}\n"
  },
  vars_to_js = function(map_to_js) {
    var reference = {}
    references.push(reference)
    try {
      map_to_js()
      var vars = Object.keys(reference)
      if (!reference._res_) vars.push("_res_")
      return "var "+vars.join(",")+";"
    } finally { references.pop() }
  },
  add_reference = function(ast) {
    references[references.length - 1][jsify(ast)] = true
    return []
  },
  add_return = function(ast) {
    if (!ast.length) return ast
    var func = (ast[0] !== "\n") ? 0 : 3 // skip line numbering
    if (ast[func] instanceof Array || ast[func] === "list" || ast[func] === "") {
      var end = ast.length - 1
      ast[end] = add_return(ast[end])
    } else if (ast[func] === "(") {
      if (ast[func + 1] !== "return") {
        ast = ["(", "return", ast]
      }
    } else if (! (ast instanceof Array)) {
      ast = ["(", "return", ast]
    } else {
      throw "no return set for " + JSON.stringify(ast)
    }
    return ast
  },
  return_to_js = function() {
    var js = map_ast_to_js(slice.call(arguments), '\n')
    if (!js.startsWith("return")) js = ";return " + js
    return js
  },
  macro_to_js = function(name, pnames, body) {
    pnames = drop_line_number(pnames)
    if (pnames instanceof Array && pnames[0] == "[") {
      body = slice.call(arguments, 2)
      pnames = pnames.slice(1)
    } else {
      body = slice.call(arguments, 1)
      pnames = []  // empty parameter list for macro
    }
    var pnames_set = new Set(pnames)
    macros[name] = function(pvalues) {
      pvalues = drop_line_number(slice.call(arguments))
      var args = {}
      for (var n = 0, v = 0; n < pnames.length; n++, v++) {
        var pname = pnames[n]
        if (pname[0] == '?' && v == pvalues.length - 1) args[pname] = "", v-- // skip ?param
        else args[pname] =
          (pname[0] === '*') ? ["list"].concat(pvalues.slice(v)) :
          (pname[0] === '&') ? ["["].concat(pvalues.slice(v)) : pvalues[v]
      }
      var expand = function(ast) {
        return (ast instanceof Array) ? ast.map(expand) : args[ast] ||
          (pnames_set.has(ast) ? "" : ast)
      }
      var js = ast_to_js(expand((body.length > 1) ? ["list"].concat(body) : body[0]))
      return js
    }
    return "/*macro "+name+"*/"
  },
  array_to_js = function() {
    var its = slice.call(arguments)
    if (arguments.length === 1 && arguments[0][0] === '[') {
      return "(_res_=[" + map_ast_to_js(its, ',') + "])"
    }
    return map_ast_to_js(its, ',')
  },
  list_to_js = function(its) {
    return (its && its.length) ? map_ast_to_js(slice.call(arguments), ';\n') : ""
  },
  // A dictionary can be a symbol table or k-value pair
  dict_to_js = function(kvp) {
    var dict = []; kvp = slice.call(arguments)
    for (var key, i = 0, l = kvp.length; i < l; i++) {
      if ((key = kvp[i])[kvp[i].length - 1] === ":") {
        dict.push("'"+jsify(key.slice(0, -1))+"':"+ast_to_js(kvp[++i]));
      } else {
        dict.push("'"+jsify(key)+"':"+ast_to_js(key));
      }
    }
    return "(_res_={" + dict.join(',') + "})";
  },
  join_to_js = function(sep, parts) {
    parts = slice.call((arguments.length > 2) ? arguments : parts, 1)
    return map_ast_to_js(parts, ast_to_js(sep))
  },
  run_ast = function(ast) {
    var context = { context:"run", location: location }
    execution_context.push(context)
    var results = ast.map(function(code) {
      return eval(context.code = ast_to_js( code))
    })
    execution_context.pop()
    return results
  },
  immediate_to_js = function() {
    execution_context.push({ context: "immediate", args: arguments })
    var lspz = run_ast(slice.call(arguments)).join("\n")
    var js = ast_to_js(parse_to_ast(lspz))
    execution_context.pop()
    return js
  },
  immediate_from_ast = function() {
    execution_context.push({ context: "#ast", args: arguments })
    var js = ast_to_js(ast_to_ast.apply(this, arguments))
    execution_context.pop()
    return js
  },
  ast_to_ast = function(func, args) {
    execution_context.push({ context: "#ast", args: arguments })
    args = slice.call(arguments, 1)
    var actor = lispz[func] ? lispz[func] : lispz.globals[func]
    if (! actor) throw { message: "No immediate function", name: func}
    var ast = actor.apply(lispz, args)
    execution_context.pop()
    return ast
  },
  // processing pairs of list elements
  pairs_to_js = function(pairs, tween, sep) {
    var el = [], tween = ast_to_js(tween);
    if (!(pairs.length % 2)) throw {message:"Unmatched pairs",pairs:pairs}
    for (var i = 1, l = pairs.length; i < l; i += 2) {
      var second = pairs[i + 1]
      el.push(ast_to_js(pairs[i]) + tween + ast_to_js(second))
    }
    return el.join(ast_to_js(sep))
  },
  binop_to_js = function(op) {
    macros[op] = function(list) {
      return '(_res_=' + map_ast_to_js(slice.call(arguments), op) + ')'
    }
  },
  /*
   * When there was a new-line in the source, we inject it into the prior non-atom
   * if possible. Now we are generating JavaScript we find and process it. This is
   * because comments can't have their own atom or they will screw up argument lists.
   */
  eol_to_js = function(name, number) {
    location = {name:name, line:number}
    var ast = slice.call(arguments, 2)
    while (ast[0] === "\n") ast = slice.call(ast, 3)
    var line = ast_to_js(ast)
    if (ast[0] !== "["&& line.length > 1 && line[line.length - 1] != "\n") {
        line += "//#" + name + ":" + number + "\n"
      }
    return line
  },
  parsers = [
    [/^(\(|\{|\[)$/, function(env) {
      env.stack.push(env.node)
      env.node = [env.atom]
    }],
    [/^(\)|\}|\])$/, function(env) {
      var f = env.node;
      (env.node = env.stack.pop()).push(f)
    }],
    /*
     * Record line number for JS comment. Can't add a new element,
     * so only do it if last compiled is not an atom.
     */
    [/^\n$/, function(env) {
      if (!env.node.length) return
      var atom = env.node[env.node.length - 1]
      if (!(atom instanceof Array)) return
      atom.unshift('\n', location.name, location.line)
    }]
  ],
  empty_words = { "of": true, ",": true, "in": true },
  comment = function(atom) {
    return atom[0] === "#" && atom[1] === "#" && (atom[2] === '#' || atom[2] == ' ')
  },
  parse_to_ast = function(source) {
    var env = { ast: [], stack: [] }
    env.node = env.ast
    tkre.lastIndex = 0
    while ((env.atom = tkre.exec(source.toString())) && (env.atom = env.atom[1])) {
      location.line += (env.atom.match(/\n/g) || []).length
      var is_parser = function(parser) {
        if (!parser[0].test(env.atom)) return false
        parser[1](env)
        return true
      }
      if (!comment(env.atom) && !parsers.some(is_parser) && !empty_words[env.atom]) {
        env.node.push(env.atom);
      }
    }
    if (env.stack.length != 0) {
      throw "missing close brace"
    }
    return env.ast
  },
  ast_to_js = function(ast) {
    return (ast instanceof Array) ? macros[ast[0]] ?
      macros[ast[0]].apply(this, ast.slice(1)) : list_to_js(ast) : jsify(ast)
  },
  map_ast_to_js = function(ast, joiner) {
    return ast.map(ast_to_js).filter(function(item){return item.length}).join(joiner)
  },
  compile = function(source, name) {
    var body = compile_to_ast(source, name)
    var vars = vars_to_js(function(){ body = body.map(ast_to_js) })
    body.unshift(vars)
    return body
  },
  compile_to_ast = function(source, name) {
    var last_module = location
    location = { name:name || "", line:0 }
    var context = {
      context: "compile",
      location: location,
      previous: last_module,
      source:   source
    }
    execution_context.push(context)
    var ast = parse_to_ast(source)
    location = last_module
    execution_context.pop()
    return ast
  },
  run = function(name, source) { return run_ast(compile_to_ast(source, name)) }
  //######################### Script Loader ####################################//
  cache = {}, manifest = [], pending_module = {},
  http_request = function(uri, type, callback) {
    var req = new XMLHttpRequest()
    req.open(type, uri, true)
    if (lispz.debug_mode && uri.indexOf(":") == -1)
      req.setRequestHeader("Cache-Control", "no-cache")
    req.onerror = function(err) {
      callback(uri+": "+err)
    }
    req.onload = function() {
      manifest.push(req.responseURL)
      if (req.status === 200) callback(null, req.responseText)
      else                    req.onerror(req.statusText)
    }
    req.send()
  },
  module_init = function(uri) {
    var state = { context: "module", uri: uri, state: "compiling Lispz" }
    execution_context.push(state)
    var js = compile(lispz_modules[uri], uri).join(';\n') +
      "//# sourceURL=" + uri + ".lispz\n"
    state.state = "compiling JavaScript"
    init_func = new Function('__module_ready__', js)
    state.state = "initialising"
    init_func(function(exports) {
      cache[uri.split('/').pop()] = cache[uri] = exports
      var on_readies = pending_module[uri]
      delete pending_module[uri]
      on_readies.forEach(function(call_module) {call_module(exports)})
      execution_context.pop()
    })
  },
  load_one = function(uri, on_ready) {
    if (cache[uri]) return on_ready()
    if (pending_module[uri]) return pending_module[uri].push(on_ready)
    pending_module[uri] = [on_ready]; var js = ""
    if (lispz_modules[uri]) return module_init(uri)
    execution_context.push({ context: "load", uri: uri })
    http_request(uri + ".lispz", 'GET', function(err, response_text) {
      if (err) throw err
      var name = uri.split('/').pop()
      lispz_modules[uri] = response_text
      execution_context.pop()
      module_init(uri)
    })
  },
  // Special to set variables loaded with requires
  requires_to_js = function(list) {
    list = list.slice(list.indexOf("[") + 1)
    return 'var ' + list.map(function(module) {
      var name = module.trim().split('/').pop()
      return jsify(name) + '=lispz.cache["' + name + '"]'
    }) + ';'
  },
  load = function(uris, on_all_ready) {
    uris = uris.split(",")
    var next_uri = function() {
      if (uris.length) load_one(uris.shift().trim(), next_uri)
      else if (on_all_ready) on_all_ready()
    }
    next_uri()
  },
  set_debug_mode = function(debugging) {
    lispz.debug_mode = debugging
  },
  //##################    where to get scripts    #############################//
  lispz_url = document.querySelector('script[src*="lispz.js"]').getAttribute('src'),
  lispz_base_path = /^(.*?)(?:ext\/)?lispz.js/.exec(lispz_url)[1] || "./",
  css = function(uri) {
    el = document.createElement("link")
    el.setAttribute("type", "text/css")
    el.setAttribute("rel", "stylesheet")
    el.setAttribute("href",  lispz_base_path+uri)
    document.head.appendChild(el)
  },
  script = function(uri, when_loaded) {
    if (cache[uri]) return when_loaded()
    cache[uri] = true
    el = document.createElement("script")
    document.head.appendChild(el)
    el.addEventListener("load",  function(evt) { setTimeout(when_loaded, 20) })
    el.addEventListener("error", function(evt) { console.log(evt); when_loaded(evt) })
    el.setAttribute("src", lispz_base_path+uri)
  }
  window.onerror = function(msg, url, line, column, error) {
    console.debug(arguments)
    if (!execution_context.length) return true;
    var context = execution_context
    execution_context = []
    var name = context[0].name
    lispz.log_execution_context(context, arguments)
    return true
  }
  window.addEventListener("error", window.onerror)
  other_window_onload = window.onload
  window.onload = function() {
    window.onload = null
    if (other_window_onload) other_window_onload()
    var q = lispz_url.split('#')
    load(((q.length == 1) ? "core" : "core," + q.pop()),
      function() {
        var to_load = [], to_run = []
        slice.call(document.querySelectorAll('script[type="text/lispz"]')).forEach(
          function (script) {
            var src = script.getAttribute("src")
            if (src) {
              var parts = src.split(".")
              if (parts.pop() == "lispz") src = parts.join(".")
              to_load.push(src)
            } else {
              to_run.push(script)
            }
          })
        var end_run = function() {
          if (to_run.length) {
            to_run.forEach(function(script) {
              execution_context = [{ context: "script", script: script}]
              run("script", script.textContent)
            })
          }
          if (window.onload) window.onload() // someome else set it
        }
        if (to_load.length) load(to_load.join(","), end_run)
        else                end_run()
    })
  }
  //#########################    Helpers    ####################################//
  var clone = function (obj) {
    var target = {};
    for (var i in obj) if (obj.hasOwnProperty(i)) target[i] = obj[i];
    return target;
  }
  //#########################   Interface   ####################################//
  var macros = {
    '(': call_to_js, '[': array_to_js, '{': dict_to_js, 'macro': macro_to_js,
    '#join': join_to_js, '#pairs': pairs_to_js, '#binop': binop_to_js,
    '#requires': requires_to_js, 'list': list_to_js, "#ast": immediate_from_ast,
    'immediate': immediate_to_js, 'lambda': function_to_js, '\n': eol_to_js,
    "return": return_to_js
  }
  // add all standard binary operations (+, -, etc)
  "+,-,*,/,&&,||,==,===,<=,>=,!=,!==,<,>,^,%,|,&,^".split(',').forEach(binop_to_js)

  return { compile: compile, run: run, parsers: parsers, load: load,
           macros: macros, cache: cache, http_request: http_request,
           clone: clone, manifest: manifest, script: script, css: css,
           synonyms: synonyms, globals: globals, tags: {}, slice: slice,
           location: location, execution_contexts: execution_contexts,
           path_base: lispz_base_path, set_debug_mode: set_debug_mode, log: log,
           execution_context: execution_context, empty_words: empty_words,
           compile_to_ast: compile_to_ast, add_reference: add_reference,
           log_execution_context: log_execution_context
          }
}()


/*bootstrap*/

lispz.tags['bootstrap']="<panel>\n  <!-- ### spec: bootstrap >> Panels\n\n    A panel is a UI component that provides decorations around your content.\n    The header includes a title and a menu button.\n    An optional footer can include more text.\n\n        <panel [context=default|primary|success|info|warning|danger]\n                  [heading=heading-text] [footer=footer-text]\n                  [menu=menu-id] height=[nn%,nn]>\n          panel-body-content-html\n        </panel>\n\n    The context defines the colours use for the decoration.\n    The _menu-id_ is used to listen on a messaging channel that\n    can publish menu contents.\n\n        <panel [context=default|primary|success|info|warning|danger]\n                [heading=heading-text] [footer=footer-text]\n                [menu=menu-id] height=[nn%,nn]>\n         panel-body-content-html\n         </panel>\n    ### -->\n  <div class=\"panel { context }\" name=outer>\n    <div class=panel-heading if={ opts.heading } name=heading\n         ><bars-menu align=right name={ opts.menu } owner={ opts.owner }/>\n         <yield from=buttons/>\n         <h3 class=panel-title>{ opts.heading }</h3></div>\n    <div class=\"panel-body\" name=body><yield/></div>\n    <div class=panel-footer if={ opts.footer } name=footer\n         >{ opts.footer }</div>\n  </div>\n\n  <style>\n    panel .panel {\n      position: relative;\n    }\n    panel .panel-title {\n      cursor: default;\n    }\n    panel .panel-body {\n      position: absolute;\n      top: 40px;\n      bottom: 2px;\n      left: 0;\n      right: 2px;\n      overflow: auto;\n    }\n    panel > .panel {\n      margin-top: 10px;\n      margin-bottom: 10px;\n    }\n  </style>\n\n  <script type=text/lispz>\n    (riot-tag\n      (tag.update! {context: (+ \"panel-\" (or opts.context \"default\"))})\n      (mount-tag-using [dom]\n        (cond opts.height (do\n          (ref px (cond\n            (is \"%\" (opts.height.slice -1))\n              (/ (* window.innerHeight (opts.height.slice 0 -1)) 100)\n            (else)\n              opts.height\n          ))\n          (dom.style! tag.outer {height: (+ px \"px\")})\n        ))\n      )\n    )\n  </script>\n</panel>\n\n<panels>\n  <yield/>\n  <style>\n    /* show the move cursor as the user moves the mouse over the panel header.*/\n    panels .panel-title { cursor: move; }\n    panels .draggable { display: block; }\n  </style>\n  <script type=text/lispz>\n    (riot-tag (mount-tag-using [sortable]\n      (sortable.create tag.root (or opts.name \"sortable\") {\n        draggable:  \".draggable\"\n        handle:     \".panel-title\"\n        dataIdAttr: \"name\"\n      })\n    ))\n  </script>\n</panels>\n\n<modal>\n  <!-- ### spec: bootstrap >> Modals\n\n  Modals pop up and deny access to the rest of the page until they are dismissed.\n\n      <modal name=n [title=heading-text] [buttons=a,*b]\n        [context=default|primary|success|info|warning|danger]>\n          modal-body-content-html\n      </modal>\n\n  Buttons are added to a footer, with the one starting with a star being the default.\n  When a modal button is pressed it will send a message with a topic of\n  _modal-name/button-name/button_.\n\n      <modal name=login-dialog title=\"...\" buttons=\"Log in,Cancel\">...</modal>\n      ....\n      (message.listen \"login-dialog/Log in/button\" (lambda ...)\n  ### -->\n  <div class=\"modal fade\" role=\"dialog\" aria-labelledby={ opts.name }\n  name=modal style=\"display:none;\">\n    <div class=\"modal-dialog { modal-lg: opts.size=='large' }\n    { modal-sm: opts.size=='small' }\" role=\"document\">\n      <div class=\"modal-content\">\n        <div class=\"modal-header\" if={ opts.title }>\n          <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\">\n            <span aria-hidden=\"true\">&times;</span>\n          </button>\n          <h4 class=\"modal-title\" id={ opts.name }>{ opts.title }</h4>\n        </div>\n        <div class=\"modal-body\"><yield/></div>\n        <div class=\"modal-footer\">\n          <push-button each={ buttons }\n          type={ type } name={ name }>\n            { title }\n          </button>\n        </div>\n      </div>\n    </div>\n  </div>\n  <style>\n  </style>\n  <script type=text/lispz>\n    (riot-tag (using [dom]\n      (cond opts.buttons (do\n        (ref buttons (stateful []))\n        (tag.update! {buttons: buttons})\n        ((opts.buttons.split \",\").forEach (lambda [title]\n          (buttons.push! (cond\n            (ref primary (is \"*\" (first title))) (do\n              (ref fixed-title (title.slice 1))\n              (ref name\n                (+ \"modal/\" opts.name \"/\" fixed-title)\n              )\n              {name title: fixed-title type: \"primary\"}\n            ) (else) (do\n              (ref name (+ \"modal/\" opts.name \"/\" title))\n              {name title type: \"default\"}\n            )\n          ))\n        ))\n      ))\n      (mount-tag-using [bootstrap message]\n        (ref modal-tag ($ tag.modal))\n        (ref show (=> (modal-tag.modal \"show\")))\n        (ref hide (=> (modal-tag.modal \"hide\")))\n        (message.dispatch\n          (+ \"modal/\" opts.name) { show hide }\n        )\n        (ref transfer-event (=>\n          (ref address (+ \"modal/\" opts.name \"/\" @))\n          (modal-tag.on (+ @ \".bs.modal\") (=>\n            (message.send address { element: tag.root })\n          ))\n        ))\n        (transfer-event \"hidden\")\n        (transfer-event \"shown\")\n      )\n    ))\n  </script>\n</modal>\n\n<buttons>\n  <!-- ### spec: bootstrap >> Buttons >> Button Bar\n  A simplistic component to group buttons into a tool-bar.\n  ### -->\n  <div class=\"btn-toolbar { right: opts.align === 'right' }\" role=\"toolbar\">\n    <yield/>\n  </div>\n  <style>\n    buttons > div.right { float: right; margin-right: 1em }\n  </style>\n  <script type=text/lispz> </script>\n</buttons>\n\n<button-group>\n  <!-- ### spec: bootstrap >> Buttons >> Button Groups\n  Buttons in a group are pushed together without separating space.\n  It is a good visual effect for radio buttons.\n  ### -->\n  <div class=\"btn-group\" role=\"group\"> <yield/> </div>\n  <style> </style>\n  <script type=text/lispz> </script>\n</button-group>\n\n<push-button>\n  <!-- ### spec: bootstrap >> Buttons >> Push Button\n  Standard button representation - a button you push to take an action.\n\n  When a button is pressed it will send a message with a topic of\n  _button-name/on_ and _button-name/off_.\n\n  Attributes are\n\n  * **name**: Name of button - used to send the push messages\n  * **type**: [*default|primary|success|info|warning|danger]\n  * **size**: [*default|lg|sm|xs]\n  ### -->\n  <button class=\n    \"btn btn-{ opts.type || 'default' } btn-{ opts.size || 'default' }\"\n    name=button>\n    <yield/>\n  </button>\n  <style></style>\n  <script type=text/lispz>\n    (riot-tag (mount-tag-using [message]\n      (tag.button.addEventListener \"click\" (=>\n        (message.send opts.name {})\n      ))\n    ))\n  </script>\n</push-button>\n\n<bars-menu>\n  <!-- ### spec: bootstrap >> Menus\n\n  A menu is a multi-level option selection.\n  Both menu contents and results selected communicate by messages.\n\n  Menu contents loading can be driven by the menu component or an external provider.\n  For the former, the menu component sends out a message when a user asks to open the menu.\n  It is up to a listener to provide the data requested.\n  Use this if the menu contents change between uses.\n\n        (message.listen \"specifications-menu/open\" (lambda\n          (ref menu (dict.map lispz_modules (lambda [title source]\n            (return {topic: \"specifications\" title source})\n          )))\n          (message.send \"specifications-menu\" (menu.sort))\n        ))\n\n  This example has a flat single-level list. All menus send a message when\n  displayed with the name of the menu concatenated to _.open_.\n  They also listen on the menu name as an address,\n  so you can pass the resulting menu back.\n\n  If an external controller knows when the menu changes,\n  or if the menu is static, then send the contents to a named message address\n  so that the specified menu can be reloaded. If this happens before the menu\n  is displayed the menu will not be loaded.\n  To fix this, wait for the menu to be ready.\n\n        (when (message.ready> \"specifications-menu\")\n          (message.send \"specifications-menu\" nenu)\n        )\n  The menu itself is a dictionary with the format:\n\n       (ref test-menu\n          [[\n            { header: true title: \"Heading 1\" }\n            { title: \"Item 1\" topic: \"Test menu item 1\" }\n            { title: \"Item 2\" children: [[{ title: \"Item 2a\" }]] }\n            { divider: true }\n            { title: \"item 2\" disabled: true }\n          ]]\n        )\n      (message.send \"test-menu\" test-menu)\n\n  where _header_ and _divider_ are list separates that cannot be selected.\n  For the rest, _title_ is the text displayed, _topic_ is part of the the address\n  for the message sent, _children_ defines sub-menus and _disabled_ is for items\n  that cannot be selected.\n\n  If a menu item has a topic entry, a message will be sent to that an address\n  made up of the component owner, dash, topic.\n\n      (message.listen \"Test Panel 2 - Test menu item 1\" (lambda [data] (debug data)))\n\n  ###\n  ### spec: bootstrap >> Menus >> bars-menu\n\n  This menu type displays three horizontal bars - sometime call a _hamburger_.\n  Click it opens up a drop-down menu.\n\n      <bars-menu align=left|center|right name=name owner=owning-component />\n\n  The owner is prepended to the response to a menu selection so that the correct\n  component can respond.\n  ### -->\n  <div name=dropdown class=\"dropdown { right: opts.align === 'right' }\">\n    <a style=\"text-decoration: none\" data-toggle=\"dropdown\" name=bars\n    class=\"glyphicon glyphicon-menu-hamburger dropdown-toggle\" aria-hidden=\"true\"\n    ></a>\n    <ul class=\"dropdown-menu { dropdown-menu-right: opts.align === 'right' }\">\n      <li each={ items } class={ dropdown-header: header && title,\n          divider: divider, disabled: disabled }><a onclick={ goto } href=\"#\">\n          <span class=\"pointer right float-right\" if={ children }></span>\n          { title }&nbsp;&nbsp;&nbsp;\n      </a></li>\n    </ul>\n  </div>\n  <style>\n    bars-menu > div.right { float: right }\n    bars-menu span.caret { margin-left: -11px }\n    bars-menu a.dropdown-toggle { cursor: pointer }\n  </style>\n  <script type=text/lispz>\n    (riot-tag (mount-tag-using [message riot]\n      (message.listen opts.name (lambda [items]\n        (riot.update! tag {items root: (or items [[]])})\n      ))\n      (($ tag.dropdown).on \"show.bs.dropdown\" (lambda\n        (message.send (+ opts.name \"/open\"))\n        (riot.update! tag {items: tag.root})\n      ))\n      (tag.update! {goto: (lambda [ev]\n        (cond ev.item.topic (message.send\n          (+ opts.owner \"/\" ev.item.topic)\n          {item: ev.item owner: opts.owner action: \"select\"}))\n        (cond ev.item.children (do\n          (tag.update! {items: ev.item.children})\n          (ev.currentTarget.blur)\n          (ev.stopPropagation)\n        ))\n      )})\n    ))\n  </script>\n</bars-menu>\n\n<tree>\n  <!-- ### spec: bootstrap >> Trees\n    A tree provides an identical interface to a menu.\n    Visually all levels to the current selection remain displayed.\n    Selecting a branch will toggle it opened or closed.\n    Selecting a leaf will send a message to the owning component.\n  ### -->\n  <tree-component name=base/>\n  <script type=text/lispz>\n    (riot-tag (using [message riot]\n      (message.listen opts.name (lambda [items]\n        (riot.update! tag {children: {base: {children: items}}})\n        (tag.update) ## once more for luck\n      ))\n    ))\n  </script>\n</tree>\n\n<tree-component>\n  <ul class=\"dropdown-menu\">\n    <li each={ item, i in items }\n        class={ dropdown-header: item.header && item.title,\n        divider: item.divider, disabled: item.disabled }\n        ><a onclick={ parent.goto } href=\"#\">\n        <span if={ item.children }\n              class=\"glyphicon glyphicon-triangle-right\"\n              aria-hidden=\"true\"></span>{ item.title }</a>\n        <tree-component if={ item.children } name={ item.title }>\n    </li>\n  </ul>\n  <style>\n    tree-component ul {\n      display: inherit !important;\n      position: inherit !important;\n    }\n    tree-component:not([name=base]) > ul {\n      display: none !important;\n    }\n    tree-component:not([name=base]).open > ul {\n      margin-left:  9px;\n      margin-right: 9px;\n      display: inherit !important;\n    }\n    tree-component span.glyphicon {\n      margin-left: -18px;\n    }\n  </style>\n  <script type=text/lispz>\n    (riot-tag (using [message dict]\n      (tag.on \"update\" (lambda [data]\n        (cond (and opts.name tag.parent.children) (do\n          (tag.update! {items: (get tag.parent.children opts.name \"children\")})\n          (cond (and tag.items tag.items.length)\n                (tag.update! {children: (dict.from-list tag.items \"title\")})\n          )\n        ))\n      ))\n\n      (tag.update! {goto: (lambda [ev]\n        (ref item ev.item.item)\n        (ref topic (or item.topic item.title ))\n        (cond topic (message.send topic {item action: \"select\"}))\n        (cond item.children (do\n          (ref tree ev.currentTarget.nextElementSibling)\n          (tree.classList.toggle \"open\")\n          (tree.parentElement.classList.toggle \"bg-info\")\n        ))\n        (ev.stopPropagation)\n      )})\n    ))\n  </script>\n</tree-component>\n\n<sidebar>\n  <!-- ### spec: bootstrap >> Side-bars\n    A side-bar is a slide-in draw. When hidden it displays a string\n    down the left side of the screen. Clicking on the 3-bars icon at\n    the top will slide the panel in and out.\n  ### -->\n  <a aria-hidden=\"true\" name=hamburger\n    class=\"glyphicon glyphicon-menu-hamburger\"></a>\n  <div id=sidebar class=\"container bg-primary\"><yield/></div>\n  <style>\n    sidebar > a {\n      text-decoration: none !important;\n      position: absolute !important;\n      z-index: 2000;\n    }\n    #sidebar {\n      z-index: 1000;\n      position: fixed;\n      width: 0;\n      height: 100%;\n      overflow-y: auto;\n      -webkit-transition: all 0.5s ease;\n      -moz-transition: all 0.5s ease;\n      -o-transition: all 0.5s ease;\n      transition: all 0.5s ease;\n      padding-right: 0;\n      overflow: hidden;\n    }\n    #sidebar.toggled { width: auto; padding-right: 15px; }\n  </style>\n  <script type=text/lispz>\n    (riot-tag (using [message dom]\n      (ref hamburger (stateful.morph! tag.hamburger))\n      (hamburger.update! {onclick: (lambda\n        (tag.sidebar.classList.toggle \"toggled\")\n        (delay 300 ## must be after slide action\n          (message.send \"dom/page-content-wrapper-padding\" tag.sidebar.offsetWidth)\n        )\n      )})\n      (mount-tag-using [riot] (delay 300\n        (message.send \"dom/page-content-wrapper-padding\" tag.sidebar.offsetWidth)\n      ))\n    ))\n  </script>\n</sidebar>\n\n<page-content>\n  <div id=page_content_wrapper>\n    <div class={ container-fluid: opts.fluid, container: !opts.fluid }>\n      <yield/>\n    </div>\n  </div>\n  <style>\n    #page_content_wrapper {\n      width: 100%;\n      position: absolute;\n    }\n  </style>\n  <script type=text/lispz>\n    (riot-tag (using [message dom]\n      (message.listen \"dom/page-content-wrapper-padding\" (lambda [px]\n        (dom.style! tag.page-content-wrapper {paddingLeft: (+ px \"px\")})\n      ))\n    ))\n  </script>\n</page-content>\n\n<bootstrap>\n  <div id=page-wrapper><yield/></div>\n  <style>\n    .pointer {\n      border: 5px solid transparent;\n      display: inline-block;\n      width: 0;\n      height: 0;\n      vertical-align: middle;\n    }\n    .pointer.float-right {\n      float: right;\n      margin-top: 5px;\n    }\n    .pointer.up {\n        border-bottom: 5px solid;\n    }\n    .pointer.right {\n        border-left: 5px solid;\n    }\n    .pointer.down {\n        border-top: 5px solid;\n    }\n    .pointer.left {\n        border-right: 5px solid;\n    }\n  </style>\n  <script type=text/lispz>\n    (riot-tag (using [dom net jquery riot message bootstrap]\n      (dom.append! \"head\" (dom.element \"meta\"\n        {name: \"viewport\" content: \"width=device-width, initial-scale=1\"}\n      ))\n    ))\n  </script>\n</bootstrap>\n"


/*code-editor*/

lispz.tags['code-editor']="<code-editor>\n  <panel height={ opts.height } heading={ heading }\n      menu={ menu } owner={ _riot_id }>\n      <yield to=buttons><yield></yield>\n  </panel>\n  <style>\n    code-editor .CodeMirror {\n      position: absolute;\n      top: 0; bottom: 0;\n      left: 5px; right: 0;\n      height: initial;\n    }\n  </style>\n  <script type=text/lispz>\n    (riot-tag\n      (tag.update! {menu: \"codemirror/menu\" heading: (or opts.heading \"Edit\")})\n      (mount-tag-using [codemirror message message dict events]\n        (ref filename-key (+ \"code-editor/\" opts.name \"/filename\"))\n        (ref cm (codemirror.open tag._riot_id tag.tags.panel.body))\n\n        (ref open (lambda [packet]\n          (codemirror.set-mode cm packet.key)\n          (cond (isnt (get packet.key 0) \".\") (do\n            (tag.update! {heading: (last (packet.key.split \"/\"))})\n            (tag.update)\n          ))\n          (localStorage.setItem filename-key packet.key)\n          (cm.setValue packet.contents)\n        ))\n\n        (ref contents-key (+ \"code-editor/\" opts.name \"/contents\"))\n        (ref filename (localStorage.getItem filename-key))\n        (cond filename (delay 100\n          (open {key: filename contents: (localStorage.getItem contents-key)})\n        ))\n        (cm.on \"change\" (events.delay 1000 (lambda\n          (ref contents (cm.getValue)) (ref name opts.name)\n          (localStorage.setItem contents-key contents)\n          (message.send (+ \"code-editor/\" name \"/change\") { contents name })\n        )))\n\n        (ref append (lambda [packet]\n          (cm.replaceRange packet.contents (CodeMirror.Pos (cm.lastLine)))\n        ))\n\n        (ref contents (=> (cm.getValue)))\n\n        (ref focus (=> (cm.focus)))\n\n        (message.dispatch (+ \"code-editor/\" opts.name)\n          { open append contents focus }\n        )\n      )\n    )\n  </script>\n</code-editor>\n"


/*firepad*/

lispz.tags['firepad']="<firepad>\n  <!-- <firepad name=pad-name [db=default]> -->\n  <panel height={ opts.height } heading={ heading }\n      menu={ menu } owner={ _riot_id }>\n    <div name=wrapper class=wrapper></div>\n  </panel>\n  <style>\n    firepad .wrapper {\n      position: absolute;\n      top: 0; bottom: 0;\n      left: 0; right: 0;\n      height: initial;\n    }\n    firepad .CodeMirror {\n      position: absolute;\n      top: 0; bottom: 0;\n      left: 5px; right: 0;\n      height: initial;\n    }\n    a.powered-by-firepad { display: none; }\n    div.firepad-toolbar { margin-top: -25px; }\n  </style>\n  <script type=text/lispz>\n    (riot-tag\n      (tag.update! {menu: \"codemirror/menu\"})\n      (tag.update! {heading: \"Edit\"})\n      (mount-tag-using [firebase codemirror firepad message dict]\n        (ref filename-key (+ \"codemirror/\" opts.name \"/filename\"))\n        (ref cm (codemirror.open tag._riot_id tag.tags.panel.wrapper))\n        (tag.update! {pad: (stateful {\n          setText:  (lambda [contents] (cm.setValue contents))\n          on-ready: (lambda [act] (act))\n        })})\n\n        (ref open (lambda [packet]\n          (codemirror.set-mode cm packet.key)\n          (tag.update! {heading: (last (packet.key.split \"/\"))})\n          (localStorage.setItem filename-key packet.key)\n          (cond packet.contents (tag.pad.setText packet.contents))\n          (tag.update)\n        ))\n\n        (cond\n          opts.db (do\n            (ref db (firebase.attach (+ \"firepads/\" opts.name) opts.db))\n            (tag.update! {pad: (stateful.morph (Firepad.fromCodeMirror db cm\n              {richTextShortcuts: false richTextToolbar: false}\n            ))})\n            (tag.pad.update! {on-ready: (lambda [act] (tag.pad.on \"ready\" act))})\n          ) (else) (do ## without firebase we need to persist locally\n            (ref contents-key (+ \"codemirror/\" opts.name \"/contents\"))\n            (ref filename (localStorage.getItem filename-key))\n            (cond filename (delay 100\n              (open {key:      filename\n                     contents: (localStorage.getItem contents-key)})\n            ))\n            (cm.on \"change\" (lambda\n              (localStorage.setItem contents-key (cm.getValue))\n            ))\n          )\n        )\n\n        (tag.pad.on-ready (lambda\n          (message.dispatch (+ \"firepad/\" opts.name) { open })\n        ))\n      )\n    )\n  </script>\n</firepad>\n"


/*github*/

lispz.tags['github']="<github>\n</github>\n\n<github-login>\n  <modal name=github-login size=\"small\" title=\"GitHub Login\" buttons=\"*Sign In\">\n    <div style=\"position:absolute;top:20px;left:16px;\">\n      <svg xmlns:dc=\"http://purl.org/dc/elements/1.1/\" xmlns:cc=\"http://creativecommons.org/ns#\" xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"2 2 81 79\" height=\"83px\" width=\"83px\" xml:space=\"preserve\" id=\"svg2\" version=\"1.1\"  preserveAspectRatio=\"xMidYMid meet\"><rect id=\"svgEditorBackground\" x=\"0\" y=\"0\" width=\"83\" height=\"83\" style=\"fill: none; stroke: none;\"/><metadata id=\"metadata8\"><rdf:RDF><cc:Work rdf:about=\"\"><dc:format>image/svg+xml</dc:format><dc:type rdf:resource=\"http://purl.org/dc/dcmitype/StillImage\"/></cc:Work></rdf:RDF></metadata><defs id=\"defs6\"><clipPath id=\"clipPath20\" clipPathUnits=\"userSpaceOnUse\"><path id=\"path18\" d=\"M 0,4999.88 V 0 h 5309.73 v 4999.88 z\"/></clipPath></defs><g transform=\"matrix(1.3333333,0,0,-1.3333333,0,666.65333)\" id=\"g10\"><g transform=\"scale(0.1)\" id=\"g12\"><g id=\"g14\"><g clip-path=\"url(#clipPath20)\" id=\"g16\"><path id=\"path24\" style=\"fill:#1b1817;fill-opacity:1;fill-rule:evenodd;stroke:none\" d=\"M217.5955922475381,4947.035689638439c-89.94000000000005,0,-162.8800000000001,-72.93000000000029,-162.8800000000001,-162.89999999999964c0,-71.96000000000004,46.67000000000007,-133.02000000000044,111.40000000000009,-154.5699999999997c8.150000000000091,-1.4899999999997817,11.11999999999989,3.5399999999999636,11.11999999999989,7.8599999999996735c0,3.8699999999998913,-0.14000000000010004,14.109999999999673,-0.2200000000000273,27.699999999999818c-45.309999999999945,-9.840000000000146,-54.86999999999989,21.840000000000146,-54.86999999999989,21.840000000000146c-7.410000000000082,18.81999999999971,-18.089999999999918,23.829999999999927,-18.089999999999918,23.829999999999927c-14.789999999999964,10.100000000000364,1.1199999999998909,9.899999999999636,1.1199999999998909,9.899999999999636c16.34999999999991,-1.1499999999996362,24.950000000000045,-16.789999999999964,24.950000000000045,-16.789999999999964c14.529999999999973,-24.890000000000327,38.13000000000011,-17.699999999999818,47.41000000000008,-13.529999999999745c1.4800000000000182,10.520000000000437,5.6900000000000555,17.699999999999818,10.339999999999918,21.770000000000437c-36.17000000000007,4.119999999999891,-74.20000000000005,18.090000000000146,-74.20000000000005,80.51000000000022c0,17.789999999999964,6.349999999999909,32.31999999999971,16.769999999999982,43.710000000000036c-1.6800000000000637,4.119999999999891,-7.269999999999982,20.68000000000029,1.599999999999909,43.10999999999967c0,0,13.670000000000073,4.380000000000109,44.789999999999964,-16.6899999999996c12.990000000000009,3.6099999999996726,26.930000000000064,5.4099999999998545,40.77999999999997,5.479999999999563c13.839999999999918,-0.06999999999970895,27.769999999999982,-1.869999999999891,40.77999999999997,-5.479999999999563c31.09999999999991,21.06999999999971,44.75,16.6899999999996,44.75,16.6899999999996c8.8900000000001,-22.43000000000029,3.2999999999999545,-38.98999999999978,1.6300000000001091,-43.10999999999967c10.440000000000055,-11.390000000000327,16.74000000000001,-25.920000000000073,16.74000000000001,-43.710000000000036c0,-62.57999999999993,-38.08999999999992,-76.35000000000036,-74.37000000000012,-80.38000000000011c5.839999999999918,-5.029999999999745,11.049999999999955,-14.970000000000255,11.049999999999955,-30.170000000000073c0,-21.770000000000437,-0.20000000000004547,-39.340000000000146,-0.20000000000004547,-44.68000000000029c0,-4.3599999999996735,2.9400000000000546,-9.430000000000291,11.200000000000045,-7.8400000000001455c64.68000000000006,21.590000000000146,111.30999999999995,82.60000000000036,111.30999999999995,154.55000000000018c0,89.97000000000025,-72.94000000000005,162.89999999999964,-162.91000000000008,162.89999999999964\" transform=\"matrix(1.82417 0 0 1.82417 -77.5862 -4045.5)\"/><path id=\"path42\" style=\"fill:none;stroke:#3a7fc3;stroke-width:10;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:10;stroke-dasharray:none;stroke-opacity:1\" d=\"m 2248.98,4994.88 v -5\"/></g></g></g></g></svg>\n    </div>\n    <form class=form-horizontal style=\"margin-left:100px\">\n      <input type=hidden name=login value=false class=login>\n      <input type=text class=form-control name=username placeholder=\"User Name\">\n      <br>\n      <input type=password class=form-control name=password placeholder=Password>\n      <br>\n      <input type=checkbox name=remember\n        data-toggle=tooltip\n        title=\"Only use on a secure, private account\"> Remember me\n    </form>\n  </modal>\n  <style>\n  </style>\n  <script type=text/lispz>\n    (riot-tag (mount-tag-using [github message dom]\n      (ref login-element (first\n        (tag.root.getElementsByClassName \"login\")\n      ))\n      (message.listen \"modal/githib-login/shown\" (=>\n        (login-element.setAttribute \"value\" \"false\")\n      ))\n      (message.listen \"modal/github-login/Sign In\" (=>\n        (login-element.setAttribute \"value\" \"true\")\n        (message.send \"modal/github-login/hide\")\n      ))\n    ))\n  </script>\n</github-login>\n"


/*iframe-panel*/

lispz.tags['iframe-panel']="<iframe-panel>\n  <panel height={ opts.height } heading={ heading } menu={ menu } owner={ _riot_id }>\n    <iframe name=iframe class=iframe></iframe>\n  </panel>\n  <style>\n    iframe-panel .panel-body {\n      bottom: 0;\n      left: 1px;\n      right: 1px;\n      padding: 0;\n      padding-bottom: 1px;\n    }\n    iframe-panel .iframe {\n      position: absolute;\n      height: 100%;\n      width: 100%;\n    }\n  </style>\n  <script type=text/lispz>\n    (riot-tag\n      (tag.update! {menu: opts.menu heading: opts.heading})\n      (mount-tag-using [message]\n        (ref iframe tag.tags.panel.iframe)\n        (ref iframe-doc (or iframe.contentDocument iframe.contentWindow.document))\n\n        (cond opts.src (iframe.setAttribute \"src\" opts.src))\n\n        (tag.update! {\n          open: (lambda [packet]\n            (tag.update! {heading: (or packet.heading tag.heading)})\n            (cond packet.menu (tag.update! {menu: packet.menu}))\n            (iframe-doc.open)\n            (iframe-doc.write (+\n              \"<!DOCTYPE html><html><head><meta charset='utf-8'>\"\n              (or packet.head \"\")\"</head><body>\" (or packet.body \"\") \"</body></html>\"\n            ))\n            (iframe-doc.close)\n            (tag.update)\n          )\n        })\n      )\n    )\n  </script>\n</iframe-panel>\n"


/*lispz*/

lispz.tags['lispz']="<lispz>\n  <bootstrap class=riot>\n    <page-content fluid=true>\n      <panels name=editor-panels>\n        <code-editor class=\"riot col-sm-6 draggable\" name=code\n          height=46% heading=Lispz>\n          <buttons name=code/buttons align=right>\n            <push-button name=code/run type=info size=xs title=\"<alt><enter>\">Run</push-button>\n          </buttons>\n        </code-editor>\n        <code-editor  class=\"riot col-sm-6 draggable\" name=compiled\n          height=46% heading=\"Generated Javascript\" />\n        <code-editor  class=\"riot col-sm-6 draggable\" name=output\n          height=46% heading=\"Console\" />\n        <markdown class=\"riot col-sm-6 draggable\" name=manual\n          href=\"README.md\"\n          height=46% heading=\"Manual\" />\n      </panels>\n    </page-content>\n  </bootstrap>\n\n  <script type=\"text/lispz\">\n    (riot-tag (using [message]\n      (lispz.set-debug-mode true)\n\n      (ref open (lambda [topic key contents]\n        (message.send (+ \"code-editor/\" topic \"/open\") {key contents})\n      ))\n\n      (when (message.ready> \"code-editor/code/open\")\n        (open \"code\" \".lispz\" \"\")\n        (message.send \"code-editor/code/focus\" {})\n      )\n\n      (ref clear_result_panels (=>\n        (open \"output\" \".txt\" \"\") (open \"compiled\" \".js\" \"\")\n      ))\n      (message.listen \"code-editor/run/prepare\" clear_result_panels)\n\n      (ref log (lambda [output]\n        (message.send \"code-editor/output/append\" {\n          key:      \".text\"\n          contents: (+ output \"\\n\")\n        })\n      ))\n\n      (using [js-beautify compilers]\n        (ref compiler (get compilers \"lispz\"))\n        (message.listen \"code-editor/run/compiled\" (lambda [compiled]\n          (open \"compiled\" \".js\" (window.js_beautify compiled.js))\n        ))\n        (ref compile-and-show (lambda [source]\n          (clear_result_panels)\n          (ref compiled (compiler.compile source \"Scratchpad\"))\n          (ref js (window.js_beautify (compiled.join \"\")))\n          (open \"compiled\" \".js\" js)\n          js\n        ))\n        (message.listen \"code-editor/code/change\" (=>\n          (compile-and-show @.contents))\n        )\n        (message.listen \"code/run\" (=>\n          (ref sources> (message.request> \"code-editor/code/contents\" @))\n          (when sources> [sources]\n            (compilers.run [[(compile-and-show (first sources))]])\n          )\n        ))\n      )\n\n      (stateful.morph! console)\n      (console.update! {log: (=> (log (+ ((*arguments 0).join \" \"))) null)})\n      (message.listen \"code-editor/run/output\" (=> (log @.output)))\n    ))\n  </script>\n</lispz>\n"


/*markdown*/

lispz.tags['markdown']="<markdown>\n  <panel height={ opts.height } heading={ heading } menu={ menu } owner={ _riot_id }>\n    <div name=wrapper class=wrapper></div>\n  </panel>\n  <style>\n  </style>\n  <script type=text/lispz>\n    (riot-tag\n      (ref markdown-menu (+ \"panel/markdown/\" opts.name \"/menu\"))\n      (ref markdown-menu-action (+ markdown-menu \"/action\"))\n      (tag.update! {menu: markdown-menu heading: opts.heading})\n      (mount-tag-using [markdown dom net message dict]\n        (ref contents-area tag.tags.panel.body)\n\n        ## hamburget menu lists a history of pages followed\n        (ref history (stateful))\n        (ref address (+ tag._riot_id \"/\" markdown-menu-action))\n        (message.listen  address (lambda [packet]\n          ## load an item selected from the hamburger\n          (load packet.item.href)\n        ))\n        (ref open (lambda [md from]\n          (ref from (or from \"\"))\n          (dom.inner-html! contents-area (markdown.compile md))\n          ((dom.select contents-area \"a\").forEach (lambda [link]\n            (ref href (link.getAttribute \"href\"))\n            (cond (not (net.external? href)) (do\n              (link.addEventListener \"click\" (lambda [evt]\n                (load (+ from href))\n                (evt.preventDefault)\n              ))\n            ))\n          ))\n        ))\n        (ref load (lambda [href]\n          ## Update the hamburger with the latest history update\n          (history.update! href true)\n          (ref menu (dict.map history (lambda [href]\n            (ref title (first ((net.url-actor href).split \".\")))\n            (return {topic: markdown-menu-action href title})\n          )))\n          (message.send markdown-menu (menu.reverse))\n          ## then continue loading and displaying\n          (ref loaded (net.http-get href))\n          (when loaded [md] (open md (net.url-path href)))\n          (promise.failed loaded [err] (debug err))\n        ))\n        (cond opts.href (load opts.href))\n\n        ### spec: Markdown >> Panel\n          Showdown can take markdown text or url and display the\n          HTML created - including most Github extensions.\n\n          In the component HTML section, define a showdown panel as follows.\n          The href is optional, and the panel will start empty without it.\n\n              &lt;showdown name=manual heading=\"Manual\"\n                href=\"https://cdn.rawgit.com/paulmarrington/lispz/master/README.md\"\n              /&gt;\n\n          To load a different markdown document from a server, send a message.\n          The final part of the address is the name attribute to the showdown\n          element above.\n\n              ((message.send \"showdown/manual/open\") {\n                href: \"another-url\"\n              })\n\n          Alternatively, pass the markdown directly in a string with the load\n          message.\n\n              ((message.send \"showdown/manual/load\") {\n                markdown: \"# Heading\\n*This is markdown*\"\n              })\n        ###\n        (message.dispatch (+ \"showdown/\" opts.name) { open load })\n      )\n    )\n  </script>\n</markdown>\n"
