(using [github list tree-view message]

  (ref add-repos (lambda [component owner]
    (monitor-tree-messages component)
    (fill-tree-view component owner)
  ))

  (ref fill-tree-view (lambda [component owner]
    (when (github.repos> owner) [repos]
      (ref paths ((extract-paths repos).map (=> (+ @ "/"))))
      (ref paths (path-to-tree paths repo-options))
      (ref tree {
        title: "GitHub" children: paths
        style: {
          open:   "cloud-download"
          closed: "cloud-upload"
          branch: "github"
        }
      })
      (tree-view.replace component tree)
    )
  ))

  (ref monitor-tree-messages (lambda [component]
    (ref base    (+ "tree-view/" component "/dom/click"))
    (ref opening (+ base "branch/open/"))
    (message.listen (+ opening "repo") (lambda [packet]
      (ref path (parse-path packet.path))
      (ref repo (github.repo> path.repo))
      (when (github.branches> repo) [data]
        (ref branches (path-to-tree (data.map (=> @.name))) branch-options)
        (tree-view.update component packet.path branches)
      )
    ))
  ))

  (ref parse-path (=>
    (ref path (@.split "/"))
    {
      store:  (first path)
      repo:   (+ (second path) "/" (third path))
      branch: (fourth path)
      file:   ((slice path 4).join "/")
    }
  ))

  (ref repo-options [[
    { open: "user" closed: "user" color: "primary" branch: "user" }
    { open: "book" closed: "book" color: "success" branch: "repo" }
  ]])
  (ref branch-options [[{
    open: "random"    closed: "random"
    color: "warning"  branch: "branch"
  }]])
  (ref contents-options [[{
    open:   "folder-open"     closed: "folder-closed"
    branch: "dir"             leaf:   "file"
    color:  "default"
  }]])

  (ref load-repo (lambda [name repo paths]
  ))

  (ref extract-paths (=> (list.sort (@.map (=> @.full-name)))))

  ### ref: (github-view.path-to-tree path-list)
    e.g. (tree-view.path-to-tree ["a/b" "a/c" "d/e" "f"])
  ###
  (ref path-to-tree (lambda [path-list options]
    (ref paths (list.sort path-list))
    (ref tree (stateful))
    (list.for-each paths (lambda [path]
      (ref level (lambda [branches depth]
        (ref style (get options
          (cond (< depth options.length) depth (else) (- options.length 1))
        ))
        (cond (> branches.length 1) (do
          ## we are at a branch, recursive call to add more
          (ref title 	 (first branches))
          (ref sub-branch (level (rest branches (+ depth 1))))
          (ref children  (stateful))
          (cond sub-branch
            (children.update! (second branches) sub-branch)
          )
          { title children style }
        ) (first branches) ## at leaf
          { title: (first branches)  style }
        )
      ))
      (ref split (path.split "/"))
      (tree.update! (first split) (level split 0))
    ))
    tree
  ))

  (export { add-repos })
)
