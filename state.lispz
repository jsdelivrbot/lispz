### literate: basic >> state -- Stateful Containers
  State is the elephant in the room - particularly in the functional programming paradigm.
  When you have state that can be changed from outside, then any function that reads from it
  no longer has referential integrity. This means that identical calls may not return identical
  results.
  
  But we need state. Without it the system is fully enclosed without input or output.
  A referentially integrous :) function can be replaced by it's return value,
  so why ever run it?
  
  The aim is to be like any machine with the internals always working the same.
  Think of a clock. The input is someone setting the time.
  After that the external gearing, etc is meant to work consistently so that the
  time advances at the correct pace. The current time is state. You can build and
  test the entire device without the state. It is on the very outside. Once the
  mechanism is working as expected, add a clock face and hands. Changing the hands
  is input and displaying the time output. The latter can be considered a
  side-effect.
  
  The state container for lispz relies on polite access, not enforced rules. By custom an
  object holding state that may break referential integrity ends in an exclamation mark.
  The default builder return an empty JavaScript dictionary.

      (describe "Create a new stateful object -- (var ref (state seed))" (=>
        (using [state]
          (var options (state {name!: "undefined" address!: "nowhere"}))
          (it "is able to read members directly -- stateful.member!" (=>
            ((expect options.name!).toBeEqual "undefined")
          ))
          (it "is able to read members by key -- stateful[key]" (=>
            ((expect options["name!"]).toBeEqual "undefined")
          ))
          (it "is able to change member values -- (state.set stateful.member! value)" (=>
            (state.set options.name! "Fred Flinstone")
            ((expect options.name!).toBeEqual "Fred Flinstone")
          ))
        )
      ))
  
  Be polite and use this container responsibly. Adding protection adds overhead. If
  you want to cheat, then so be it.
###

(var state (lambda [seed] (return (Object.create Object.prototype seed))))
(var set (lambda [state! value] (#join '' state! '=' value ';')
(set state.set set) ## so we can pass back the 'constructor'

(export state)

### not implemented
  Javascript lives in the world of objects as well as functions. Sometimes to work in this world
  objects need to be labelled as stateful. Use this approach as sparingly as possible. Always
  consider other alternatives first.
  
      (describe "Creating a stateful reference -- (var ref (state.morph this))" (=>
        (using [state]
          (var that {a: 1 b: 2})
          (var context (state.morph that))
          (it "looks the same as the original object" (=>
            ((expect context.a).toBeEqual that.a)
          ))
          (it "reflects changes to the original object" (=>
            (state.set context.a 99)
            ((expect that.a).toBeEqual 99)
          ))
        )
      ))
###
