<panel>
  <!-- ### spec: bootstrap >> Panels

    A panel is a UI component that provides decorations around your content.
    The header includes a title and a button bar.
    An optional footer can include more text.

        <panel [context=default|primary|success|info|warning|danger]
                  [heading=heading-text] [footer=footer-text]
                  [menu=menu-id] height=[nn%,nn]>
          panel-body-content-html
        </panel>

    The context defines the colours use for the decoration.
    The _menu-id_ is used to listen on a messaging channel that
    can publish menu contents.

        <panel [context=default|primary|success|info|warning|danger]
                [heading=heading-text] [footer=footer-text]
                [menu=menu-id] height=[nn%,nn]>
          <div name=body>panel-body-content-html</div>
          <div name=tool-bar>buttons-for-toolbar</div>
         </panel>
    ### -->
  <div class="panel" actor=set-context,set-height>
    <div class="panel-heading" actor=display-heading>
      <bars-menu align=right actor=set-menu/>
       <buttons actor=tool-bar/>
       <h3 name=heading class="panel-title" actor=set-heading></h3>
     </div>
    <div name=body class="panel-body" actor=fill-body></div>
    <div name=footer class="panel-footer" actor=set-footer></div>
  </div>

  <style>
    panel .panel {
      position: relative;
    }
    panel .panel-title {
      cursor: default;
    }
    panel buttons .btn-toolbar {
      margin-top: -2px;
    }
    panel .panel-body {
      position: absolute;
      top: 40px;
      bottom: 2px;
      left: 0;
      right: 2px;
      overflow: auto;
    }
    panel > .panel {
      margin-top: 10px;
      margin-bottom: 10px;
    }
  </style>

  <script type=text/lispz>
    (using [dom]
      (tag.activate {
        set-context:      (lambda [node]
          (node.classList.add
            (+ "panel-" (or tag.attributes.context "default"))
          )
        )
        set-height:       (lambda [node]
          (ref height (dom.get-height tag.attributes.height))
          (dom.style! node { height })
        )
        tool-bar:         (tag.fill "tool-bar")
        set-heading:      (tag.html tag.attributes.heading)
        fill-body:        (tag.fill "body")
        display-heading:  (tag.transfer-attribute "heading")
        set-menu:         (tag.transfer-attribute "menu")
        set-footer:       (tag.transfer-attribute "footer")
      })
    )
  </script>
</panel>

<panels>
  <div actor=body></div>
  <style>
    /* show the move cursor as the user moves the mouse over the panel header.*/
    panels .panel-title { cursor: move; }
    panels .draggable { display: block; }
  </style>
  <script type=text/lispz>
    (tag.activate { fill: tag.fill })
    (using [sortable]
      (sortable.create tag (or tag.attributes.name "sortable") {
        draggable:  ".draggable"
        handle:     ".panel-title"
        dataIdAttr: "name"
      })
    )
  </script>
</panels>

<modal>
  <!-- ### spec: bootstrap >> Modals

  Modals pop up and deny access to the rest of the page until they are dismissed.

      <modal name=n [title=heading-text] [buttons=a,*b]
        [context=default|primary|success|info|warning|danger]>
          modal-body-content-html
      </modal>

  Buttons are added to a footer, with the one starting with a star being the default.
  When a modal button is pressed it will send a message with a topic of
  _modal-name/button-name/button_.

      <modal name=login-dialog title="..." buttons="Log in,Cancel">...</modal>
      ....
      (message.listen "login-dialog/Log in/button" (lambda ...)
  ### -->
  <div class="modal fade" role="dialog" actor=aria-labelledby
  name=modal style="display:none;">
    <div class="modal-dialog" actor=modal-size role="document">
      <div class="modal-content">
        <div class="modal-header" actor=display-title>
          <button type="button" class="close" data-dismiss="modal" aria-label="Close">
            <span aria-hidden="true">&times;</span>
          </button>
          <h4 class="modal-title" actor=title></h4>
        </div>
        <div class="modal-body" actor=body></div>
        <div class="modal-footer">
          <buttons actor=tool-bar/>
        </div>
      </div>
    </div>
  </div>
  <script type=text/lispz>
    (using [dom]
      (tag activate {
        aria-labelledby:  (lambda [node]
          (node.setAttribute "aria-labelledby" tag.attributes.name)
        )
        modal-size:       (lambda [node]
          (node.classList.remove "modal-lg modal-sm")
          (cond
            (is tag.attributes.size "large")
              (node.classList.add "modal-lg")
            (is tag.attributes.size "small")
              (node.classList.add "modal-sm")
          )
        )
        display-title:    (tag.transfer-attribute "title")
        title:            (tag.html "title")
        body:             (tag.fill "body")
        tool-bar:         (tag.fill "tool-bar")
      })
      (ref modal-tag ($ tag.modal))
      (ref show (=> (modal-tag.modal "show")))
      (ref hide (=> (modal-tag.modal "hide")))
      (message.dispatch
        (+ "modal/" tag.attributes.name) { show hide }
      )
      (ref transfer-event (=>
        (ref address (+ "modal/" tag.attributes.name "/" @))
        (modal-tag.on (+ @ ".bs.modal") (=>
          (message.send address { element: tag.root })
        ))
      ))
      (transfer-event "hidden")
      (transfer-event "shown")
    )
  </script>
</modal>

<buttons>
  <!-- ### spec: bootstrap >> Buttons >> Button Bar
  A simplistic component to group buttons into a tool-bar.
  ### -->
  <div class="btn-toolbar" role="toolbar" actor=body></div>
  <style>
    buttons > div.right { float: right; margin-right: 1em }
  </style>
  <script type=text/lispz>
    (tag.activate { body: (tag.fill) })
  </script>
</buttons>

<button-group>
  <!-- ### spec: bootstrap >> Buttons >> Button Groups
  Buttons in a group are pushed together without separating space.
  It is a good visual effect for radio buttons.
  ### -->
  <div class="btn-group" role="group" actor=body></div>
  <script type=text/lispz>
    (tag.activate { body: (tag.fill) })
  </script>
</button-group>

<push-button>
  <!-- ### spec: bootstrap >> Buttons >> Push Button
  Standard button representation - a button you push to take an action.

  When a button is pressed it will send a message with a topic of
  _button-name/on_ and _button-name/off_.

  Attributes are

  * **name**: Name of button - used to send the push messages
  * **type**: [*default|primary|success|info|warning|danger]
  * **size**: [*default|lg|sm|xs]
  ### -->
  <button class= "btn" actor=body,add-click-event></button>
  <script type=text/lispz>
    (using [message]
      (tag.activate {
        body:             (tag.fill)
        add-click-event:  (lambda [node]
          (node.addEventListener "click" (=>
            (message.send tag.attributes.name { node: tag })
          ))
        )
      })
    )
  </script>
</push-button>

<bars-menu>
  <!-- ### spec: bootstrap >> Menus

  A menu is a multi-level option selection.
  Both menu contents and results selected communicate by messages.

  Menu contents loading can be driven by the menu component or an external provider.
  For the former, the menu component sends out a message when a user asks to open the menu.
  It is up to a listener to provide the data requested.
  Use this if the menu contents change between uses.

        (message.listen "specifications-menu/open" (lambda
          (ref menu (dict.map lispz_modules (lambda [title source]
            (return {topic: "specifications" title source})
          )))
          (message.send "specifications-menu" (menu.sort))
        ))

  This example has a flat single-level list. All menus send a message when
  displayed with the name of the menu concatenated to _.open_.
  They also listen on the menu name as an address,
  so you can pass the resulting menu back.

  If an external controller knows when the menu changes,
  or if the menu is static, then send the contents to a named message address
  so that the specified menu can be reloaded. If this happens before the menu
  is displayed the menu will not be loaded.
  To fix this, wait for the menu to be ready.

        (after (message.ready> "specifications-menu")
          (message.send "specifications-menu" nenu)
        )
  The menu itself is a dictionary with the format:

       (ref test-menu
          [[
            { header: true title: "Heading 1" }
            { title: "Item 1" topic: "Test menu item 1" }
            { title: "Item 2" children: [[{ title: "Item 2a" }]] }
            { divider: true }
            { title: "item 2" disabled: true }
          ]]
        )
      (message.send "test-menu" test-menu)

  where _header_ and _divider_ are list separates that cannot be selected.
  For the rest, _title_ is the text displayed, _topic_ is part of the the address
  for the message sent, _children_ defines sub-menus and _disabled_ is for items
  that cannot be selected.

  If a menu item has a topic entry, a message will be sent to that an address
  made up of the component owner, dash, topic.

      (message.listen "Test Panel 2 - Test menu item 1" (lambda [data] (debug data)))

  ###
  ### spec: bootstrap >> Menus >> bars-menu

  This menu type displays three horizontal bars - sometime call a _hamburger_.
  Click it opens up a drop-down menu.

      <bars-menu align=left|center|right name=name owner=owning-component />

  The owner is prepended to the response to a menu selection so that the correct
  component can respond.
  ### -->
  <div name=dropdown class="dropdown" actor=align-bars>
    <a style="text-decoration: none" data-toggle="dropdown"
    class="glyphicon glyphicon-menu-hamburger dropdown-toggle"
    aria-hidden="true"></a>
    <ul class="dropdown-menu" actor=align-menu>
      <li class=template actor=each-item>
        <a href="#" actor=on-click>
          <span class="pointer right float-right" actor=branch>
          </span>
          <span actor=title></span>
        </a>
      </li>
    </ul>
  </div>
  <style>
    bars-menu > div.right { float: right }
    bars-menu span.caret { margin-left: -11px }
    bars-menu a.dropdown-toggle { cursor: pointer }
  </style>
  <script type=text/lispz>
    (using [message dom]
    (ref add-right-align-class (lambda [class-name]
      (lambda [node]
        (cond (is tag.attributes.align "right")
          (node.classList.add class-name)
        )
      )
      (tag.activate {
        each-item:  (lambda [template]
          (message.listen tag.attributes.name (lambda [items]
            (dom.node.empty ul)
            (tag.activate-template template items)
          ))
        )
        align-bars: (add-right-align-class "right")
        align-menu: (add-right-align-class "dropdown-menu-right")
      })
    )
    ))
  </script>
</bars-menu>

<sidebar>
  <!-- ### spec: bootstrap >> Side-bars
    A side-bar is a slide-in draw. When hidden it displays a string
    down the left side of the screen. Clicking on the 3-bars icon at
    the top will slide the panel in and out.
  ### -->
  <a aria-hidden="true" actor=handle
    class="glyphicon glyphicon-th-list text-danger"></a>
  <div name=sidebar class="container bg-primary" actor=sidebar></div>
  <style>

    sidebar .well {
      padding: 0px;
      margin: 5px 0 0 5px;
    }

    sidebar > a {
      text-decoration: none !important;
      position: absolute !important;
      z-index: 2000;
      cursor: pointer;
      left: 1px;
    }
    sidebar > div.container {
      z-index: 1000;
      position: fixed;
      width: 0;
      min-width: 18px;
      height: 100%;
      overflow: hidden;
      -webkit-transition: all 0.5s ease;
      -moz-transition: all 0.5s ease;
      -o-transition: all 0.5s ease;
      transition: all 0.5s ease;
      padding-right: 0;
      padding-top: 10px;
    }
    sidebar > div.toggled {
      width: auto;
      padding-right: 15px;
      overflow: auto;
    }

  </style>
  <script type=text/lispz>
    (using [message dom]
      (ref address (+ "sidebar/" tag.attributes.name))
      (ref sidebar (tag.sidebar))
      (tag.activate {
        handle:  (lambda [node]
          (stateful.morph! node {
            onclick:      (=> (sidebar.classList.toggle "toggled"))
            onmouseover:  (=> (sidebar.classList.add    "toggled"))
            onmouseleave: (=> (sidebar.classList.remove "toggled"))
          })
        )
        sidebar: (tag.fill)
      })
    )
  </script>
</sidebar>

<page-content>
  <div actor=wrapper>
    <div actor=container></div>
  </div>
  <style>
    #page_content_wrapper {
      width: 100%;
      position: absolute;
    }
  </style>
  <script type=text/lispz>
    (using [message dom]
      (tag.activate {
        wrapper:    (lambda [node]
          (message.listen "dom/resize-contents" (lambda [px]
            (dom.style! node {paddingLeft: (+ px "px")})
          ))
        )
        container:  (lambda [node]
          (node.classList.add (cond tag.attributes.fluid
            "container-fluid" (else) "container"
          ))
        )
      })
    )
  </script>
</page-content>

<bootstrap>
  <div id=page-wrapper></div>
  <style>
    .pointer {
      border: 5px solid transparent;
      display: inline-block;
      width: 0;
      height: 0;
      vertical-align: middle;
    }
    .pointer.float-right {
      float: right;
      margin-top: 5px;
    }
    .pointer.up {
        border-bottom: 5px solid;
    }
    .pointer.right {
        border-left: 5px solid;
    }
    .pointer.down {
        border-top: 5px solid;
    }
    .pointer.left {
        border-right: 5px solid;
    }
  </style>
  <script type=text/lispz>
    (using [dom]
      (dom.append! "head" (dom.node.create "meta"
        {name: "viewport" content: "width=device-width, initial-scale=1"}
      ))
    )
  </script>
</bootstrap>
