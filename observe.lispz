/*** Streams / ReactiveX / FRP / Promise / Events basics - more in rx.lispz ***/

(macro observer [] ((lambda []
  (var obs {observer: (lambda []) completed: (lambda []) error: (lambda[])})
  (set! obs.root obs) (return obs))))
(macro observable [] __)

(macro observe [action obs *body] ((lambda []
  (var parent __) (var r { root: parent.root observer: (lambda []) }) (var act (lambda obs *body))
    (set! parent.observer (lambda obs (var rc (act obs)) (action r rc) (return rc)))
  (return r))))

(macro map [obs *body] (observe (lambda [r rc] (r.observer rc)) obs *body))
(macro filter [obs *body] (observe (lambda [r rc] (cond rc (r.observer obs))) obs *body))
(macro for-each [obs *body] (observe (lambda [r rc] (r.observer obs)) obs *body))
(macro then [obs *body] (for-each obs *body))
(macro delay [ms] (observe (lambda [r rc] (setTimeout (lambda [] (r.observer rc)) ms)) [resp] (return resp)))

(macro on-completion [*body] ((lambda []
  (var parent __) (set! parent.root.completed (lambda [] *body)) (return parent))))
  
(macro on-error [*body] ((lambda []
  (var parent __) (set! parent.root.error (lambda [] *body)) (return parent))))

(macro observe.array [array] ((lambda []
  (var a ([array].slice)) (var r (observer)) (var once (lambda [] (yield
  (cond (> a.length 0) (once (r.observer (a.shift))) (else) (r.completed))
  ))) (once) (return r))))

(macro observe.callback [fn-builder] (return ((lambda [] (var r (observer))
  (fn-builder (lambda [event] (r.observer event))) (return r)))))

(var timeout (lambda [ms] (observe.callback (lambda [cb] (setTimeout cb ms)))))

(export {timeout})
