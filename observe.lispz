/*** Streams / ReactiveX / FRP / Promise / Events basics - more in rx.lispz ***/
/*
 * For namespacing. (observer (array [1 2 3]) (map [entry] ...))
 */
(macro observe [*body] *body)
/*
 * Creates a promise-like object for observables - being the first in the observer chain.
 * Has to point back to itself to mimic the observer promises. Runs a function that return
 * the promise for full (dis)closure.
 */
(macro observable [] (
  (lambda []
    (var root {observer: (lambda [])})
    (set! root.root root)
    (return root))
))

(macro #observe [action it *body] ((lambda []
  (var parent __)
  (var r { observer: (lambda []) root: parent.root })
  (var act (lambda it *body))
  (set! parent.observer (lambda it (var rc (act it)) (action r rc) (return rc)))
  (return r))))

(macro observe.map [it *body] (#observe (lambda [r rc] (r.observer rc)) it *body))
(macro observe.filter [it *body] (#observe (lambda [r rc] (cond rc (r.observer it))) it *body))
(macro observe.for-each [it *body] (#observe (lambda [r rc] (r.observer it)) it *body))
(macro observe.then [it *body] (for-each it *body))
(macro observe.delay [ms] (#observe (lambda [r rc] (setTimeout (lambda [] (r.observer rc)) ms)) [resp] (return resp)))

(macro observe.on-completion [*body] ((lambda []
  (var parent __) (set! parent.root.completed (lambda [] *body)) (return parent))))
  
(macro observe.on-error [*body] ((lambda []
  (var parent __) (set! parent.root.error (lambda [] *body)) (return parent))))

(macro observe.array [array] ((lambda [] (var root (observable))
  (var a ([array].slice)) (var once (lambda [] (yield
  (cond (> a.length 0) (once (root.observer (a.shift))) (else) (r.completed))
  ))) (once) (return root))))

(macro observe.callback [fn-builder] (return ((lambda [] (var root (observable))
  (fn-builder (lambda [event] (root.observer event))) (return root)))))

(macro observe.timeout (observe.callback (lambda [cb] (setTimeout cb ms))))

(export {})
