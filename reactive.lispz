/*** Streams / ReactiveX / FRP / Promise / Events basics - more in rx.lispz ***/

(macro observer [] ((lambda []
  (var obs {observer: (lambda []) completed: (lambda []) error: (lambda[])})
  (set! obs.root obs) (return obs))))
(macro observable [] __)

(macro observe [action obs *body] ((lambda []
  (var parent __) (var r { root: parent.root observer: (lambda []) }) (var act (lambda obs *body))
    (set! parent.observer (lambda obs (var rc (act obs)) (action r rc) (return rc)))
  (return r))))

(macro map [obs *body] (observe (lambda [r rc] (r.observer rc)) obs *body))
(macro filter [obs *body] (observe (lambda [r rc] (cond rc (r.observer obs))) obs *body))
(macro for-each [obs *body] (observe (lambda [r rc] (r.observer obs)) obs *body))
(macro then [obs *body] (for-each obs *body))

// bridge must be the end of the road - unless it returns another observable
(macro bridge [obs *body] (observe (lambda [r rc] (r.observer rc)) obs *body))

(macro on-completion [*body] ((lambda []
  (var parent __) (set! parent.root.completed (lambda [] *body)) (return parent))))
  
(macro on-error [*body] ((lambda []
  (var parent __) (set! parent.root.error (lambda [] *body)) (return parent))))

(macro array.observe [array] ((lambda []
  (var a ([array].slice)) (var r (observer)) (var once (lambda [] (yield
  (cond (> a.length 0) (once (r.observer (a.shift))) (else) (r.completed))
  ))) (once) (return r))))

(macro callback.observe [fn-builder] (return ((lambda [] (var r (observer))
  (fn-builder (lambda [event] (r.observer event))) (return r)))))

(macro timeout.observe [ms] (callback.observe (lambda [cb] (setTimeout cb ms))))

(export {})
