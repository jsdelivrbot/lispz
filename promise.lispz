(ref reject-promise (lambda [message data type]
  (ref name (or type "Promise-Error"))
  (ref error (stateful.morph! (new Error message)))
  (error.update! { name data })
  (#join '' 'throw ' error)
))
(global reject-promise reject-promise)
(global throw reject-promise)

(global promise {})
(global promise.rejected reject-promise)

(macro promise [?params *body] (lambda ?params
  (new Promise (lambda [resolve-promise catch-promise] *body))
))

(macro promise.callback [?params *body] (promise ?params
  (ref callback (lambda [err result]
    (cond err    (catch-promise  err)
          (else) (resolve-promise result)
    )
  ))
  *body
))
(global promise.resolved (promise [pact] (resolve-promise pact)))

(ref promised (lambda [pledge]
  (cond (and pledge pledge.then) pledge
        (else)                   (promise.resolved pledge)
  )
))
(global promised promised)

(macro when [pledge ?params *body]
  (ref #last-promise#
    ((promised pledge).then (lambda ?params *body))
  )
)

(macro when-rejected [*body] (#last-promise#.catch (=> *body)))

(macro promise.failed [pledge ?errors *body]
  ((promised pledge).catch (lambda ?errors *body))
)

(using [list]
  ### Promises >> promise.all
    Given a list of promises and constant data, will return a list of
    returned data when all the promises have been resolved.
  ###
  (global promise.all (=>
    (ref flattened (list.flatten (*arguments 0)))
    (ref promisified (flattened.map (=> (promised @))))
    (return (Promise.all promisified))
  ))
  ### ref: (promise.cascade> functions-that-return-data-or-promises)
    Each function is called with the value from the previous step
    after the promise is resolved. Returns last promise.
  ###
  (global promise.cascade> (lambda
    (ref promise-functions (list.flatten (*arguments 0)))
    ((promise
      (ref process-level (lambda [input functions]
        (cond functions.length (do
          (ref pledge (promised ((first functions) input)))
          (when pledge [output] (process-level output (rest functions)))
        ) (else)
          (resolve-promise input)
        )
      ))
      (process-level null promise-functions)
    ))
  ))
  ### ref: (promise.sequence> promise-or-data)
    e.g. (promise.sequence> (session>) (request @))
    is the same as (promise.cascade session> request)
  ###
  (macro promise.sequence> [*body]
    (#join '' '(_res_=lispz.globals.promise.cascade_g_(function(_t_){return '
      (#join '},function(_t_){return ' *body) '}))'
    )
  )
)

(export [])
