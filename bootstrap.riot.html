<!-- ### spec: Bootstrap
  # Bootstrap/RIOT/Lispz Combo
  
  There is a difference of scope between bootstrap and riot. Bootstrap is designed to be used page-widw. Riot is a web component system where each component should be as independent as possible.
  
  ## Page Level Bootstrap
  
  Any single page application that is going to use bootstrap to simplify the UI wraps the contents inside the body with a bootstrap tag. Use an inner page-content tag to allow for fluid layouts - those that change as the window changes size.
  
      <!-- using bootstrap code-editor --&gt;
      <body>
        <bootstrap class=riot>
          <page-content fluid=true>
            ...
          </page-content>
        </bootstrap>
      </body>
      
  ## Bootstrap Themes
  
  Bootstrap sites do not have to look alike. [Bootswatch](https://bootswatch.com/) provides 16+ free themes, including ones that fit in with Metro, Polymer and Ubuntu:
  
  > Default, Cerulean, Cosmo, Cyborg, Darkly, Flatly, Journal, Lumen, Paper, Readable, Sandstone, Simplex, Slate, Spacelab, Superhero, United, Yeti
  
  To select a theme, send a message to _change-bootstrap-theme_ with the name of the theme to change to. If you don't provide
  a theme name, a random one is chosen.
  
  ## Component Specific Bootstrap
  
  Riot components can include a _script_ section. If you preface all entries with the name of the component then you have effectively name-spaced your css.
  
      <code-editor>
        <panel height={ opts.height } heading={ heading } menu={ menu } owner={ _id }>
          <div name=wrapper class=wrapper></div>
        </panel>
        <style>
          code-editor .wrapper {
            ...
          }
      </code-editor>
### -->
<panel>
  <!-- ### spec: bootstrap >> Panels
    
    A panel is a UI component that provides decorations around your content.
    The header includes a title and a menu button.
    An optional footer can include more text.
    
        <panel [context=default|primary|success|info|warning|danger]
                  [heading=heading-text] [footer=footer-text]
                  [menu=menu-id] height=[nn%,nn]>
          panel-body-content-html
        </panel>
    
    The context defines the colours use for the decoration.
    The _menu-id_ is used to listen on a messaging channel that
    can publish menu contents.
    
        <panel [context=default|primary|success|info|warning|danger]
                [heading=heading-text] [footer=footer-text]
                [menu=menu-id] height=[nn%,nn]>
         panel-body-content-html
         </panel>
    ### -->
  <div class="panel { context }" name=outer>
    <div class=panel-heading if={ opts.heading } name=heading
         ><bars-menu align=right name={ opts.menu } owner={ opts.owner }/>
         <h3 class=panel-title>{ opts.heading }</h3></div>
    <div class="panel-body" name=body><yield/></div>
    <div class=panel-footer if={ opts.footer } name=footer
         >{ opts.footer }</div>
  </div>

  <style>
    panel .panel {
      position: relative;
    }
    panel .panel-title {
      cursor: default;
    }
    panel .panel-body {
      position: absolute;
      top: 40px;
      bottom: 2px;
      left: 0;
      right: 2px;
    }
  </style>

  <script type=text/lispz>
    (var tag (stateful.morph! this))
    (tag.on "mount" (=> (using [dom]
      (tag.update! {context: (+ "panel-" (or opts.context "default"))})
      (cond opts.height (do
        (var px opts.height)
        (cond (is "%" (opts.height.slice -1))
          (var px (/ (* window.innerHeight (opts.height.slice 0 -1)) 100))
        )
        (dom.style! tag.outer.style.height (+ px "px"))
      ))
    )))
  </script>
</panel>

<modal>
  <!-- ### spec: bootstrap >> Modals

  Modals pop up and deny access to the rest of the page until they are dismissed.
  
      <modal name=n [title=heading-text] [buttons=a,*b]
        [context=default|primary|success|info|warning|danger]>
          modal-body-content-html
      </modal>
  
  Buttons are added to a footer, with the one starting with a star being the default.
  When a modal button is pressed it will send a message with a topic of
  _modal-name/button-name/button_.
  
      <modal name=login-dialog title="..." buttons="Log in,Cancel">...</modal>
      ....
      (message.listen "login-dialog/Log in/button" (=> ...)
      
        <modal name=n [title=heading-text] [buttons=a,*b]>
          modal-body-content-html
        </modal>
  ### -->
  <div class="modal fade" role="dialog" aria-labelledby={ opts.name }>
    <div class="modal-dialog" role="document">
      <div class="modal-content">
        <div class="modal-header" if={ opts.title }>
          <button type="button" class="close" data-dismiss="modal" aria-label="Close">
            <span aria-hidden="true">&times;</span>
          </button>
          <h4 class="modal-title" id={ opts.name }>{ opts.title }</h4>
        </div>
        <div class="modal-body"><yield/></div>
        <div class="modal-footer">
          <button each={ buttons } class="btn btn-{ type }" name={ name }>
            { title }
          </button>
        </div>
      </div>
    </div>
  </div>
  <style>
  </style>
  <script type=text/lispz>
    (var tag (stateful.morph! this))
    (cond opts.buttons (do
      (tag.update! {buttons: [[]]})
      ((opts.buttons.split ",").forEach (lambda [title]
        (var primary (is "*" (first title))  type "default")
        (cond primary (do (var type "primary") (title.shift)))
        (var name title)
        (tag.buttons.push { title type name })
      ))
    ))
  </script>
</modal>

<bars-menu>
  <!-- ### spec: bootstrap >> Menus

  A menu is a multi-level option selection.
  Both menu contents and results selected communicate by messages.
  
  Menu contents loading can be driven by the menu component or an external provider.
  For the former, the menu component sends out a message when a user asks to open the menu.
  It is up to a listener to provide the data requested.
  Use this if the menu contents change between uses.
  
        (message.listen "specifications-menu-open" (=>
          (var menu (dict.map lispz_modules (lambda [title source]
            (return {topic: "specifications" title source})
          )))
          (message.send "specifications-menu" (menu.sort))
        ))
        
  This example has a flat single-level list. All menus send a message when
  displayed with the name of the menu concatenated to _.open_.
  They also listen on the menu name as an address,
  so you can pass the resulting menu back.
  
  If an external controller knows when the menu changes,
  or if the menu is static, then send the contents to a named message address
  so that the specified menu can be reloaded. If this happens before the menu
  is displayed the menu will not be loaded.
  To fix this, wait for the menu to be ready.
  
        (when (message.ready "specifications-menu") []
          (message.send "specifications-menu" nenu)
        )        
  The menu itself is a dictionary with the format:
  
       (var test-menu
          [[
            { header: true title: "Heading 1" }
            { title: "Item 1" topic: "Test menu item 1" }
            { title: "Item 2" children: [[{ title: "Item 2a" }]] }
            { divider: true }
            { title: "item 2" disabled: true }
          ]]
        )
      (message.send "test-menu" test-menu)
      
  where _header_ and _divider_ are list separates that cannot be selected.
  For the rest, _title_ is the text displayed, _topic_ is part of the the address
  for the message sent, _children_ defines sub-menus and _disabled_ is for items
  that cannot be selected.
  
  If a menu item has a topic entry, a message will be sent to that an address
  made up of the component owner, dash, topic.
  
      (message.listen "Test Panel 2 - Test menu item 1" (lambda [data] (debug data)))
  
  ## bars-menu
  
  This menu type displays three horizontal bars - sometime call a _hamburger_.
  Click it opens up a drop-down menu.
  
      <bars-menu align=left|center|right name=name owner=owning-component />
      
  The owner is prepended to the response to a menu selection so that the correct
  component can respond.
  ### -->
  <div name=dropdown class="dropdown { right: opts.align === 'right' }">
    <a style="text-decoration: none" data-toggle="dropdown" name=bars
    class="glyphicon glyphicon-menu-hamburger dropdown-toggle" aria-hidden="true"
    ></a>
    <ul class="dropdown-menu { dropdown-menu-right: opts.align === 'right' }">
      <li each={ items } class={ dropdown-header: header && title,
          divider: divider, disabled: disabled }><a onclick={ goto } href="#">
          <span class="pointer right float-right" if={ children }></span>
          { title }&nbsp;&nbsp;&nbsp;
      </a></li>
    </ul>
  </div>
  <style>
    bars-menu > div.right { float: right }
    bars-menu span.caret { margin-left: -11px }
    bars-menu a.dropdown-toggle { cursor: pointer }
  </style>
  <script type=text/lispz>
    (var tag (stateful.morph! this))
    (tag.on "mount" (=> (using [message riot]
      (message.listen opts.name (lambda [items]
        (riot.update! tag {items root: (or items [[]])})
      ))
      (($ tag.dropdown).on "show.bs.dropdown" (=>
        (message.send (+ opts.name "-open"))
        (riot.update! tag {items: root})
      ))
      (tag.update! {goto: (lambda [ev]
        (cond ev.item.topic (message.send
          (+ opts.owner "-" ev.item.topic)
          {item: ev.item owner: opts.owner action: "select"}))
        (cond ev.item.children (do
          (tag.update! items ev.item.children)
          (ev.currentTarget.blur)
          (ev.stopPropagation)
        ))
      )})
    )))
  </script>
</bars-menu>

<!-- ### spec: bootstrap >> Trees
  A tree provides an identical interface to a menu.
  Visually all levels to the current selection remain displayed.
  Selecting a branch will toggle it opened or closed.
  Selecting a leaf will send a message to the owning component.
### -->
<tree>
  <tree-component name=base/>
  <script type=text/lispz>
    (var tag (stateful.morph! this))
    (using [message riot]
      (message.listen opts.name (lambda [items]
        (riot.update! tag {children: {base: {children: items}}})
        (tag.update) ## once more for luck
      ))
    )
  </script>
</tree>

<tree-component>
  <ul class="dropdown-menu">
    <li each={ item, i in items }
        class={ dropdown-header: item.header && item.title,
        divider: item.divider, disabled: item.disabled }
        ><a onclick={ parent.goto } href="#">
        <span if={ item.children }
              class="glyphicon glyphicon-triangle-right"
              aria-hidden="true"></span>{ item.title }</a>
        <tree-component if={ item.children } name={ item.title }>
    </li>
  </ul>
  <style>
    tree-component ul {
      display: inherit !important;
      position: inherit !important;
    }
    tree-component:not([name=base]) > ul {
      display: none !important;
    }
    tree-component:not([name=base]).open > ul {
      margin-left:  9px;
      margin-right: 9px;
      display: inherit !important;
    }
    tree-component span.glyphicon {
      margin-left: -18px;
    }
  </style>
  <script type=text/lispz>
    (var tag (stateful.morph! this))
    (using [message dict]
      (tag.on "update" (lambda [data]
        (cond (and opts.name tag.parent.children) (do
          (tag.update! {items: (get tag.parent.children opts.name "children")})
          (cond (and tag.items tag.items.length)
                (tag.update! {children: (dict.from-list tag.items "title")})
          )
        ))
      ))

      (tag.update! {goto: (lambda [ev]
        (var item ev.item.item)
        (var topic (or item.topic item.title ))
        (cond topic (message.send topic
          {item action: "select"}))
        (cond item.children (do
          (var tree ev.currentTarget.nextElementSibling)
          (tree.classList.toggle "open")
          (tree.parentElement.classList.toggle "bg-info")
        ))
        (ev.stopPropagation)
      )})
    )
  </script>
</tree-component>

<!-- ### spec: bootstrap >> Side-bars
  A side-bar is a slide-in draw. When hidden it displays a string
  down the left side of the screen. Clicking on the 3-bars icon at
  the top will slide the panel in and out.
### -->
<sidebar>
  <a aria-hidden="true" name=hamburger
    class="glyphicon glyphicon-menu-hamburger"></a>
  <div id=sidebar class="container bg-primary"><yield/></div>
  <style>
    sidebar > a {
      text-decoration: none !important;
      position: absolute !important;
      z-index: 2000;
    }
    #sidebar {
      z-index: 1000;
      position: fixed;
      width: 0;
      height: 100%;
      overflow-y: auto;
      -webkit-transition: all 0.5s ease;
      -moz-transition: all 0.5s ease;
      -o-transition: all 0.5s ease;
      transition: all 0.5s ease;
      padding-right: 0;
      overflow: hidden;
    }
    #sidebar.toggled { width: auto; padding-right: 15px; }
  </style>
  <script type=text/lispz>
    (var tag (stateful.morph! this)  hamburger (stateful.morph! tag.hamburger))
    (using [message dom]
      (hamburger.update: {onclick: (=>
        (tag.sidebar.classList.toggle "toggled")
        (delay 300 ## must be after slide action
          (message.send "page-content-wrapper-padding" tag.sidebar.offsetWidth)
        )
      )})
      (tag.on "mount" (delay 300
        (message.send "page-content-wrapper-padding" tag.sidebar.offsetWidth)
      ))
    )
  </script>
</sidebar>

<page-content>
  <div id=page_content_wrapper>
    <div class={ container-fluid: opts.fluid, container: !opts.fluid }>
      <yield/>
    </div>
  </div>
  <style>
    #page_content_wrapper {
      width: 100%;
      position: absolute;
    }
  </style>
  <script type=text/lispz>
    (var tag this)
    (using [message dom]
      (message.listen "page-content-wrapper-padding" (lambda [px]
        (dom.style! tag.page-content-wrapper.style.paddingLeft (+ px "px"))
      ))
    )
  </script>
</page-content>

<bootstrap>
  <div id=page-wrapper><yield/></div>
  <style>
    .pointer {
      border: 5px solid transparent;
      display: inline-block;
      width: 0;
      height: 0;
      vertical-align: middle;
    }
    .pointer.float-right {
      float: right;
      margin-top: 5px;
    }
    .pointer.up {
        border-bottom: 5px solid;
    }
    .pointer.right {
        border-left: 5px solid;
    }
    .pointer.down {
        border-top: 5px solid;
    }
    .pointer.left {
        border-right: 5px solid;
    }
  </style>
  <script type=text/lispz>
    (var tag (stateful.morph! this))
    (using  [dom net jquery riot message bootstrap]
      (var bootswatch-themes [[ "cerulean" "cosmo" "cyborg" "darkly" "flatly"
        "journal" "lumen" "paper" "readable" "sandstone" "simplex" "slate"
        "spacelab" "superhero" "united" "yeti" ]])
      ###
      # https://bootswatch.com
      # Loads a bootswatch theme to make the page look different.
      # If no theme is provided, a random one is selected.
      ###
      (message.listen "change-bootstrap-theme" (lambda [theme]
        (cond (not (defined? theme))
          (var theme (get bootswatch-themes (random bootswatch-themes.length)))
        )
        (net.css (+ "https://bootswatch.com/" theme "/bootstrap.css"))
      ))
      (dom.append! "head" (dom.element "meta"
        {name: "viewport" content: "width=device-width, initial-scale=1"}
      ))
    )
  </script>
</bootstrap>
