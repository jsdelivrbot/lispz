### spec: async >> Messaging
###
### spec: async >> Messaging >> exchange
  The exchange is a location (box) that keeps lists of observers for each
  known address.
###
(using [list dict]
  (ref exchange (stateful))
  (ref in-exchange (pull exchange))

  (ref add-to-exchange (=>
    (ref box (stateful []))
    (exchange.update! @ box)
    box
  ))

  ### spec: async >> Messaging >> (clear)
    Clear al observers from a message box.
  ###
  (ref clear (lambda [matcher]
    (cond
      (instance-of RegExp matcher) (do
        (list.for-each (dict.filter exchange (=> matcher.test @))
          (=> (add-to-exchange @))
        )
      ) (else)
        (add-to-exchange @)
    )
  ))

  ### spec: async >> Messaging >> (observers)
    given an address return the list of recipients who are interested in
    mail sent to this address. It will create a new list of observers
    if needed.
  ###
  (ref observers (lambda [address]
    (ref observer (or (in-exchange address) (add-to-exchange address)))
    observer
  ))

  ### spec: async >> Messaging >> Sources >> (post>)
    Send a message directly to an address so that it is picked up by
    all observers directly. It is curried so specific functions can
    be created to send to specific addresses. Send returns a promise
    that is fulfulled when all listeners have responded.

        (when (message.post> "examples/my-address"
          { msg: "whatsit" read-now: true }
        ) [results context] ...)
        ## is the same as
        (ref post-to-me (message.post> "examples/my-address"))
        (when (post-to-me { msg: "whatsit" read-now: true }) [results] ...)
  ###
  (ref post> (curry [address packet]
    (ref postman (=> (promised (@.action> packet @))))
    (promise.all ((observers address).map postman))
  ))

  ### spec: async >> Messaging >> Sources >> (observe)
    Observe the passage of a message. An action is called with the packet
    and a reference to the observer object as stateful local context.
    The action can return a promise and preferably not do anything too
    time-costly in-process. Observe is curried.
  ###
  (ref observe (curry [address action>]
    ((observers address).push! (stateful { action> }))
  ))

  ### spec: async >> Messaging >> Sources >> (dispatch)
    Dispatch is a specialised version of observe where a number of actions
    can be defined and messages built to dispatch to them.

        (ref open  (=> ...))
        (ref close (=> ...))
        (message.dispatch "my-component" { open close })

    Each action creates a separate message-box using the given address followed
    by the action name. In this example, _my-component/open_ and _my-component/close_.
  ###
  (ref dispatch (lambda [address actions]
    (dict.for-each actions (lambda [name action>]
      (message.observe (+ address "/" + name) action>)
    ))
  ))

  ### spec: async >> Messaging >> Sources >> (observe)
    You can post to a dispatched action directly, as in

        (message.post "my-component/open" "file-name.txt")

    or you can create a curried connector.

        ((message.connector "my-component" "open") "file-name.txt")
        ## is the same as
        (ref my-component (message.connector "my-component"))
        ((my-component "open") "file-name.txt")
        ## is the same as
        (ref open-in-my-component (message.connector "my-component" "open"))
        (open-in-my-component "file-name.txt")
  ###
  (ref connector (curry [address action-name]
    (ref full-address (+ address "/" action-name))
    (=> (message.post.apply ([[full-address]].concat arguments)))
  ))

  ### spec: async >> Messaging >> Sources >> (combine-address)
    Mapping and filtering messages are given source and target
    addresses. If the target address starts with a / it is used
    alone, otherwise the source and target addresses are concatenated.

        (combine-address "left" "right")  ## left/right
        (combine-address "left" "/right") ## right
  ###
  (ref combine-address (lambda [from to]
    (cond
      (is (first to) "/")   (slice to 1)
      (else)                (+ from "/" to)
    )
  ))

  ### spec: async >> Messaging >> Sources >> (from.dom)
    Start a message stream from different sources. All curried
    to create convenient functions.

        (message.from.dom "click" "my-message-address" document.body)
        ## is the same as
        (message.from.click "my-message-address" document.body)

    both will send messages to address _dom-click/my-message-name/_. For
    convenience the method returns the full address for mapping and filtering.
  ###
  (ref from (stateful {
    dom:  (curry [event-name to element]
      (ref address (combine-address (+ "dom-" event-name) to))
      (element.addEventListener event-name (=> (message.post> address @)))
      address
    )
  }))
  (from.update! {
    click: (from.dom "click")
  })

  ### spec: async >> Messaging >> Observers >> (map)
    Map message streams to change the results
        (ref @click (message.from.click "my-message-address" document.body))
        (ref @mouse (message.map @click "mouse" (lambda [event]
          {x: event.clientX  y: event.clientY}
        )))
        (message.observe @mouse (=> (console.log @.x @.y)))
  ###
  (ref message-map (lambda [from to mapper]
    (ref address (combine-address from to))
    (message.observe from (=> (message.post> address (mapper @))))
    address
  ))

  ### spec: async >> Messaging >> Observers >> (filter)
    Map message streams to change the results
        (ref @click (message.from.click "my-message-address" document.body))
        (ref @mouse (message.map @click "mouse" (lambda [event]
          {x: event.clientX  y: event.clientY}
        )))
        (ref @top-left (message.filter @mouse "top-left" (lambda [pos]
          (< pos.x pos.y)
        )))
        (message.observe @top-left (=> (console.log @.x @.y)))
  ###
  (ref message-filter (lambda [from to filterer]
    (ref address (combine-address from to))
    (message.observe from (=> (cond (filterer @) (message.post> address @))))
    address
  ))

  ### spec: async >> Messaging >> Sources >> (trace)
    Turning tracing on will display messages posted and received to
    the browser console. Use a regular expression to reduce the number
    of messages to a manageable amount. A parameter of false will turn
    trace off again.
  ###

  (ref with-tracing (lambda [name action filterRE has-packet]
    (lambda [address packet]
      (cond (filterRE.test address)
        (console.trace name "\t" address (cond has-packet packet (else) ""))
      )
      (action address packet)
    )
  ))

  (ref set-trace (lambda [filterRE]
    (message.update! {
      post>:   (with-tracing "POST   "  post>   filterRE true)
      observe: (with-tracing "OBSERVE"  observe filterRE false)
    })
  ))

  (ref trace (=>
    (cond
      (is @ false)    (message.update! { post> observe })
      (not @)         (set-trace '/.*/')
      (else)          (set-trace @)
    )
  ))

  (ref message (stateful {
    post> observe dispatch connector clear trace from
    map: message-map filter: message-filter
  }))
  (export message)
)
